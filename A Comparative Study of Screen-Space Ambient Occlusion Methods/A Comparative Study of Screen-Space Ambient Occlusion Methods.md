---
title: A Comparative Study of Screen-Space Ambient Occlusion Methods [@Aalund2013]
---
# はじめに {#sec:1}

## 動機 {#sec:1.1}

シャドウは物体同士の空間的な関係を見た目に判断するための手がかりとなる。シャドウがないと、平坦に見えたり浮遊しているように見えたりする。

シャドウの計算は大縮尺[large-scale]シャドウと小縮尺[small-scale]シャドウに分けられる。アンビエントオクルージョンは後者に含まれる。

## 大まかな歴史 {#sec:1.2}

アンビエントオクルージョンは初めにレイトレーシングで使われ、次に、リアルタイムのインタラクティブアプリケーションでの前処理工程[@Moller2008]で使われるが、これは静的なワールドに制限される。2007年以降、いわゆる*スクリーンスペース[screen-space]*のアプローチを用いて、期待される他の効果と一緒に、オンザフライかつリアルタイムに実現可能であることが証明されてきた[@Mittring2007a; @Shanmugam2007; @Nguyen2007]。これはアニメーションや物理を含む動的な環境で上手く動作する。さらに、遮蔽データの事前計算が必要ないため、アーティストやメモリの予算を軽減する。

スクリーンスペースアンビエントオクルージョン(SSAO)はいくつかの欠点も持ち合わせている。レイトレーシングは一般に優れた画像を生成し、他の大局照明効果とうまく統合する。SSAOも時折近しい所まで行くが、いくつかはcolor-bleeding効果を含んでいたりもする[@Ritschel2009]。依然として、高速化には情報を破棄する必要があるが、それ故に品質に悩まされるだろう。一般則として、品質を良くしようとすればそれだけパフォーマンスコストがかかるが、アルゴリズム的な発展は大いに役立つ可能性がある。

## プロジェクト {#sec:1.3}

## 報告の概要 {#sec:1.4}

# 背景 {#sec:2}

## レンダリング理論 {#sec:2.1}

光と表面の間の相互作用は複合的であり、故に、リアルタイム用途ではかなり近似される。それを行う歴史的に有名な方法は光を*ディフューズ[diffuse]*、*スペキュラ[specular]*、*アンビエント[ambient]*の構成要素に分けることである[@Cook1982]。この議論では、前者2つ(ディフューズとスペキュラ)を*直接光[direct light]*、光源から直接来る光とすれば事足りる。アンビエント光はすべての*間接光[indirect light]*、直接光でないすべての光である。例えば、任意の回数の反射または屈折を経験した光がある。

与えられた表面点[surface point]と方向に対して物理的に正しい間接光を計算することは計算的に難しい。各表面点$\boldsymbol{p}$と方向$\omega$の対は以下の関連する量を持つ。

- $L_o$、与えられた方向$\omega$に対する$\boldsymbol{p}$における出射する[outgoing]放射輝度。
- $L_i$、与えられた方向$\omega$に対する$\boldsymbol{p}$における入射する[incomming]放射輝度。
- $f$、$\boldsymbol{p}$における$\omega$に沿った出射する放射輝度と入射方向$\omega_i$に沿った入射する放射照度[incident irradiance]の比。双方向反射率分布関数[bidirectional reflectance distribution function] (BRDF)として知られている。

3つすべての量の間の相互作用はずっと複雑である[@Kajiya1986]。

$$
L_o = \int f L_i \cdot (n \cdot \omega) d\omega
$$ {#eq:2.1}

## アンビエントオクルージョン {#sec:2.2}

アンビエント光は*すべて*の入射方向に対して集約された間接光である。これは、アンビエント光を決定するためには[@eq:2.1]の積分を計算しなければならない、ということである。これはアンビエント光を更なる仮定なしに扱いづらい量にしている。そこで、状況を改善するため、かなり大量の仮定が作られている[@Cook1982]。

- アンビエント光は一様に入射する。すなわち、入射する放射輝度はすべての方向で同じになる($L_i$は定数)。
- アンビエント光は見ている角度に依存しない。すなわち、反射した光の比はすべての方向で同じになる($f$は定数であり、その表面は*ランバート[Lambertian]*である)。

合わせて、これらの近似はアンビエント光のより単純なモデルをもたらす。

$$
L_{oa} = f L_{ia} \int (n \cdot \omega) d\omega
$$ {#eq:2.2}

[@eq:2.2]の積分は$\boldsymbol{p}$における半球の可視性であり、まずは以下のように書き表すとする。

$$
A(\boldsymbol{p}) = \frac{1}{\pi} \int (n \cdot \omega) d\omega
$$ {#eq:2.3}

ここで、$\boldsymbol{p}$は照らされている点であり、$n$は$\boldsymbol{p}$における表面の法線であり、$\omega$は積分の方向である。この積分は$\boldsymbol{p}$と$n$によって定義される半球の*遮蔽されていない[unoccluded]*部分に対してである。内積$n \cdot \omega$はこの文脈においてその意味が変化し、浅い角度でのオクルーダーが大きな範囲に投影されるという事実を考慮するために可視性を調整する。

$A$はアンビエント光のオクルージョンを計算に入れる。古典的な単純化では積分計算を回避するために$A=1$を用いる。モダンな実装では[@eq:2.3]によるオリジナルの定義を用いて、$\boldsymbol{p}$から可視である方向に入射するアンビエント光$L_{ia}$を制限する。

### 半球の定義 {#sec:2.2.1}

関数$V(\boldsymbol{p}, \omega)$を方向$\omega$における$\boldsymbol{p}$からのレイの*可視性[visibility]*とすると、$V$は以下のように定義される。

$$
V(\boldsymbol{p}, \omega) = \begin{cases}
0 & \text{方向} \omega \text{における} \boldsymbol{p} \text{からのレイがなにかに当たる場合} \\
1 & \text{その他}
\end{cases}
$$

すると、半球全体で計算するために$A$を拡張できる。その新しい積分は以下となる。

$$
AO(\boldsymbol{p}) = \frac{1}{\pi} \int_{\Omega} V(\boldsymbol{p}, \omega) (n \cdot \omega) d\omega
$$ {#eq:2.4}

ここで、$\Omega$は$\boldsymbol{p}$と$\omega$によって定義される半球である。アンビエントオクルージョン(AO)[@Landis2002]という用語は基本の式の長らく後に新造された。離散的な方向数をテコ入れすることでレイトレーサーでのモンテカルロ積分によって定めることができる[@Landis2002]。

$$
AO \approx \frac{1}{N} \sum_{n=1}^{N} V \cdot (n \cdot \omega_n)
$$

ここで、$N$は調査用[probe]のレイの数であり、$\omega_n$は各$n$に対して一様に無作為に選ばれた方向である。

## Ambient Obscurance {#sec:2.3}

開口部が小さくて抜け出せるレイが極わずかである、すなわち、ほとんどの部分で$V$が0となる場合、[@eq:2.4]で与えられるようなAOの式でレンダリングすると、ほぼ識別不可能なほどに暗くなる。これは望ましくなく、我々は見た目に満足な結果をもたらすAOのさらに実践的な定義を必要とする。

Ambient Obscurance[@Zhukov1998]は可視性の関数$V$を距離$d$に基づく減衰(フォールオフ)関数$\rho(d)$で置き換える。関数$\rho$は経験的に選ばれるが、以下のような一般的な特性を持つ必要がある。

- $\rho$は$d$の単調増加関数である。
- $d > d_{max}$に対する$\rho(d) =1$となるような上限$d_{max}$が存在する。

$\rho$によるアイデアは遠くのオクルーダーが受ける影響を少なく、または、一切なくすることにある。これは結果の画像を一般に明るくし、見た目に満足な結果を生み出す。$\rho$は物理ベースではなく、審美眼に基づいて完全に選択されることに注意すべきである。Ambient Obscuranceの定義はすでに見てきたものと似ている。

$$
AO^{* }(\boldsymbol{p}) = \frac{1}{\pi} \int_{\Omega} \rho(|\boldsymbol{p}\omega - \boldsymbol{p}|)(n \cdot \omega) d\omega
$$ {#eq:2.5}

ここで、$|\boldsymbol{p}\omega-\boldsymbol{p}|$は$\boldsymbol{p}$から調査用レイにヒットした最初の表面への距離である。

$V$は本当に単に$d_{max}=\infty$での$\rho$の特殊なケースであることに注意する。

## Inversion {#sec:2.4.1}

$AO$関数はアンビエントの*遮蔽[occlusion]*を示そうとしているにも関わらず、*可視性*によって増加する($AO=1$で完全に可視であることを示す)。そのため、著者によっては以下のように定義を反転するのを好む場合がある。

$$
AO = 1 - \int \dots
$$

これは多かれ少なかれ好みの問題であり、このレポートでは、各手法で与えられる定義を用いる。

## リアルタイムレンダリング {#sec:2.5}

### 変換、空間、座標 {#sec:2.5.1}

### ディファードレンダリング {#sec:2.5.2}

### シェーダ {#sec:2.5.3}

# 解析 {#sec:3}

## レイトレーシングとラスタライゼーション {#sec:3.1}

歴史的に、AOはレイトレーサーのために用意された機能であったが、レイトレーサーはGPUが活用するラスタライゼーションアプローチと互換性がないため、大きな商業基盤におけるインタラクティブなリアルタイムレンダリングでは用いられていない。

## 以前の研究 {#sec:3.2}

### ディスクプロキシ {#sec:3.2.1}

このアルゴリズムはディスク要素に分解されたシーンのすべてのポリゴンメッシュを入力として必要とする。そのアイデアはシーン中のジオメトリを遮蔽するディスク数を確認することにある[@Pharr2005]。これが初めて提案されたAO実装に対するレイトレーシングの代替案であり、後に、結果を平滑化することで改良された[@Nguyen2007]。

### アンシャープマスキング {#sec:3.2.2}

[@Luft2006]

### 最初のスクリーンスペースアプローチ {#sec:3.2.3}

#### シーン近似としての深度バッファ

深度バッファは、元々の目的を越えて、シーンの粗い表現として働くことも可能である[@Mittring2007a; @Shanmugam2007]。

#### 拡張されたパイプライン

AOは入力に深度バッファのみを用いるため、同じく入力に深度バッファを用いるシェーディングパスでAOを計算させることができるが、低解像度で計算したりパフォーマンス特徴の割り出しがし易かったりするので、専用のAOパスで計算したほうが良い。

#### スクリーンスペース積分

シーンを深度バッファで表現することで、[@eq:2.5]の積分を解くいくつかの興味深いアプローチが可能となる。

方法のひとつは標本点[sample point]近くでの遮蔽と可視の比で$AO$を近似することである[@Mittring2007a; @Mittring2007b; @Dachsbacher2009]。

$$
AO \approx \frac{1}{N} \sum_{n=1}^{N} V'(s_n)
$$ {#eq:3.1}

ここで、$N$は標本点の数であり、$s_n$は$n$番目の標本点であり、$V'$は$s_n$が可視であれば$1$、そうでなければ$0$である。$s_n$の標本点は半径$r$を持つ$\boldsymbol{p}$周辺の球に拡散される。

現在の点$\boldsymbol{p}$は始めに再構築されなければならず、計算コストが低いスクリーン座標で$\boldsymbol{p}$を再構築するアプローチが選ばれる。$\boldsymbol{p}_{xy}$は現在のピクセル座標であり、$\boldsymbol{p}_z$は深度バッファから直接読み出すことができる。$\boldsymbol{p}$が定まれば、周囲の球に標本点を選ぶことは自明となるはずである。しかし、手法の著者が記す通り、これはアーティファクトの源となり得る。

標本の位置$\boldsymbol{s}$は$\boldsymbol{p}$と同様にスクリーン座標上にあり、関連する$\boldsymbol{s}_z$の座標を持つ。$\boldsymbol{s}$の上にある表面の深度は$\boldsymbol{s}_d = \text{depth}(\boldsymbol{s}_{xy})$として深度バッファから読み出すことができる。後は単純な比較を行うだけで可視性が定まる。

$$
V'(\boldsymbol{s}) = \begin{cases}
1 & \boldsymbol{s}_d > \boldsymbol{s}_z \\
0 & \text{その他}
\end{cases}
$$

この手法([@eq:3.1])は元の式([@eq:2.5])にあるような半球ではなく、$\boldsymbol{p}$の周囲の球の中でサンプルすることにも注意する。すなわち、平坦な表面に対してでさえ、サンプルの半分が遮蔽されることを期待しなければならない。

理論上よろしくても、標本分布の問題が残っている。標本位置が$\boldsymbol{p}$ごとに固定される場合、結果のAOはバンディングアーティファクトを持つだろうから、代わりに、標本位置を一様に無作為に分布させる。これはバンディングアーティファクトを除去するが、高周波ノイズを引き起こす。著者らはAO計算上でジオメトリ対応[geometry-aware]のブラーを適用することでノイズを回避する。残念ながら、GPUの特徴により、ブラーはそれ自身のシェーダパスで行われなければならない。もうひとつの障害はシェーダプログラムが乱数をを生成できないことであるため、代わりに、事前に計算した乱数のバッファをAOシェーダに供給する。

#### バリエーション

以下に概略される差異を持つ前述の手法のバリエーション[@Filion2008]が存在する。

標本位置はワールド座標で探し、深度比較のためにスクリーン座標へ投影される。著者らは、単純な比較関数$V'$を前に使っていたが、減衰関数$\rho$も再導入している。これは高い$\boldsymbol{s}_d$の値を持つ前面のオブジェクトに起因する過剰な遮蔽[over-occlusion]を軽減する。前述の通り、標本の半分はデフォルトで遮蔽されていると扱われるので、代替アプローチではまず球の中の標本を探すが、表面の法線$n$に従って半球にこれらをflip backする。事実上、サンプルの半数がこのアプローチでは必要になる。

#### 球プロキシ

スクリーンスペースで動作し、多くの特性を共有する、[@Mittring2007a]と同時期に独立して開発された手法は、球プロキシで表現される表面近くの遮蔽を平均することで$AO$を近似する[@Shanmugam2007]。この手法は、[@Mittring2007a]と同様に、スクリーン座標で$\boldsymbol{p}$を再構築し、同様にスクリーン座標で$\boldsymbol{p}$の周りの*ディスク*内の$N$ケのサンプル$s_n$を分布させる。これは、その類似性がstopであった場合、各サンプル$s$が$s_z = s_d$で表面に投影されるので、ワールド座標への変換に従う。球は近くの表面を近似することを意図している各ワールド空間$s$に位置する。球の半径は$s_d$の関数である。$AO$は球が$p$で半球を遮蔽するサンプル数の合計として近似される。これは単に[@Mittring2007a]に見られる$V'$のような比較関数ではないことに注意する。

上記で述べられる手法は非常に込み入っており、他の提案と比較して非常に異なって$AO$の近似に取り掛かる。

### A Horizon-Based Approach {#sec:3.2.4}

$AO$を近似するもうひとつの方法は$p$周りの半球上で見える地平線の角度$h$を定めることによるものである[@Bavoil2008a; @Bavoil2008b; @BavoilSainz2008; @Dachsbacher2009]。高さフィールドが連続的であるという仮定の下では、この角度を越えてトレースされるレイは遮蔽されるはずである。さらに、視線ベクトルの周りに与えられた角度$\theta$に対する地平線の角度$h(\theta)$が求まると仮定する。我々は視線ベクトル周りの*すべての*$\theta$に対する$h$の平均を求めたい。この手法の著者らはそれを行うために以下の式を提示する。

$$
AO = 1 - \frac{1}{2\pi} \int_{\theta=-\pi}^{\pi} AO_{horizon}(\theta)d\theta
$$ {#eq:3.2}

ここで、積分は視線ベクトルの周りのすべての角度$\theta$全体で行われる。$AO$の定義が反転していることに注意する。

すると、与えられた$\theta$に対しいて$AO_{horizon}(\theta)$を計算する方法が必要になる。[@eq:2.5]では$\rho$によって重み付けされた接線から法線までのすべての方向でレイをトレースする必要があるが、$h(\theta)$以下のすべてのレイは遮蔽されることがすでに分かっており、逆に、$h(\theta)$以上のすべてのレイは可視であるため、いずれの場合もトレースする必要はない。代わりに、接線の角度$t(\theta)$と$h(\theta)$の間の積分としてAOの寄与を求めることができる。$t(\theta)$は$n$と$\theta$から容易に導くことができる。著者らは以下としている。

$$
AO_{horizon} = \int_{\alpha=t(\theta)}^{h(\theta)} \rho(d) \cdot \cos(\alpha) d\alpha
$$ {#eq:3.3}

ここで、$\cos(\alpha)$は[@eq::2.5]からの内積である。$\rho(d)$は少々込み入っており、後に説明したい。著者らは[@eq:3.3]を以下へとさらに計算する。

$$
AO_{horizon} = \rho(d) \left( \sin(h(\theta)) - \sin(t(\theta)) \right)
$$

すると、[@eq:3.3]を[@eq:3.2]に挿入できる。計算目的のために、この積分を解くのにモンテカルロ積分を用いることも有用である。

$$
AO = 1 - \frac{1}{N} \sum_{n=1}^{N} \rho(d_n) (\sin(h(\theta_n)) - \sin(t(\theta_n)))
$$ {#eq:3.4}

ここで、$N$はサンプル数である。

#### スクリーンスペースの計算

[@eq:3.4]を実装する鍵は、同じ著者らによって提案されるように、$h(\theta)$を求めるためにスクリーンスペースで深度バッファをレイマーチすることである。レイはスクリーン座標で$p$から方向$\theta$に生成され、深度バッファを横断し、別個の間隔でサンプルする。各サンプルは$s_z = \text{depth}(s_{xy})$でシーンの表面に投影される。サンプルのAO寄与は遮蔽された角度$\text{acos}(t^{* }, \text{normalize}(s-p))$から計算され、$\rho(|s-p|)$で重み付けされる。$t^{* }$は初期の接線ベクトルであるが、後続のサンプルの各$s-p$ベクトルへ[reassign]される。これは各サンプルが貢献することを可能にし、過剰遮蔽を回避する。現時点で定義される$t^{* }$以下であるサンプルは$p$から見えないので却下される。

さらに、著者らは規則正しい[systematic]ノイズを回避するためにレイマーチングのステップサイズをジッタリングして無作為に方向を選択することを提案する。これは[@Mittring2007a]で遭遇したアーティファクトと似たものである。

#### バリエーション

アイ空間でレイをトレースし、バッファをサンプリングするために毎ステップにスクリーン座標に投影する方法もある[@Dimitrov2008; @Sainz2008]。これはHorizon-Split AO(HSAO)として知られ、対して、[@Bavoil2008a]で述べられる手法はHorizon-Based AO(HBAO)として知られている。追加された投影はパフォーマンスの観点でHBAOを優れたものにする追加の計算を暗示する。HSAOとHBAOの両方を支持する論文は同じ著者らによるものであるが、後者の論文は前者の半年後のものであるので、我々はHBAOはHSAOの改良版であると結論付けても差し支えはないと考えている。

### Directional Occlusion {#sec:3.2.5}

Screen-Space Directional Occlusion (SSDO) [@Ritschel2009; @Dachsbacher2009]は$AO$だけでなく、$p$に属する表面の入射する放射輝度も計算する。これはその結果に色付きで有向のシャドウを可能にする。さらに、SSDOは光のディフューズ間接バウンスをひとつ近似する任意の第2パスを持つ。これは最初のパスで集められた直接放射輝度の値近くをサンプリングすることで行われる。従って、レイトレースの大域照明ソリューションで知られているcolor bleeding効果が起こり得る。

著者らは、深度バッファが最前面のオブジェクトに関する情報のみを含んでいることに起因するシーン情報の欠落の問題に対処するため、*depth peeling*を用いることを提案する。

### マルチレイヤとマルチ解像度 {#sec:3.2.6}

[@BavoilSainz209]は一般的なSSAOアルゴリズムへの2つの改善を提示する。

1つ目の改善は品質ついてである。著者らは[@Ritschel2009]ですでに提示されたようなdepth peelingを用いることを提案し、加えて、シーン際近くでのアーティファクトを修正するために$AO$を計算するときに拡大した視野(ガードバンド)を用いることも提案する。

2つ目の改善は品質を犠牲にしないパフォーマンスに焦点を当てる。そのキモはAO計算をハーフ解像度とフル解像度の2つのパスに分けることである。

#### バリエーション

マルチ解像度を用いると、ブラーステップを省略できる[@HoangLow2010]。$AO$はまず対称的な低解像度の入力(深度と法線バッファ)を用いてますます低解像度で計算され、異なる$AO$値が最終的なフル解像度のレンダリングに組み合わせられる。そのアイデアは[@BavoilSainz2009]で開発されたデュアル解像度手法と似ているように見えるが、いくつかの重要な差異が存在する。まず、著者らは$AO$の計算に用いる深度と法線をダウンサンプリングすることを提案する。これはすでに粗いシーンの近似を粗くする。次に、彼らは$AO$値を組み合わせるのに知的な組み合わせのスキームを提案せず、ただ単にエッジ対応バイラテラルフィルタを用いて一緒にブレンドすることを提案する。その粗い近似にも関わらず、著者らは良好な結果をもたらすとしている。マルチ解像度の入出力バッファはミップマップによりモダンなハードウェアで容易に表現される。

同著者らはいくつかの改善で2年後に初期の実装を再検討する[@HoangLow2012]。今回は、各パスが数学的な動機付けと共に詳細に説明されている。また、著者らは両方の入力バッファを賢くダウンサンプリングし、$AO$値を組み合わせる手法を提示する。このように、提案される手法は審美眼的に動機付けされるのみならず、その背後に理に適った数学的な理由付けがなされている。

### A Temporal Approach {#sec:3.2.7}

$AO$計算の品質を改善する方法のひとつは前フレームからの情報を再利用することである[@SmedbergWeight2009]。*テンポラルフィルタ[temporal filter]*は移動するシーンの結果を改善することを示す。動機付けを行う観察結果はビュー(カメラ)が、通常のケースではシーンのアニメーションを行うので、フレームからフレームへ徐々に変化することである。そのアイデアは*時間をかけて[over time]* 2つの項をブレンドすることでフレーム$n$の$AO$でフレーム$n-1$の$AO$をフィルタリングすることにあり、実質的に移動中のノイズアーティファクトを取り除く。これが機能するためには、フレーム$n$のビューおよびアニメーションステートがフレーム$n$で利用できなければならず、メモリオーバーヘッドを被る。スクリーン座標における$p$は2つのフレームの間で異なる可能性が高いので、ワールド座標における$p$からフレーム$n-1$とフレーム$n$の両方で計算されなければならない。ビューとアニメーション種テートを保存するとこれが可能になる。著者らはこれを*再投影[reprojection]*と呼んでいる。

動きがないとき、この追加のテンポラルフィルタは品質的な利点をもたらさず、パフォーマンスコストをもたらすのみである。これはフィルタが*時間をかけて*フレーム間をブレンドするためである。静的なシーンでは、フレーム間で$AO$が変化せず、フィルタが効力を持たず、動的なシーンでさえ、新旧$AO$値の間の収束レート[rate of convergence]に基づいて発生し得る。

著者らは、サンプリング半径が大きすぎると、無作為なサンプル探索[look-up]がテクスチャキャッシュをめちゃくちゃにするとも説明する。小さな値に半径をクランプすることはキャッシュ内のテクスチャサンプルの空間的局所性を改善する。

#### バリエーション

他の見方はフレーム間で$AO$計算を単純にブレンドしたりはせずに時間をかけて$AO$を精錬するためにサンプルを実際に再利用することであり[@Mattausch2010; @Scherzer2010]、すなわち、より良い結果に収束するために古いフレームのサンプルを集める[aggregate]ことである。これは大量のサンプルがピクセルあたりに追加で格納されなければならないことを示しているが、静的なシーンでも品質が改善するだろう。この手法は[@SmedbergWeight2009]と無関係に開発された。

著者らはディファードパイプラインに再投影を統合する方法やdisocclusionを扱う方法に踏み込んでいる。後者は前景[foreground]の動きによって後景[background]のオブジェクトが可視になる(disoccluded)ときのことである。一般的なアイデアはフレーム$n-1$と$n$の間のワールド座標における$p$の相対的な深度差が与えられたしきい値以上であるかを確かめることにある。それが正しければ、$p$が後景のオブジェクトの表面を表現している可能性が大いに高く、$AO$は再び計算されなければならない。

### The First Hybrid {#sec:3.2.8}

[@Bavoil2008a]と[@ShanmugamArikan2007]に見られる手法の組み合わせは最初に提案されたハイブリッド手法を形成する[@Song2010]。

### ボリューメトリックなアプローチ {#sec:3.2.9}

Volumetric Obscurance (VO)は$p$の周りの3D近傍(例えば、球)の遮蔽されたボリュームと遮蔽されないボリュームの比である[@LoosSloan2010]。彼らはVOを以下のように定式化する。

$$
VO(p) = \int_{X} \rho(|x-p|) O(x) dx
$$ {#eq:3.5}

ここで、$X$は$p$の周りの3Dボリュームであり、$x$は$X$内の点であり、$\rho$は以前に述べた通りであり、$O(x)$は$x$にモノがあれば1、そうでなければ0のいずれかである*占有率関数[occupancy function]*である。彼らは[@eq:2.5]の代わりに[@eq:3.5]を用いて、AOを計算する目的のために以下とすることを提案する。

$$
AO = VO
$$

著者らが示す通り、上記の式は任意の方向における$p$からのレイが単一の表面に交差するのみであろうという仮定の下で有効である。

ある場面では、[@Mittring2007a]や[@FilionMcNaughton2008]の手法はポイントサンプルを用いて[@eq:3.5]の積分を解くこととして考えることができる。各ポイントサンプルは調査用ボリューム$X$の一部を表し、すなわち、それは球か半球である。サンプル数$N$が$\infty$に近づくと、サンプルは$X$のすべてを覆い、等しい数式を得る。これはもちろん$V' = O$である仮定の下である。

著者らは積分を解くのにラインおよびエリアサンプリングを用いるためにポイントサンプルの使用を一般化する。ラインサンプリングにおいて、積分は遮蔽されるラインの長さと可視分の比として近似される。サンプル位置$s_n$それ自体はスクリーン座標での$p$の周囲のディスク内で探す。ラインの長さの可視部分の計算は自明であり、可視から遮蔽への交差点は単純な深度バッファ探索$s_d = depth(s_{xy})$で示され、$s_{xy}$での球の高さは単純な三角法$\sqrt{r^2-(s_x^2+s_y^2)}$で見つけられる。ここで、$r$は球の半径である。ポイントサンプルに対するラインサンプリングの提案された利点は、ポイントサンプルは遮蔽されるか否か($V'$でテストされる)であり、ちょっとした移動でポップインやポップアウトが発生し得るが、ラインサンプルは移動中に滑らかにフェードすることが可能となる*サンプルあたり*の遮蔽と可視の比を持つ、という点である。

もうひとつの新しいアイデアは小さな球および大きな球の$AO$または$VO$計算を組み合わせることにある。この技術は狭い範囲[low-scale]のディテールと広い範囲[broad-scale]のディテールの両方を同様にキャプチャする。

#### バリエーション

無作為化や回転の両方を用いて$p$周りのディスク内の標本点を選ぶための多くの方法が存在する[@Ownby2010]。著者らはいくつかのバリアントの提案と差異の解析を行う。提案のひとつはすべての範囲をより良く得るためにoutward spiral pattern^[訳注:外に広がる渦巻きパターン]を用いることであるが、以前に言及した通り、ほとんどの固定形成[fixed-formation]サンプリングパターンは結果としてスパイラル分布が含まれるバンディングとなる。最終的に、彼らは視線ベクトル周りでスパイラルにおける各サンプルを無作為に回転する。

著者らは深度バッファによって与えられる粗いシーン近似に起因する欠落しているサンプル情報をより良く推定するために($p$の周りで対称的な)対になるサンプル位置を用いることを提案する。

大規模のプロダクションで実際に使われるもうひとつの提案は時間的な精錬[@Mattausch2010]と共にラインサンプリング[@LoosSloan2010]を用いることである。これは、後者を前者の拡張として動作させることができると証明されている[@Kaplanyan2010]ためである。

### ポアソンサンプリングのアプローチ {#sec:3.2.10}

任意の2サンプル間の距離が与えられるしきい値以上であるところの表面上に分布するサンプルはポアソン分布されるといわれる。形式的には、この分布の特性は以下のようにサンプル位置$s$としきい値$d$によって述べられる。

$$
\forall_{s_i} \forall_{s_j} (|s_j - s_i| > d | i \ne j)
$$

ディスク上でポアソン分布されるサンプルを用いるアイデアは既存の手法のハイブリッドの一部として導入された[@Sourimant2011]。著者らは[@Bavoil2008a]で提案されるような高さフィールドとして深度バッファをレイマーチングすることを提案する。その差異は、彼らはfree horizonの角度を計測していないが、代わりにレイマーチングによってより良いサンプルオクルーダー距離を見つけることを目的としていることである。サンプルそれ自体はディスク表面上でポアソン分布から選ばれ、$p$と$n$によって定義される半球に投影される。$AO$計算それ自体は[@Mittring2007]や[@FilionMcNaughton2008]と同種のものである。

上記の手順の多くを共有するが細かいところで異なるもうひとつのアルゴリズムが存在する[@AksoyPhaneuf2011]。ディスク上にポアソン分布されたサンプル位置をスクリーン座標における深度バッファ(シーン表面)に投影することに始まり、サンプル位置が$p$と法線$n$で定義される平面の背後にある場合、それは遮蔽され、そうでない場合、関数$\rho(|s-p|)$が遠くのサンプルの寄与が少なくなるようにAO寄与を重み付けする。

著者らはinteractive ratesでフラグメントあたり32サンプルを持つ結果をブラーする必要はないと述べている。しかし、重要な特徴だけがその手法を用いて陰影付けされたということを覚えておくべきである。フレームの大部分(例えば、背景のジオメトリ)はこの種のAO計算を受けなかった。

[@LoosSloan2010]と同様に、著者らはfine-scaleおよびbroad-scaleの両方の詳細をキャプチャするために異なる半径で2つの半球を用いることを提案する。

### 曲率ベースのアプローチ {#sec:3.2.11}

[@Hattori2010; @Hattori2011]は$p$の周りの近傍におけるジオメトリの曲率からAOを近似する。

### Bent Normals {#sec:3.2.12}

*bent normals*の概念はアンビエントオクルージョンの用語の始まり[@Landis2002]から使われてきたが、スクリーンスペースのアプローチとの組み合わせに最初に現れるまでおそらく数年かかった[@Kasyan2011; @DonzallazSousa2011]。標準の$AO$計算は、遮蔽されない方向の平均を示すbent normalを加えること以外、通常通りに行われる。このbent normalは単なる$AO$としてピクセルごとに格納され、続くシェーディング計算で用いられる。[@Ritschel2009]にある通り、これは、著者らが*contact shadows*と呼ぶ、小縮尺における有向のシャドウを可能にする。

bent normalsへの拡張には、円錐の大きさを示すassociated *angle*を持つbent normalである*bent cones*がある[@Klehm2011]。この角度はサンプル方向の間の分散に基づく。*bent cones*が利用できると、点が(円錐で定義される)spherical capを通して受け取る光量を計算できるより複雑な照明手法を可能にする。著者らはbent normalsの間に見つかるノイズを減らすためにインターリーブされたサンプリングを用いることを提案する。

### Alchemy Ambient Occlusion {#sec:3.2.13}

このアイデアは、[@eq:2.5]でいくつかの項を打ち消すことで、減衰関数$\rho$を賢く選択することにある[@McGuire2011]。彼らが選択する$\rho$は以下である。

$$
\rho(d) = \frac{u \cdot d}{\text{max}(u, d)^2}
$$

ここで、$d$はサンプル距離であり、$u$は厳密な形状を選択するためのユーザ定義パラメータである。$\rho$の選択が$AO$の逆の定義を用いていることを示すことはすでに明らかであるはずである。我々は議論しやすくするために逆$AO$を関数を述べ直したい。

$$
AO = 1 - \frac{1}{\pi} \int_{\Omega} \rho(d) (n \cdot \omega) d\omega
$$ {#eq:3.6}

[@eq:3.6]に$\rho$を挿入しても、$u$が積分の外に移動できるという事実にも関わらず、まだおもしろい結果にはならない。

$$
AO = 1 - \frac{u}{\pi} \int_{\Omega} \frac{d \cdot (n \cdot \omega)}{\text{max}(u, d)^2} d\omega
$$ {#eq:3.7}

著者らはベクトル$v = \omega \cdot d$を定義し、[@eq:3.7]を以下に単純化することを提案する。

$$
AO = 1 - \frac{u}{\pi} \int_{\Omega} \frac{v \cdot n}{\text{max}(u, d)^2} d\omega
$$ {#eq:3.8}

さらに、$u>0$および$d>0$の両方の仮定の下で$\text{max}(u, d)^2 = \text{max}(u^2, d^2)$とすることは安全である。著者らは$v \cdot v = |v|^2 = d^2$であるとも述べ、[@eq:3.8]を以下に単純化する。

$$
AO = 1 - \frac{u}{\pi} \int_{\Omega} \frac{v \cdot n}{\text{max}(u^2, v \cdot v)} d\omega
$$ {#eq:3.9}

最後に、計算用の式を得るためにモンテカルロ積分を用いる。著者らはいくつかの追加の単純化と共にそれを行い、最終的に以下となる。

$$
AO = 1 - \frac{1}{N} \sum_{n=1}^{N} \frac{\text{max}(v_n \cdot n + \beta, 0)}{v_n \cdot v_n + \epsilon}
$$ {#eq:3.10}

ここで、$N$はサンプル数であり、$v_n$は与えられたサンプルベクトル$(s_n - p)$であり、$\beta$はオクルージョンの大きs差を制御するパラメータであり、$\epsilon$は0除算を回避するための小さな数である。分母にあるmax関数は、$u^2$の関数が実際には0除算を回避するためであったので、置き換えられた。加えて、分子における内積は、ベクトル$v_n$が意図せず半球以下になるかもしれないので、0にクランプされた。これは下記されるサンプル生成のアーティファクトである。

著者らはオクルーダーへのサンプリングを制限することを目的とするのみである、サンプル生成への面白いアプローチを提案する。これはサンプルが可視か遮蔽されるかのいずれかとなり得るボリューメトリック手法の一般的な戦略と対照的である。著者らの提案はhorizon angle $h$以下のすべてが遮蔽していると見なされる[@Bavoil2008a]により近いのものである。

著者らは[@LoosSloan2010]で行われるようにスクリーン座標における$p$の周囲のディスク中でサンプル$s_n$を選択する。彼らは[@Bavoil2008a]で行われるようにサンプルをシーン表面に投影する。すると、$s_n-p$としてサンプルベクトル$v_n$を構築できる。半球以下のサンプルは[@eq:3.10]のぶんしにあるmax関数によって自動的に排除されることに注意する。

彼らは背景のオブジェクトがより少ないサンプルを用いるように距離によってサンプル数を変化させるという面白いアイデアも提示する。これは全体で使われるサンプルが少なくなるのでパフォーマンスが改善する。

### 分割可能なアプローチ {#sec:3.2.14}

その核となるアイデアは垂直と水平にAO計算を分けることにある[@Huang2011]。これは一般的なSSAOアルゴリズムへの近似の追加のレイヤーを提示する。ブラーカーネルがまず水平に計算され、続いて垂直に計算される分割可能なブラーフィルタと強い類似性がある。その有益性は全体的にサンプルを少なくすることによるパフォーマンスの改善である。

上記で提示される基本形式では、その手法は対角に並行な遮蔽を扱わない。この問題を迂回するため、著者らはピクセルごとにサンプルフレームを無作為に回転することを提案する。すなわち、"水平"および"垂直"の2つの方向は直交したままイメージフレームに対して共に回転される。これは前述の"交差"アーティファクトを実質的に隠す。

ブラーフェーズは無作為に回転したサンプルフレームによってもたらされるジッタリングを隠す必要があることに注意すべきである。

### もうひとつのHorizon-Based Approach {#sec:3.2.15}

(例えば、レイマーチングで[@Bavoil2008a])正確なhorizon angle $h$を近似しようとする代わりに、他すすのサンプル角度をサンプルして平均する[@Mittring2012]。すでに示した通り、前述の角度ベースのアルゴリズムにかなり匹敵している。この手法は初期のアルゴリズムの後のバリアントこのとして見なすことができる。

対となるサンプル位置の集合$\langle s_1, s_2 \rangle_n$はスクリーン座標における$p$の周囲に見られる。ここで言う対となるとはサンプル位置の各対が$p$の周囲に対称的に位置していることを意味する。各対は対におけるサンプル$s_1$と$s_2$の両方に対して$s_z = depth(s_{xy})$によってシーンに投影される。free horizonの角度はその対に対して$s_1-p$と$s_2-p$の間の角度として推定できる。free horizonの角度は対から見つかる平均角度として近似される。その法線は各$s-p$ベクトルを接平面にクランプするために使うことができる。

### スケーラブルなアプローチ {#sec:3.2.16}

著者らは大きなサンプリング半径と高解像度でスケールするように以前の手法[@McGuire2011]を調整する[@McGuire2012; @Bukowski2012]。

１つ目の改善は深度バッファに依存するのみにすることでメモリ帯域を切り詰めることである。深度バッファから、位置と法線を導出できる。後者は空間微分[spatial derivatives]を介する。もうひとつの重要な変更は[@HoangLow2010]で行われた研究と同じようなミップマップ化された深度バッファを用いることである。これは深度バッファからのテクスチャフェッチのパフォーマンスを改善し、アルゴリズムが大きなサンプル半径でスケールすることを可能にする。フェッチされるミップマップレベルは遠くのサンプルが粗い深度バッファレベルからフェッチするために$s$が$p$からどれだけ離れているかに依存する。すなわち、細かなディテールが高解像度の深度バッファをサンプルする$p$の周りで保存されつつも、長距離の遮蔽が粗い深度バッファレベルを通じて計算に含まれる。

[@HoangLow2010]と[@HoangLow2012]の両方において、出力$AO$は入力バッファの解像度に対応する複数の解像度でも計算されることに注意すべきである。そして、$AO$は続いて後のパスで組み合わせられる。[@McGuire2012]では、$AO$はミップマップ化された深度バッファを用いていても一番高い解像度で常に計算される。

著者らは現代のハードウェア上でのパフォーマンスを改善するための多くの技術的詳細も提供する。

## 概要 {#sec:3.3}

# 設計 {#sec:4}

## 一般的な所見 {#esc:4.1}

### 深度バッファの不連続性 {#sec:4.1.1}

前節では、我々はこれまでに深度バッファがうまくシーンを近似すると仮定してきた。深度バッファは最前面の表面しか格納せず、他のすべての表面の情報は喪失する。これは誤った$AO$計算をもたらすかもしれない。結果のアーティファクトは深度の不連続性の周りの暗い後光である。

#### フォールオフ関数

最も簡単な改善策は$AO$計算にフォールオフ関数$\rho(d)$を導入することである。前景と背景のオブジェクトは相当の距離で分かれている傾向にあり、ほとんどの部分で確実に$d_{max}$以上である。結局の所、$\rho$は審美眼的な動機を以て導入された[@Zhukov1998]。しかし、サンプルが深度バッファのビューから隠れた表面によって遮蔽される場合、そのサンプルを可視として誤って扱ってしまう。

#### リジェクション

より単純だが関連のある代替案では$p_d$から離れすぎている深度値$s_d$を持つサンプルを排除する。すなわち、我々は距離$|s-p|$ではなく差$p_d - s_d$を計測する。これはその距離ではなく何らかの方法でその差を計算する手法で計算コストが安価になる可能性がある。このサンプルように単純に破棄するとアンダーサンプリングを引き起こすかもしれない[@Ownby2010]。例えば、ほとんどのサンプルがしきい値を越えている場合、実際の$AO$計算のためにはほとんど残っておらず、おそらくそれでは少なすぎるだろう。

#### 深度レイヤと複数ビュー

層状の深度バッファ(または、depth peeling)を用いるアイデアもある[@Ritschel2009; @BavoilSainz2009]。代替案として、複数のビュー角度が異なる視点[perspectives]から深度バッファを生成するのに使うことができる[@Ritschel2009]。深度レイヤと複数ビュー角度の両方のアイデアはメモリ予算を使い込み、パフォーマンスを傷つけるかもしれない。加えて、各手法は追加のシーン情報を容易にするために必要な計算を組み込まなければならない。


#### Paired Sampling

最後に、これは欠落する深度情報を復旧しようと変化を増やすためのサンプルの対を用いるアイデアである[@Ownby2010]。このアプローチは表面が平均して平坦であるという仮定を用いる。多くのシーンでは、これは理にかなわない仮定ではない。対における1つのサンプルが拒否される場合(例えば、差$p_d-s_d$によって)、そのパートナーは隠れた情報を再構築するのに使われるかもしれない。このアプローチは必然的に既定で対となるサンプルを用いる手法と適合する。さらに、多くのSSAO手法はpaired samplingを用いるように拡張できる。

#### 比較

上記の深度バッファの不連続性に対する改善策のすべては手法の多くの間に理論上適用できる。しかし、各手法は統治モデル[governing models]や計算するデータのいずれかによる特定の改善策により自然と適合する。各手法がどれだけ深度バッファの不連続性を扱うかは比較対象として興味深い変数である。選ばれたアプローチは結果の画像だけでなく計算時間にも大いに影響を与える。

フォールオフ関数$\rho$の定義は曖昧であり、それを使う手法で変化し得ることに注意する。我々は各手法の背後にある論文によって推奨される定義に同調することを選択した。

### ガードバンド {#sec:4.1.2}

以前に述べたように、幾人かの著者らはスクリーンエッジ近くのアーティファクトへのガードバンドの使用を推奨する[@BavoilSainz2009]。しかし、これは、より多くのピクセルをレンダリングする必要があるため、パフォーマンスコストとして降りかかる。ガードバンドの使用が学術的な論文で述べられているのみであり、(我々が確認できる限り)プロダクションのユースケースでは一切言及されていないことは、さらに興味深いことである。我々は、大抵焦点がスクリーンの中心に当たっているため、エッジのアーティファクトは目立たない、というのがこの理由であると考えている。結論として、我々はガードバンドを使わないことを選択した。

### メモリ予算の影響力[impact] {#sec:4.1.3}

この研究を開始した当初、我々は各手法は異なるメモリ要件を持つだろうと仮定していた。しかし、すべての手法が深度バッファのみを入力として実装できることが判明している。それは、位置が深度から再構築でき[@Mittring2007; @Kasyan2011]、法線が位置から再構築できる[@McGuire2012; @Bukowski2012]ことが理由である。結論として、手法間にメモリ要件の違いは存在しない可能性がある。再構築は若干のパフォーマンスヒットを伴うが、モダンなハードウェア上ではそれほど問題にならないことに注意すべきである。さらに、再構築される法線の品質は議論の余地があり[@Bukowski2012]、幾人かの著者らは本物の法線の方を好む。

### ブラー {#sec:4.1.4}

AOパイプラインにおける重要な点は無作為なサンプリングによってもたらされる高周波ノイズを取り除くためにブラーを用いることである。前述のすべてのSSAO手法は(解析で明示的に述べられていない限り)ブラーパスを推奨する。これはすべての手法に絶対必要であると言っているわけではなく、ある手法は十分に大きなサンプル数$N$を用いれば高品質な結果を生成できる。このとき問題となるのが$N$を増やすことで発生する急速なパフォーマンス低下である。しかし、各手法は様々にスケールするので、比較対象として興味深い点となる。我々は、選択した各手法が高品質な出力を維持しつつブラーパス全体を省略することへの影響度を発見したいと思う。我々はいくつかがパフォーマンスの観点で他のものより悩まされるであろうと期待している。

#### ブラー自体

すべての推奨事項で共通することは、ブラーがgeometry-awareでなければならない、すなわち、無関係な表面にまたがってブラーしてはならない、ということである。幾人かの著者らは深度バッファを用いることを提案し[@Mittring2007a]、その他は表面法線を追加で使用することを提案する[@FilionMcNaughton2008]。しかし、すべての手法の目標は、表面の定義を維持しつつ高周波ノイズを取り除くこと、で一致しているように思える。これを踏まえ、我々は*すべて*の手法に対して*同じ*ブラーパスを用いることを選択した。これは比較の次元を削減するが、SSAOの詳細における議論により大きく注力する。そうと言っても、いくつかの手法は他のものより広範囲のぶらーを必要とする。これは比較要素として残しておきたい。

我々は表面の定義を維持するために深度と法線の両方の情報を用いる分割可能なブラーフィルタを用いる。これはすべての手法が高品質なブラーをretrieveすることを保証すべきである。

### ノイズとサンプルパターン {#sec:4.1.5}

サンプルパターンが結果に反映されるであろうことはすべての手法に固有の性質である。無作為なパターンが用いられるとき、高周波ノイズが加わる[@Mittring2007a]。一般的に言えば、著者らはバンディングアーティファクトより高周波ノイズを好む。各手法は推奨されるサンプルパターンも持つ。これは時に手法が機能する方法と強く結びついている。故に、手法間のサンプルパターンを切り替えるのは実現不可能である。

### 自己遮蔽 {#sec:4.1.6}

いくつかの手法は問題になっている位置の周辺で球内に分布するサンプルを用いる([@Mittring2007a]や[@LoosSloan2010])。その問題は、平坦な表面上でさえ、サンプルの半分が表面の下にあることを期待されることである。これは自己遮蔽[self-occlusion]として知られている。

### 解像度の変化 {#sec:4.1.7}

多くの著者はパフォーマンス上の理由のためにより低解像度で$AO$を計算し、スクリーンに合うように再スケールすることを提案する[@BavoilSainz2008; @Bavoil2008b; @SmedbergWeight2009; @BavoilSainz2009]。他の著者らは複数の解像度で$AO$を計算するための専用で複雑な努力をしている[@BavoilSainz2009; @HoangLow2010; @HoangLow2012; @McGuire2012]。いくつかは再スケーリングを上手くこなし、精度不足のときに$AO$をリサンプルする[@BavoilSainz2009]が、その他はパフォーマンスを優遇し、リサンプリングを省略する[@SmedbergWeight2009]。

我々はこの因子を比較対象外とするためにある特定の解像度(800x800ピクセル)で$AO$を常に計算することを選択した。すべてのアプローチを平等の立場に置くため、品質における差異はリスケーリングに起因する可能性はない。

### スケール {#sec:4.1.8}

比較のための主要な変数はAO効果が適用されるところでのスケールである。すべての手法は影響度の半径、または、サンプル球かサンプルディスクの半径を制御するいずれかと同様のものを持つ。[@eq:2.5]では、パラメータ$d_{max}$によってフォールオフ関数$\rho$で暗黙的に定義される。レイトレースのリファレンスは期待されるものとしてスケールする。比較の中で候補の手法がどれだけスケールするかを見ることが興味深いだろう。

#### サンプル数

$AO$積分を解決するのに使われるサンプル数$N$は比較対象として良い候補となる変数でもある。各手法は$N$で個別にスケールするが、それらすべてに対する一般則は大きな$N$で遅くなることである。我々はいくつかの良い妥協案を見つけようとするだろう。

### 計算パフォーマンス {#sec:4.1.9}

パフォーマンスは(できれば)ミリ秒での実行時間としてプロファイルされる。そのようなプロファイリングはソフトウェア自体で容易に処理される。しかし、全体としてのアプリケーションはプロファイルされないことが重要である。AOを計算するシェーダパスと関連するブラーのみが関係している。

我々はプロファイリングにNVIDIA GeForce 260 GTX GPUを用いる。

#### 業界[industry]の平均レンダリング予算

AO計算がどれだけの長さをかけるべきかていう標準の基準系[reference frame]が存在しない。しかし、我々は業界で使われるレンダリング予算から平均を計算できる。

- $AO$計算: 1.2ms [@Kaplanyan2010]
- $AO$計算とGI: 2ms [@DonzallazSousa2011]
- $AO$計算とブラー: 2〜4ms [@McGuire2011]
    - 複数プラットフォームを対象とするときは3〜5msの間

残念ながら、我々が見つけた(上記の)2つのレンダリング予算は純粋に$AO$計算に対するものではない。また、著者らはいくつかのケースで使っているGPUを明記するのみであった。しかし、我々は上記の情報に基づき2msを選択するのが公平であると考える。パフォーマンス比較はいずれにせよ手法間で行われるはずである。業界のレンダリング予算は参考として含まれるのみである。

### 品質 {#sec:4.1.10}

品質は手動の見た目の比較によって評価される。我々は金字塔として用いられるレイトレースのリファレンスを生成した。我々はできるだけリファレンスに似るように各手法を調整することを目的とする。

### リファレンスシーン {#sec:4.1.11}

Crytekによって開発されたSponzaモデルを用いている。リファレンスはMental Rayレンダラによってレンダリングされる。我々は線形のフォールオフ関数$\rho$を持つ完全な半球でピクセルあたり64つのレイを用いた。

我々は比較のために2つの異なるカメラ位置を用いる。この比較パラメータは[@McGuire2011]で提案された。

### パラメータ {#sec:4.1.12}

各手法はユーザの好みに調整できる一連のパラメータを持つ。時折、統治している$AO$モデルは実装者にある自由度をもたらすすべての詳細を網羅しないことがある。しかし、すべての手法の間で共有される、結果を調節する一連のパラメータが潜在する。それらは以下としてポストプロセッシングステップを介して適用される。

$$
AO'(AO) = (b \cdot (AO + a))^c
$$

ここで、$a$、$b$、$c$はユーザ定義される。$b$と$c$は$AO$計算の明るさとコントラストを制御するのに使うことができる。$a$は期待される$0.5$の遮蔽量をその結果に単純に加算することで自己遮蔽を改善してクランプするのに使うことができる。

## 候補手法 {#sec:4.2}

比較対象として選ばれた手法は[@fig:4.3]に示される。これらはアルゴリズム的にも時系列的にも異なるSSAO手法が提示されることが意図されている。前者は異なる統治$AO$近似を網羅できる。後者は初期の手法が後の手法や一般の傾向にどれだけ影響を与えたかを見せてくれる。

![選択されたSSAO手法。(a)スクリーン座標で球状にポイントサンプルするAO[@Mittring2007a]、(b)ワールド座標で半球状にポイントサンプルするAO[@FilionMcNaughton2008]、(c)レイマーチングによるhorizon-based AO[@Bavoil2008a]、(d)ラインサンプルを用いるボリューメトリックAO[@LoosSloan2010]、(e)投影されたサンプルと球状の$\rho$関数を用いるAlchemy AO[@McGuire2011]、(f)対となるサンプルを用いるhorizon-based AO[@Mittring2012]](){#fig:4.3}

さらに、我々は手法が$AO$近似の組み合わせや積分の解き方に基づいて分類できることを発見した。これは各手法のアルゴリズムの基盤を素早く評価することを可能にする。故に、(我々が以下で明らかにするであろう)様々なカテゴリーに起因する手法は等しく表現されるはずである。

### 手法の分類方法 {#sec:4.2.1}

TODO
