---
title: >
CHC++: Coherent Hierarchical Culling Revisited [@Mattausch2008]
#bibliography: bibliography.bib
---
# はじめに {#sec:1}

オクルージョンクエリは複合的なシーンをレンダリングするのにかかる時間を減らすために重要な技術である。いわゆるハードウェアオクルージョンクエリの可用性は可視性の実行時測定[runtime determination]を魅力的にしてきた。ハードウェアオクルージョンクエリはグラフィクスハードウェアが単純なプロキシオブジェクトの可視性状態を素早く報告できるメカニズムである。しかしながら、ハードウェアオクルージョンクエリが使用できるようになるのは、例えばCoherent Hierarchical Culling(CHC)アルゴリズム[@BWPP04]にあるような、時間的一貫性[temporal coherence]を活用することによってのみである。なぜなら、これはCPUをストールしたりGPUを飢餓状態[starvation]にしたりすること回避するためである。

CHCアルゴリズムは密に遮蔽された[densely occluded]シーンで上手く機能するが、ハードウェアオクルージョンクエリのオーバーヘッドはいくつかの状況において単純な視錐台カリング(VFC)にさえ後れを取る[fall behind]ようにしてしまう。これは、オクルージョンの賢い統計モデルとハードウェア較正[calibration]ステップに基づいてクエリ数を減少させるNear Optimal Hierarchical Culling(NOHC)と呼ばれるアルゴリズムを提供する、Guthe et al.[@GBK06]によって認知された。しかしながら、Guthe et al.によって定義された最適条件でさえ更なる単純化の源を活用することによって依然として改善できる。

![視錐台カリング(VFC)、Coherent Hierarchical Culling (CHC)、Near Optimal Hierarchical Culling (NOHC)、我々の新しいアルゴリズム(CHC++)に対する発電所モデルのウォークスルーのフレーム時間の比較。](){#fig:1}

本論において、我々は以前のオンラインのオクルージョンカリング手法に大幅な改良を加える手法であるCHC++を提案する([@fig:1]を参照)。そのアルゴリズムの核は単純なままであり、較正をまったく必要とせず、ゲームエンジンへと簡単に統合することができる。その手法の主要な貢献は以下である。

- **状態変化[state changes]の削減**。その重要性に関わらず、状態変化の削減は以前のオクルージョンカリング手法によって明示的に扱われなかった。我々の手法はクエリのバッチ処理を用いることによって状態変化の数を最小化するための強力なメカニズムを提供する。結果として、状態変化の総数は1桁以上[more than an order of magnitude]削減される。
- **クエリ数の削減**。クエリ数の削減はハードウェアベースのオクルージョンカリングにおける以前の研究の主要な目標であった。例えば、Guthe et al.[@GBK06]によって提案されるNOHCアルゴリズムは低い遮蔽率を持つビューに対するクエリ数の削減では非常に成功している。我々はクエリ数の更なる削減のための2つの新しい手法を提案する。1つ目の手法は単一のクエリによって階層において多くのノードの可視性を解決し、2つ目の手法はOriented Bounding Boxやk-DOPのような補助データ構造を必要としないクエリに対するよりタイトな境界ボリュームを活用する。結果として、我々はGuthe et al.[@GBK06]によって定義される"最適"なアルゴリズムより大幅に少ないクエリ数を達成する([@fig:2]を参照)。
- **CPUストールの削減**。CHCアルゴリズムはCPUストールの削減では良い仕事を行っているが、あるシナリオにおいて、ストールは依然として発生し、パフォーマンス上のペナルティを引き起こす。我々は待ち時間のさらなる削減をもたらし、それと同時に状態変化の削減に対する我々の手法と上手く統合する単純な修正を提案する。
- **レンダリングされるジオメトリの削減**。よりタイトな境界ボリュームは境界ボリュームによって引き起こされる可視性の過剰推定を削減し、それ故に、可視として分類されるジオメトリ量を削減するだろう。
- **ゲームエンジンとの統合**。ほとんどのゲームエンジンはマテリアルによってソートされている高度に最適化されたレンダリングループを組み入れ[incorporate]、シェーダはレンダリングステートの変更を最小化する順番で処理される。我々の手法はレンダリングエンジンがレンダキューに格納されるプリミティブのバッチ上でそのようなソートを処理できるようにする。加えて、提案される技術はエンジン呼び出し数を大幅に削減する。

![左上:街のシーンにおけるサンプル視点。右上:CHCアルゴリズムによって必要とされる状態変化(状態変化の数 = 階層ノードの異なる色の数)。左下:CHC++アルゴリズムによって必要とされる状態変化。右下:マルチクエリ:すべての可視ノードがたった2つのオクルージョンクエリによって網羅される(異なる色で示される)。](){#fig:2}

# 関連研究 {#sec:2}

こんにちの急速に進化するグラフィクスハードウェアでしばしば発生するCPUに制約された[CPU-limited]アプリケーションでさえ、可視性カリングはグラフィクスドライバやレンダリングAPIにかかる時間を大幅に削減でき、グラフィクスハードウェアをより良く使うことができる。可視性カリングの一般的な概要について、Cohen-Or et al.[@COCSD02]やBittner and Wonka[@BW03]の精緻な調査[thorough surveys]を参照ください。

可視性アルゴリズムは事前処理の工程として処理するものと実行時に処理するものに大まかに分類することができる。事前処理のアルゴリズムは実行時のオーバーヘッドを一切持たないが、その一方で、しばしば実装し辛く、静的なシーンに対してのみ正常に動作する。一方のオンラインのオクルージョンカリングは長々しい事前処理の工程に頼らず、ひとつの点からの可視性を計算するためにより正確となる可能性があり、また、完全に動的なシーンに対して行うことが可能となる。ほとんどのオンラインのカリングアルゴリズムはイメージ空間で動作するため、ラスタライゼーションを用いて地頭的なオクルーダーの融合を可能にする。専用のハードウェアサポートが存在する前は、オンラインのオクルージョンカリングは、Zhang et al.によるHierarchical Occlusion Maps[@ZMHH97]やAila et al.によるdPVSシステム[@AM04]のようないくつかの有名な例外を除いて、実践で用いるにはコストが高すぎるとおおよそ考えられていた。

ハードウェアで高速化された[hardware accelerated]オクルージョンクエリの導入に伴い、オンラインのオクルージョンカリングは多くの人気を獲得した。ハードウェアオクルージョンクエリはフレームバッファを読み戻す必要なしにプロキシジオメトリの可視ピクセル数を返す比較的に軽量な命令である。これらは多種多様なアルゴリズム[@KS01; @HSLM02; @GSYM03; @SBS04; @KS05]に対する分野を開いたが、そのクエリはコストを伴うため、愚直な[naive]実装ではクエリが戻るのを待つことによって引き起こされるGPUおよびCPUのアイドル時間により非常に遅くなる可能性がある。

Coherent Hierarchical Culling[@BWPP04]や後のNear Optimal Hierarchical Culling[@GBK06]は時間的一貫性を利用することでアイドル時間を回避する。これらは次節にてその詳細を論じたい。

# 概要 {#sec:3}

この節では、CHCおよびNOHCアルゴリズムを手短に評し[briefly review]、これらの問題のいくつかを論ずる。その後、我々は新しいCHC++アルゴリズムの主要な構成要素を述べる。

## CHCとその問題 {#sec:3.1}

Coherent Hierarchical Cullingアルゴリズム[@BWPP04]はハードウェアオクルージョンクエリのオーバーヘッドおよびレイテンシを減らすために時間的および空間的一貫性を利用する。前から後ろへの順に階層を横断し、以前に可視であった[previously visible]リーフ^[訳注:木構造の葉ノード]と以前に不可視であった[previously invisible]境界のノードに対してのみクエリを発行する。以前に可視であったリーフは現在のフレームにおいて可視のままであると仮定され、故にこれらは即座にレンダリングされる。これらのノードに対するクエリの結果は次のフレームに対するこれらの分類を更新するのみである。不可視であるノードは不可視のままであると仮定されるが、そのアルゴリズムは可視性の変化を発見するために現在のフレームにおけるクエリ結果を検索する[retrieve]。オリジナルのCHCアルゴリズムの擬似コードに対する図6を参照のこと(印のない部分[unmarked parts])。

クエリ数の削減(クエリは以前に可視であった内側[interior]ノードに関して発行されない)と賢いインターリービングは許容できる量にまでオクルージョンクエリのオーバーヘッドを削減した。そのアルゴリズムは大量の遮蔽を持つシナリオに対して非常に上手く動作する。しかし、ジオメトリのレンダリングが問い合わせ[querying]と比べて安価となるより新しいハードウェアやシーンの多くが可視となる視点では、その手法は伝統的な視錐台カリングより低速にさえなる可能性がある。これは無駄なクエリや不必要な状態変化の結果である。この問題は視錐台カリングより確実に高速であるアルゴリズムを求めているゲーム開発者に対してCHCアルゴリズムを魅力的でなくしている。CHCのもうひとつの問題は高度に最適化されたゲームエンジンのレンダリングループへのその手法の複雑な統合にある。CHCは空間的階層の個々のノードのレンダリングと問い合わせを互い違いにする[interleave]。これはエンジンがマテリアルでのソートを処理することを不可能にし、より多数のエンジンAPI呼び出しを引き起こす。

## NOHCとその問題 {#sec:3.2}

Guthe et al.によって提案されるNear Optimal Hierarchical Cullingアルゴリズム[@GBK06]は無駄なクエリの問題に取り組む。その手法はクエリコストとレンダリングコストを推定するためにグラフィクスハードウェアの較正されたモデルを用いる。単純なスクリーンカバレッジモデルと時間的一貫性を仮定する更なる補正を用いることによってノードの遮蔽を推定する。その遮蔽推定とハードウェアモデルは現時点で処理されているノードに関してオクルージョンクエリを適用するかどうかを決める費用便益[cost/benefit]のヒューリスティクスに用いられる。このヒューリスティックは2、3の規則を伴うクエリに対する洗練された妥当性テストを用いる。

そのアルゴリズムは、かなりのクエリ数、特に可視ノード上に適用されるであろうクエリを節約する。これはCHCで提案される仮定された可視性の最適化が用いられない場合にCHCアルゴリズム全体に大幅な改善をもたらし得る。

NOHCに対する結果は、適切なハードウェア較正により、その手法が視錐台カリングより上手に常に処理されることを示している。これらの論文において、Guthe et al.[@GBK06]もまたオクルージョンクエリに基づいた最適なカリングアルゴリズムを定義した。その最適なアルゴリズムはすべてのカリングされるノードの状態がオクルージョンクエリによって検証されなければならないという前提の下で導出される。そうして、NOHC手法は最適なアルゴリズムに近づく。

我々の論文では、我々はGuthe et al.[@GBK06]によって用いられる最適性の定義が依然として多大な改善の余地を残している[leaves significant room for improvement]ことを示す。実際に、CHC++アルゴリズムはGuthe et al.によって定義される最適条件[optimum]を常に明らかに下回っている。

NOHCはハードウェアパラメータが人為的なレンダリングシナリオを用いる事前処理において測定されるハードウェア較正の工程を必要とする。モデルの正確なパラメータの測定は非常に慎重な[careful]実装を必要とする。しかし、精密に[precisely]実装したとしても、これらの測定は状態変化、パイプライン処理、実際のウォークスルー中のレンダリングとオクルージョンクエリのインターリービングの複合的な処理を反映する必要がないことが判明している。我々の新しい手法はハードウェア較正に頼らず、外部パラメータへの依存度を最小化することを目的とする。実際に、ユーザにはその影響度が十分に予測可能であるいくつかのパラメータを大まかに設定できるようにしてある。

## CHC++の構成要素[building blocks] {#sec:3.3}

TODO
