---
title: >
Performance and Memory Post Mortem for Middle-earth: Shadow of War [@Mintus2018]
---
# Performance and Memory Post Mortem for Middle-earth: Shadow of War

# Shadow of War

MONOLITH FIREBIRD engine

# Shadow of War

- 三人称視点のアクションアドベンチャーゲーム
- 2017年10月10日発売
- プラットフォーム: Xbox One, Xbox One S, Xbox One X, Playstation 4, Playstation 4 Pro, PC Win32, PC UWP
- 対象コンソールのフレームレート: 30 fps (33.3ms)
- 対象PCのフレームレート: 60 fps (16.6ms)

# Shadow of War

- Nemesis System
    - コアデザインの中心的存在[pillar]
    - ユニークなAI
        - 個性
        - 特徴[Traits]
        - <font color="red">見た目[Visuals]</font>

# Shadow of War

1. パフォーマンス最適化
2. メモリ最適化

# パフォーマンス最適化

# The Cost of War

- Shadow of MordorはアクティブAIをF.E.A.R. 2以来の8体から60体に移行する挑戦であった
- Shadow of Warの設計は<font color="">アクティブAIを200体</font>に移行することでこの挑戦をさらに先へと推し進めた
- これは<font color="red">Nemesis System</font>が要するAIロジックの実行と<font color="red">200体のユニークなAI</font>のレンダリングの両方で問題となる

# The Cost of War

||Shadow of Mordor|Shadow of War|
|-|-|-|
|AI数|60|200|
|AIあたりのメッシュ数(LOD0)|4|48|
|メッシュ密度|1x|5x|
|メッシュあたりのボーン数|32|64|

48ヶの部品 × 64ヶのボーン = キャラクターあたりの<font color="red">768ヶ</font>のボーン

# The Cost of War

||Shadow of Mordor|Shadow of War|
|-|-|-|
|エフェクト|CPUで約2ms|CPUで約20ms|
|GPUパーティクルエミッター|10〜20|5000超|
|ナビゲーションメッシュ|371kトライアングル|1.1Mトライアングル<br>8ヶのclearance cachesに76ヶのpathing sets|

# The Cost of War

- 酷いときは、このゲームはコンソール上でフレームあたり90msで動作した

# スレッディング

# スレッディング

- 200ヶのAIを同時にシミュレートさせるために、Shadow of Mordorから多くの<font color="red">ゲームシステム</font>を<font color="red">スレッド化</font>しなければならなかった
- これはエンジニアリングチームの大部分を消費した主な仕事であり、プロジェクトのほとんどを費やした

# スレッディング

|スレッド|説明|
|-|-|
|エフェクト|CPU上でエフェクトを処理するバックグラウンドスレッド|
|AI|200ヶのAIに対応するAI更新|
|経路探索[Path Finding]|バックグラウンドの経路探索スレッド|
|経路領域[Path Region]|バックグラウンドの経路領域更新スレッド|
|火のシミュレーション|火のシミュレーションスレッド|
|プレイヤーとAIのモーション|プレイヤーとAIのモーションシステム|

# スレッディング --- 同期プリミティブ

- アトミックなデータアクセス保護のために、カーネルプリミティブを用いるのを止め、<font color="red">軽量なアトミックスピンロック</font>を採用した
- コンテキストスイッチが望まれるときには、依然としてカーネルプリミティブが用いられる
- コンテキストスイッチの実際のコストはキャッシュの追い出し[eviction]である

# スレッディング --- 同期プリミティブ

- 軽量の<font color="red">多読み込み単書き込み[multiple readers single writer]</font>プリミティブを導入した
- 複数のスレッドからの物理シミュレーションの状態の読み出しはその例である
- MicrosoftのプラットフォームはSlim Reader/Writer (SRW) Locksプリミティブを持つ
- Sonyは同等のプリミティブを持つ

# スレッディング --- 同期プリミティブ

- <font color="red">2つのアトミックスピンロック</font>インスタンスと読み込み側の数を追跡するための <font color="red">1つのアトミックカウンター</font>を用いて実装できる
    - 1つ目のアトミックスピンロックは読み込み側のロックとして用いられる
    - 2つ目のアトミックスピンロックは書き込み側のロックとして用いられる

# スレッディング --- CPUクラスタ

- コンソールでは共有L2キャッシュの恩恵を得るために2つのCPUクラスタにワークロードを分割した
    - 1つ目のCPUクラスタはゲームプレイロジックを実行する
    - 2つ目のCPUクラスタはレンダリングロジックを実行する

# スレッディング --- CPUクラスタ

- Shadow of Warの増加した複雑さにより、これは結果として<font color="red">10%</font>のパフォーマンスゲインとなった
- クラスタが同時に同じキャッシュラインに触らないことが必須
    - 黒魔術やな

# スレッディング --- Monolithのアプローチ

- ジョブを大きく保つ
    - できるだけシングルスレッドのコードと同じ位に保つ
    - 後輩エンジニアにはエントリのレベルを低くする
    - 並行性によって生み出されるバグの量を少なくする
    - 同期の総量を少なくする必要がある
    - 一般的には結果としてCPUキャッシュが上手に使われるようになる

# スレッディング --- Monolithのアプローチ

- システム全体をバックグラウンドスレッド上に移す
- 大きなシステムでは強固な親和性[hard affinities]を設定する

# スレッディング --- Monolithのアプローチ

- 低優先度のスレッドで<font color="red">CPUの空白[gaps]</font>を埋める
    - <font color="red">非同期コンピュート</font>の概念と似ているが、これはCPUコアに対してである
    - ファイルI/O、ストリーミング、非同期レイキャストがその例である

# スレッディング --- Monolithのアプローチ

# スレッディング --- Monolithのアプローチ

<font color="red">モノリシック</font>なアプローチ

# スレッディング --- パイプライン化

- 操作は環状[circular]コマンドバッファの使用を通してパイプライン化される
- パイプラインは単方向に操作をプッシュする
- そして、これらコマンドバッファのひとつひとつは<font color="red">専用コア</font>で動作する<font color="red">専用スレッド</font>で実行される
- それぞれのパイプライン化されたステージをフレームあたり33.3msぴったりにできる

# スレッディング --- パイプライン化

# スレッディング --- 動的フレームペーシング[pacing]

- スレッドをパイプライン化するとき、パイプラインにある次のステージが<font color="red">1フレーム</font>(33.3ms)以上遅れないことを保証する
- 理想的には、すべてのパイプライン化されたステージは、それぞれが数[few]ミリ秒ズレて、<font color="red">並列</font>に動作している
- これはパイプライン全体がパイプラインにおける最初のステージによって束縛される場合に正しくなるだろう

# スレッディング --- 動的フレームペーシング

- システム全体が最後のステージによって束縛される場合、最終的には数[several]フレーム後にシミュレートされたフレームを表示することになる
- これはパイプラインの<font color="red">telescoping</font>の性質によって引き起こされる
- 垂直同期を行うときは常に最後のステージによって束縛される

# スレッディング --- 動的フレームペーシング

シミュレーションスレッド
↓
レンダスレッド
↓
ドライバスレッド
↓
GPU
↓
ディスプレイキュー
↓
ディスプレイ

33.3ms + 33.3ms + 33.3ms + 33.3ms + 33.3ms + 33.3ms = <font color="red">200</font>ms

# スレッディング --- 動的フレームペーシング

- 入力はシミュレーションスレッドで計算されるので、フレームがスクリーンに表示されるまで最大<font color="red">200</font>msとなり、入力レイテンシーが問題となる

# スレッディング --- 動的フレームペーシング

- 我々の解決法は動的フレームペーシングシステムである
- このシステムは<font color="red">GPU</font>上の<font color="red">ディスプレイキュー</font>をモニターする。キューが満杯ならば、GPUによって束縛されている
- GPU束縛されているとき、最初のステージ、そのシミュレーションスレッドを人為的にストールさせるので、割り当てられる時間より若干<font color="red">多く</font>かかる。すなわち、Sleep(33.3 - TimeOfSimulationThread <font color="red">+ 1</font>)
- これによりtelescopeが収縮する

# スレッディング --- 動的フレームペーシング

# スレッディング

- これでシミュレーションスレッドは知る限りの最悪のケースで50msにまで減少した

# レンダラ

# レンダラ

||Shadow of Mordor|Shadow of War|
|-|-|-|
|Xbox One API|D3D11/D3D11.X混合|高速セマンティクス付きD3D11.X|
|PS4 API|GNM|LCUE|
|PC API(最小)|D3D11.0|D3D11.1|
|PCハードウェア(最小)|11_0|11_0|
|コンソールコア|2|1.5|

# レンダラ --- 定数バッファ

- ゲームとエンジンの抽象レイヤーの間に多すぎるほどのコピーが作られた
- 各定数は個々に設定され、その後、定数バッファに集められた
- 定数バッファはドローコールごとに再生成された

# レンダラ --- 定数バッファ

- 更新頻度に基づいて定数バッファを分解した
- レンダラにおいて定数へアクセスすると、実際の定数バッファへのポインタが返される
- アクセサを通してゲームに直接定数バッファを開示した

# レンダラ --- 定数バッファ

- ダーティステートとフレームコードを通して追跡した
- ひとたびGPUに送られると、新しいコピーが作られ、ダーティステートがクリアされる
- メモリはGPUによってフレームコードがクリアされるまで再利用されない

# レンダラ --- 定数バッファ

- 名前付き定数バッファをバインドすることは単にポインタを設定することである
- <font color="red">マテリアル定数バッファ</font>は調理時[cook time]にアセットに焼き込まれる

# レンダラ --- 定数バッファ

|Shadow of Mordor|Shadow of War|
|-|-|
|$Global|$Global|
||Frame|
||View|
||Material|
||RenderTarget|
||<font color="red">CurrentBones</font>|
||<font color="red">PreviousBones</font>|
||Vegetation|
||Wind|
||TiledLighting|

# レンダラ --- 定数バッファ

48ヶの部品 × 64ヶのボーン × 2ヶの前フレーム × 200ヶのAI

= フレームあたり<font color="red">307,200</font>ヶのボーン変換
× <font color="red">4</font>ヶのレンダステージ
= フレームあたり<font color="red">1,228,800</font>ヶのボーン変換

# レンダラ --- 定数バッファ

- 各定数バッファの定数は定数が使われる頻度のヒューリスティクスを得ることで手でソートされた
- 稀に使われる定数や通常0に設定される定数は定数バッファの最下部にソートされた


- <font color="red">使用される</font>定数と<font color="red">0</font>でない定数を保持するのに十分大きい定数バッファのみを割り当てる
    - これはアクセスされるメモリ量を劇的に少なくする
    # レンダラ --- 定数バッファ
    - GPUではバッファの終端以降を読み込むと単に0を返す^[訳注:単なるUBの結果なのでは…と思うが、そういう仕様が存在するのか？]
    - グラフィクスAPIのエラースパムを引き起こすが、これは抑えられる

# レンダラ --- 定数バッファ

- 変更がなければ、異なるステージで再利用するためにレンダノードと一緒に定数バッファをキャッシュした
    - GバッファステージとCSMステージに対するボーン

# レンダラ --- 一般的な最適化

- より高速なファーストパーティのグラフィクスAPIに切り替えた
    - 高速セマンティクス付きD3D11.X/LCUE
- フレーム間の参照カウンタをすべて取り除いた
- 寿命はフレームコードを用いてのみ管理される
- グラフィクスAPIステート全体をキャッシュした
    - ファーストパーティのグラフィクスAPIへの冗長なステート変更を取り除いた

# レンダラ --- 一般的な最適化

- キャッシュライン境界で動的GPUメモリを割り当て、キャッシュラインの終端をパディングし、CPUアクセスのためにフレームコードでこのメモリを追跡することでCPUおよびGPUキャッシュflushingを減らした

# レンダラ --- 一般的な最適化

- 動的CPU負荷スケーリング
    - メッシュ数を少なくするためにCPU負荷に基づいてLODを押し上げる
    - CPU使用率、メモリプレッシャー、物理ページマッピングのコストを下げるために高次のMIPストリーミングを一時停止する

# レンダラ

- レンダスレッドは知る限りの最悪のケースから45msまで低下した

# パフォーマンス --- メモリ

# パフォーマンス --- メモリ

- Shadow of Warにおいてパフォーマンスに大幅な改善をもたらしたもの[huge performance win]はすべてのアロケーションを大きな<font color="red">2MiBのページ</font>に切り替えたことである
    - 64KiBのページよりも<font color="red">20%</font>のパフォーマンスゲイン
    - 大きなページは非常にコストのかかる<font color="red">Translation Lookaside Buffers (TLBs)ミスを減らす</font>
- プロセス生成時にすべての大きなページを事前に割り当てる
- PCでもこれを実装したが、それでもPCはほぼ常にGPU限界である

# パフォーマンス --- メモリ

GPU非コヒーレント(2MiBページ) 1,536
GPUコヒーレント(2MiBページ) 256
テクスチャGPU非コヒーレント(64KiBページ) 1,024
CPUメモリ(2MiBページ) 2,048

# パフォーマンス --- メモリ

- 知る限りの最悪のケースで、シミュレーションスレッドは40msまで下がり、レンダスレッドは36msまで下がった

# パフォーマンス --- とどめの一撃

# パフォーマンス --- とどめの一撃

- 開発ビルド
    - DLLsがエンジニアリングのイテレーションを改善するのに使われている
    - すべてのプロジェクトでインクリメンタルリンキングが有効化されている
    - Debug:FastLinkが利用可能で、何人かのエンジニアによって使われている
    - 実行ファイルはこれらのDLLsを読み込んで実行する極小さなスタブである

# パフォーマンス --- とどめの一撃

- リテールビルド
    - DLLsはLIBsとしてコンパイルする
    - インクリメンタルリンキングを無効化する
    - 実行ファイルは依然としてこれらLIBsにリンクされる極小さなスタブである
    - 実行パフォーマンスを約<font color="red">10%</font>改善する

# パフォーマンス --- とどめの一撃

- リテールビルド
    - LTCG^[Link-Time Code Generation]は、すべてのミドルウェアを含め、すべてのプラットフォーム、すべてのプロジェクトで有効化する
    - MicrosoftのプラットフォームにおけるLTCGはもう<font color="red">10%</font>の改善を、PS4では<font color="red">5%</font>の改善をもたらす
    - PGO^[Profile Guided Optimization]はすべてのプラットフォームで有効化する
    - PGOはすべてのプラットフォームで約<font color="red">5%</font>のパフォーマンスを改善する
    - MicrosoftプラットフォームではCOMDAT foldingを確実に無効化する
        - PGOによるゲインを打ち消すだろう

# パフォーマンス --- とどめの一撃

- 知る限りの最悪のケースで、シミュレーションスレッドは33msまで下がり、レンダスレッドは30msまで下がった

# メモリ最適化

# メモリ最適化 --- GPU仮想メモリ

- モダンなGPUはCPUような仮想メモリを用いる
- 物理メモリは連続している必要はない
- 物理メモリはページ粒度でマップおよびアンマップされている可能性がある
- 単一の物理メモリページは複数の仮想メモリアドレスにマップされている可能性がある

# メモリ最適化 -- GPU仮想メモリ

# メモリ --- 64KiBページ

- <font color="red">64KiB</font>のページを用いる利点は、大きなページより小さいことであり、より優れた共有や再利用を可能にすることである
- 64KiBのページを用いる欠点は<font color="red">TLBミス</font>が増えることでアクセスが遅くなることである

# メモリ --- ミップマップのストリーミング

# メモリ --- ミップマップのストリーミング

- Shadow of Mordorでは、ミップマップを流し入れ[stream in]ていたが、アンロードは一切しなかった
    - これは主にロード時間を短くするために行われた
    - テクスチャをが使用された場合、その高次のミップが流し入れられる
- Shadow of Warでは、メモリを節約するために高次のミップマップを出し入れする必要があった
    - 固定のミップマップメモリプールを用いていた
    - 高次のミップはTexture2Dに対して<font color="red">66%</font>のメモリとなる

# メモリ --- ミップマップのストリーミング

- cook時、すべてのメッシュを解析して、最も大きなテクセル密度を持つ最大のトライアングルを決定する。保存しておく
- 実行時、メッシュをレンダリングするとき、このトライアングルをCPUを用いてスクリーン空間に投影して,
<font color="red">近似</font>ミップマップ値を計算する

# メモリ --- ミップマップのストリーミング

- CPUシステムは、フレーム(64)ごとに解析できるマテリアルあたりのメッシュ数、メッシュあたりのフレームコード、thrashingを回避するための緩衝材によって調整[throttle]される
    - 毎秒<font color="red">1920</font>ヶのメッシュがテストされる
- ミップマップ解析のCPUコストはフレームあたり<font color="red">0.1ms</font>で固定される

# メモリ --- ミップマップのストリーミング

- 高次のミップは64KiBページのプールを用いる。このページのプールはプロセス生成時に事前に割り当てられる
- 高次のミップはプールが枯渇するまでロードされる
- 高次ミップストリーミングをサポートするすべてのテクスチャはphysical memory backing for their high mipなして生成される

# メモリ --- ミップマップのストリーミング

# メモリ --- ミップマップのストリーミング

- 結論
    - 高次ミップにメモリプールを用いると約<font color="red">1.0</font>GiBのメモリが節約された

# メモリ --- Texture2DArray

# メモリ --- Texture2DArray

- Shadow of Warはかなりの量のTexture2DArraysを用いている
    - 地形[Terrain]
    - キャラクターモデル
    - ほとんどの構造物
    - エフェクトのパラパラマンガ[flipbooks]

# メモリ --- Texture2DArray

- 利点
    - Texture2DArrays内のスライスはすべて<font color="red">ブレンディング</font>に対して素晴らしい同じレベルでサンプリングされる
    - 一般にいくつかのTexture2Dsをサンプリングするときのそれより、ひとつのTexture2DArrayをサンプリングするシェーダのほうが分岐を回避し易い

# メモリ --- Texture2DArray

- 問題
    - <font color="red">パッディング</font> --- AMDハードウェアにおけるTexture2DArraysはミップあたり、スライスあたりで格納される。これは最終的にスライス数を<font color="red">2の累乗</font>にパッディングすることとなる。テクスチャ配列が<font color="red">3つのスライス</font>を含む場合、メモリレイアウトは<font color="red">4つのスライス</font>を含んでいる

# メモリ --- Texture2DArray

- 問題
    - <font color="red">複製</font> --- 2つのTexture2DArraysが同じスライスを用いる場合、そのスライスはメモリ上に<font color="red">複製される</font>ことになる
        - 例えば、これらの配列が一般的にブレンディングに使われるとしよう。降雪地帯では、すべてが雪とブレンドされるだろう。その雪のテクスチャスライスは多くのテクスチャ配列に<font color="red">複製される</font>だろう

# メモリ --- Texture2DArray

- <font color="red">パッディング</font>を回避[get around]するために、GPUによって実際に読まれるテクスチャの部分に64KiBページを<font color="red">手動でバインド</font>する
- 物理メモリで<font color="red">パッディング</font>しているレイアウトをbackしない
- <font color="red">パックされたミップ</font>は64KiBより小さく、ひとつの64KiBページを共有するミップである。これらは常に物理メモリページによってbackされる

# メモリ --- Texture2DArray

# メモリ --- Texture2DArray

- スライス間で64KiBの物理メモリページを<font color="red">共有</font>することで<font color="red">複製</font>を解決した
- Texture2DArraysはTexture2Dスライスへの<font color="">参照</font>を含むのみである
- 実行時、スライスの物理ページはTexture2DArraysにマップされる
- 各スライスは<font color="red">参照カウント</font>される。スライスに対する物理メモリはすべての参照がなくなるまで解放されない

# メモリ --- Texture2DArray

- <font color="red">パックされたミップ</font>は単一の64KiBページより小さく、複製されたままである
- この解法では通常のTexture2Dとしてスライスを用いてメモリのTexture2DArrayと共有することもできる
- 一度にひとつのスライスをcookするだけでよいので、cook時間が減ったりもした

# メモリ --- Texture2DArray

# メモリ --- Texture2DArray

- 結論
    - <font color="red">複製</font>を避けることで、平均でだいたい<font color="red">300</font>MiBを節約した
        - シーン依存
    - パッディングを回避することで、2の累乗でない配列をアーティストが生成できた

# Join us!

#

# ありがとうございました

ご質問は？
