---
title: >
Performance and Memory Post Mortem for Middle-earth: Shadow of War [@Mintus2018]
---
# Performance and Memory Post Mortem for Middle-earth: Shadow of War

# Shadow of War

MONOLITH FIREBIRD engine

# Shadow of War

- 三人称視点のアクションアドベンチャーゲーム
- 2017年10月10日発売
- プラットフォーム: Xbox One, Xbox One S, Xbox One X, Playstation 4, Playstation 4 Pro, PC Win32, PC UWP
- 対象コンソールのフレームレート: 30 fps (33.3ms)
- 対象PCのフレームレート: 60 fps (16.6ms)

# Shadow of War

- Nemesis System
    - コアデザインの中心的存在[pillar]
    - ユニークなAI
        - 個性
        - 特徴[Traits]
        - <font color="red">見た目[Visuals]</font>

# Shadow of War

1. パフォーマンス最適化
2. メモリ最適化

# パフォーマンス最適化

# The Cost of War

- Shadow of MordorはアクティブAIをF.E.A.R. 2以来の8体から60体に移行する挑戦であった
- Shadow of Warの設計は<font color="">アクティブAIを200体</font>に移行することでこの挑戦をさらに先へと推し進めた
- これは<font color="red">Nemesis System</font>が要するAIロジックの実行と<font color="red">200体のユニークなAI</font>のレンダリングの両方で問題となる

# The Cost of War

||Shadow of Mordor|Shadow of War|
|-|-|-|
|AI数|60|200|
|AIあたりのメッシュ数(LOD0)|4|48|
|メッシュ密度|1x|5x|
|メッシュあたりのボーン数|32|64|

48ヶの部品 × 64ヶのボーン = キャラクターあたりの<font color="red">768ヶ</font>のボーン

# The Cost of War

||Shadow of Mordor|Shadow of War|
|-|-|-|
|エフェクト|CPUで約2ms|CPUで約20ms|
|GPUパーティクルエミッター|10〜20|5000超|
|ナビゲーションメッシュ|371kトライアングル|1.1Mトライアングル<br>8ヶのclearance cachesに76ヶのpathing sets|

# The Cost of War

- 酷いときは、このゲームはコンソール上でフレームあたり90msで動作した

# スレッディング

# スレッディング

- 200ヶのAIを同時にシミュレートさせるために、Shadow of Mordorから多くの<font color="red">ゲームシステム</font>を<font color="red">スレッド化</font>しなければならなかった
- これはエンジニアリングチームの大部分を消費した主な仕事であり、プロジェクトのほとんどを費やした

# スレッディング

|スレッド|説明|
|-|-|
|エフェクト|CPU上でエフェクトを処理するバックグラウンドスレッド|
|AI|200ヶのAIに対応するAI更新|
|経路探索[Path Finding]|バックグラウンドの経路探索スレッド|
|経路領域[Path Region]|バックグラウンドの経路領域更新スレッド|
|火のシミュレーション|火のシミュレーションスレッド|
|プレイヤーとAIのモーション|プレイヤーとAIのモーションシステム|

# スレッディング --- 同期プリミティブ

- アトミックなデータアクセス保護のために、カーネルプリミティブを用いるのを止め、<font color="red">軽量なアトミックスピンロック</font>を採用した
- コンテキストスイッチが望まれるときには、依然としてカーネルプリミティブが用いられる
- コンテキストスイッチの実際のコストはキャッシュの追い出し[eviction]である

# スレッディング --- 同期プリミティブ

- 軽量の<font color="red">多読み込み単書き込み[multiple readers single writer]</font>プリミティブを導入した
- 複数のスレッドからの物理シミュレーションの状態の読み出しはその例である
- MicrosoftのプラットフォームはSlim Reader/Writer (SRW) Locksプリミティブを持つ
- Sonyは同等のプリミティブを持つ

# スレッディング --- 同期プリミティブ

- <font color="red">2つのアトミックスピンロック</font>インスタンスと読み込み側の数を追跡するための <font color="red">1つのアトミックカウンター</font>を用いて実装できる
    - 1つ目のアトミックスピンロックは読み込み側のロックとして用いられる
    - 2つ目のアトミックスピンロックは書き込み側のロックとして用いられる

# スレッディング --- CPUクラスタ

- コンソールでは共有L2キャッシュの恩恵を得るために2つのCPUクラスタにワークロードを分割した
    - 1つ目のCPUクラスタはゲームプレイロジックを実行する
    - 2つ目のCPUクラスタはレンダリングロジックを実行する

# スレッディング --- CPUクラスタ

- Shadow of Warの増加した複雑さにより、これは結果として<font color="red">10%</font>のパフォーマンスゲインとなった
- クラスタが同時に同じキャッシュラインに触らないことが必須
    - 黒魔術やな

# スレッディング --- Monolithのアプローチ

- ジョブを大きく保つ
    - できるだけシングルスレッドのコードと同じ位に保つ
    - 後輩エンジニアにはエントリのレベルを低くする
    - 並行性によって生み出されるバグの量を少なくする
    - 同期の総量を少なくする必要がある
    - 一般的には結果としてCPUキャッシュが上手に使われるようになる

# スレッディング --- Monolithのアプローチ

- システム全体をバックグラウンドスレッド上に移す
- 大きなシステムでは強固な親和性[hard affinities]を設定する

# スレッディング --- Monolithのアプローチ

- 低優先度のスレッドで<font color="red">CPUの空白[gaps]</font>を埋める
    - <font color="red">非同期コンピュート</font>の概念と似ているが、これはCPUコアに対してである
    - ファイルI/O、ストリーミング、非同期レイキャストがその例である

# スレッディング --- Monolithのアプローチ

# スレッディング --- Monolithのアプローチ

<font color="red">モノリシック</font>なアプローチ

# スレッディング --- パイプライン化

- 操作は環状[circular]コマンドバッファの使用を通してパイプライン化される
- パイプラインは単方向に操作をプッシュする
- そして、これらコマンドバッファのひとつひとつは<font color="red">専用コア</font>で動作する<font color="red">専用スレッド</font>で実行される
- それぞれのパイプライン化されたステージをフレームあたり33.3msぴったりにできる

# スレッディング --- パイプライン化

# スレッディング --- 動的フレームペーシング[pacing]

- スレッドをパイプライン化するとき、パイプラインにある次のステージが<font color="red">1フレーム</font>(33.3ms)以上遅れないことを保証する
- 理想的には、すべてのパイプライン化されたステージは、それぞれが数[few]ミリ秒ズレて、<font color="red">並列</font>に動作している
- これはパイプライン全体がパイプラインにおける最初のステージによって束縛される場合に正しくなるだろう

# スレッディング --- 動的フレームペーシング

- システム全体が最後のステージによって束縛される場合、最終的には数[several]フレーム後にシミュレートされたフレームを表示することになる
- これはパイプラインの<font color="red">telescoping</font>の性質によって引き起こされる
- 垂直同期を行うときは常に最後のステージによって束縛される

# スレッディング --- 動的フレームペーシング

シミュレーションスレッド
↓
レンダスレッド
↓
ドライバスレッド
↓
GPU
↓
ディスプレイキュー
↓
ディスプレイ

33.3ms + 33.3ms + 33.3ms + 33.3ms + 33.3ms + 33.3ms = <font color="red">200</font>ms

# スレッディング --- 動的フレームペーシング

- 入力はシミュレーションスレッドで計算されるので、フレームがスクリーンに表示されるまで最大<font color="red">200</font>msとなり、入力レイテンシーが問題となる

# スレッディング --- 動的フレームペーシング

- 我々の解決法は動的フレームペーシングシステムである
- このシステムは<font color="red">GPU</font>上の<font color="red">ディスプレイキュー</font>をモニターする。キューが満杯ならば、GPUによって束縛されている
- GPU束縛されているとき、最初のステージ、そのシミュレーションスレッドを人為的にストールさせるので、割り当てられる時間より若干<font color="red">多く</font>かかる。すなわち、Sleep(33.3 - TimeOfSimulationThread <font color="red">+ 1</font>)
- これによりtelescopeが収縮する

# スレッディング --- 動的フレームペーシング

# スレッディング

- これでシミュレーションスレッドは知る限りの最悪のケースで50msにまで減少した

# レンダラ

# レンダラ

||Shadow of Mordor|Shadow of War|
|-|-|-|
|Xbox One API|D3D11/D3D11.X混合|高速セマンティクス付きD3D11.X|
|PS4 API|GNM|LCUE|
|PC API(最小)|D3D11.0|D3D11.1|
|PCハードウェア(最小)|11_0|11_0|
|コンソールコア|2|1.5|

# レンダラ --- 定数バッファ

- ゲームとエンジンの抽象レイヤーの間に多すぎるほどのコピーが作られた
- 各定数は個々に設定され、その後、定数バッファに集められた
- 定数バッファはドローコールごとに再生成された

# レンダラ --- 定数バッファ

- 更新頻度に基づいて定数バッファを分解した
- レンダラにおいて定数へアクセスすると、実際の定数バッファへのポインタが返される
- アクセサを通してゲームに直接定数バッファを開示した

# レンダラ --- 定数バッファ

- ダーティステートとフレームコードを通して追跡した
- ひとたびGPUに送られると、新しいコピーが作られ、ダーティステートがクリアされる
- メモリはGPUによってフレームコードがクリアされるまで再利用されない

# レンダラ --- 定数バッファ

- 名前付き定数バッファをバインドすることは単にポインタを設定することである
- <font color="red">マテリアル定数バッファ</font>は調理時[cook time]にアセットに焼き込まれる

# レンダラ --- 定数バッファ

|Shadow of Mordor|Shadow of War|
|-|-|
|$Global|$Global|
||Frame|
||View|
||Material|
||RenderTarget|
||<font color="red">CurrentBones</font>|
||<font color="red">PreviousBones</font>|
||Vegetation|
||Wind|
||TiledLighting|

# レンダラ --- 定数バッファ

48ヶの部品 × 64ヶのボーン × 2ヶの前フレーム × 200ヶのAI

= フレームあたり<font color="red">307,200</font>ヶのボーン変換
× <font color="red">4</font>ヶのレンダステージ
= フレームあたり<font color="red">1,228,800</font>ヶのボーン変換

# レンダラ --- 定数バッファ

- 各定数バッファの定数は定数が使われる頻度のヒューリスティクスを得ることで手でソートされた
- 稀に使われる定数や通常0に設定される定数は定数バッファの最下部にソートされた

# レンダラ --- 定数バッファ

TODO
