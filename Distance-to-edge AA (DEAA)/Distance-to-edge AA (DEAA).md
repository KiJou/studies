---
title: Distance-to-edge AA (DEAA)
numberSections: false
---
# 結果[Results]

上段が元画像であり、下段がアンチエイリアスした結果である。

このアンチエイリアシング手法はMLAAやポストプロセスとして処理する他のすべてのアンチエイリアシングエフェクトと同じファミリーの一部である。我々が取っているこのアプローチはbeautyパス中にピクセルシェーダでエッジまでの距離を計算して、その色と一緒にブラーヒントを書き出すことである。このテクニックの大きな利点は、最大256の異なるブラーレベルにより、とても滑らかなエッジを供給し、回転するエッジのcrawlingのようなMLAAテクニックが持つ時間的な問題の多くを避ける能力を持つことである。

これは標準のMLAAとは異なる強みと弱みを持つ。distance-to-edgeは解析的に計算されるので、ピクセルの近傍でのエッジ検索が存在しない。なので、高価な局所検索[local-search]ステップは完全にスキップされる。対応する欠点は、distance-to-edge情報を格納するためのフレームバッファに追加スペースが必要になることである。8ビットあれば大丈夫だが、32ビットが理想的だろう。


その他2、3つ欠点を持つが、それは取り扱おうと思う。

我々はAPBにそれを適用することを調査した。我々が直面する問題を入念に調査する。明白な質問は、なぜこれが間に合わなかったのか、ということである。その理由は極めて退屈であるためである。この手法は我々がそれらのコンテンツと共に実行したときに2、3の問題を抱えていた。我々は未だにこれらの問題に取り組んでおり、ローンチのためにアセットを最終的に確定[lock down]していたとき、それの統合について考え始める準備が整っていなかった。

# エッジへの距離[Distance to edge]

このテクニックの最も重要な部分は、ピクセルシェーダで最も近いトライアングルのエッジへの距離を計算する手法である。なので、そこから始めようと思う。

与えられたトライアングルに対して、頂点プログラムがある頂点で`v = 1`を、その他の頂点/反対側のエッジで`v = 0`を出力する場合、補間された値`v`は大まかにそのエッジからの距離に比例する。

<!-- p.5 -->

$$
\left( \frac{-\nu}{\frac{\partial \nu}{\partial x}}, \frac{-\nu}{\frac{\partial \nu}{\partial y}} \right)
$$

```hlsl
distance_x = -v / ddx(v)
distance_y = -v / ddy(v)
```

`distance_x = -v / (dv / dx)`と`distance_y = -v / (dv / dy)`はスクリーンピクセルでのトライアングルのエッジへの符号付き距離を与える。もし`distance_x`が正ならば、トライアングルエッジは現在のピクセルの右側にあり、負ならば、現在のピクセルの左側にある。

この手法はピクセルシェーダが、とても良好な精度で、トライアングルのある特定のエッジへの距離を計算できるようにする。パースペクティブ補正のため、`v`はトライアングルのいたる所で線形に補間される訳ではなく、計算は厳密な値ではなく推定値をもたらす。

基本のddx/ddyのスクリーン空間のエッジへの距離の計算[math]に対する興味深い使い方がたくさんあるが、このトークではそこまで触れないと思う。

ともかく、次のステップは、スキンメッシュや変形メッシュ、プロシージャルに生成されるジオメトリ、こんにちのゲームで見られるその他すべてをサポートする、輪郭の頂点で0を、その他で1を出力する、高速でロバストなコードを頂点プログラムでセットアップすることである。

<!-- p.6 -->

TODO
