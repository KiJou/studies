---
title: Distance-to-edge AA (DEAA)
numberSections: false
---
# 結果[Results]

上段が元画像であり、下段がアンチエイリアスした結果である。

このアンチエイリアシング手法はMLAAやポストプロセスとして処理する他のすべてのアンチエイリアシングエフェクトと同じファミリーの一部である。我々が取っているこのアプローチはbeautyパス中にピクセルシェーダでエッジまでの距離を計算して、その色と一緒にブラーヒントを書き出すことである。このテクニックの大きな利点は、最大256の異なるブラーレベルにより、とても滑らかなエッジを供給し、回転するエッジのcrawlingのようなMLAAテクニックが持つ時間的な問題の多くを避ける能力を持つことである。

これは標準のMLAAとは異なる強みと弱みを持つ。distance-to-edgeは解析的に計算されるので、ピクセルの近傍でのエッジ検索が存在しない。なので、高価な局所検索[local-search]ステップは完全にスキップされる。対応する欠点は、distance-to-edge情報を格納するためのフレームバッファに追加スペースが必要になることである。8ビットあれば大丈夫だが、32ビットが理想的だろう。


その他2、3つ欠点を持つが、それは取り扱おうと思う。

我々はAPBにそれを適用することを調査した。我々が直面する問題を入念に調査する。明白な質問は、なぜこれが間に合わなかったのか、ということである。その理由は極めて退屈であるためである。この手法は我々がそれらのコンテンツと共に実行したときに2、3の問題を抱えていた。我々は未だにこれらの問題に取り組んでおり、ローンチのためにアセットを最終的に確定[lock down]していたとき、それの統合について考え始める準備が整っていなかった。

# エッジへの距離[Distance to edge]

このテクニックの最も重要な部分は、ピクセルシェーダで最も近いトライアングルのエッジへの距離を計算する手法である。なので、そこから始めようと思う。

与えられたトライアングルに対して、頂点プログラムがある頂点で`v = 1`を、その他の頂点/反対側のエッジで`v = 0`を出力する場合、補間された値`v`は大まかにそのエッジからの距離に比例する。

<!-- p.5 -->

$$
\left( \frac{-\nu}{\frac{\partial \nu}{\partial x}}, \frac{-\nu}{\frac{\partial \nu}{\partial y}} \right)
$$

```hlsl
distance_x = -v / ddx(v)
distance_y = -v / ddy(v)
```

`distance_x = -v / (dv / dx)`と`distance_y = -v / (dv / dy)`はスクリーンピクセルでのトライアングルのエッジへの符号付き距離を与える。もし`distance_x`が正ならば、トライアングルエッジは現在のピクセルの右側にあり、負ならば、現在のピクセルの左側にある。

この手法はピクセルシェーダが、とても良好な精度で、トライアングルのある特定のエッジへの距離を計算できるようにする。パースペクティブ補正のため、`v`はトライアングルのいたる所で線形に補間される訳ではなく、計算は厳密な値ではなく推定値をもたらす。

基本のddx/ddyのスクリーン空間のエッジへの距離の計算[math]に対する興味深い使い方がたくさんあるが、このトークではそこまで触れないと思う。

ともかく、次のステップは、スキンメッシュや変形メッシュ、プロシージャルに生成されるジオメトリ、こんにちのゲームで見られるその他すべてをサポートする、輪郭の頂点で0を、その他で1を出力する、高速でロバストなコードを頂点プログラムでセットアップすることである。

<!-- p.6 -->

残念ながら、私はそのようなコードを一切知らない。たくさんの手法で実験したが、選択肢に入るようなロバストかつ高速なものを見つけることはできなかった。私は、すべてのエイリアスしたエッジに対してdistance-to-edgeヒントを書き出し、色の差に基づいてブラーするかどうかをポストプロセスに決めさせる、まったく異なるアプローチを取ることを提案したいと思った。

3つのエッジすべてに対するdistance-to-edgeの値の計算は素直である。`v`をスカラではなく3要素のベクトルとすることでこれを行う。この画像は色としてベクトル`v`を示す。3つの頂点のそれぞれである要素が1に、それ以外が0になっている。別の言い方をすれば、トライアングルの各エッジに沿うと、確定でひとつの要素が0になる --- 例えば、画像では、上のエッジは青の要素によって、左のエッジは緑の要素によって暗示される。

故に、我々は現在シェーディングしているピクセルの上下左右の4方向におけるトライアングルのエッジへの距離を計算できる。正確には、方向ごとに3つのトライアングルエッジへの距離を測定し、その3つの値の最小を取る。

恐らくあなたの想像通りに、すべての計算[math]はベクトル化でき、完全に分岐なしにできる。

<!-- p.7 -->

このダイアグラムは描画された大きなトライアングルを示す。黒い線はそのトライアングルのエッジである。線の下のピクセルはトライアングルの内側であり、ラスタライズされる。矢印はトライアングルエッジへの上方向の距離が1ピクセルより小さい所のピクセルを指し示す --- 間もなく明らかになる理由により、1ピクセルより大きい距離について気にしない。

我々は上下左右の4方向の距離の値を計算した。要素あたり8ビットのRGBAレンダターゲットにこれらを格納することは自然な選択である。これはかなり高価な品物である --- これが取引を失敗させる[dealbreaker]場合には、いくつか他の選択肢がある。

このトライアングルが表面の一部であるならば、黒の線によって示されるエッジのもう一方の側でレンダリングされ、ここに示される下方向の距離の厳密に逆の値である上方向に対するdistance-to-edgeの値を書き出す相補的なトライアングルを期待するだろう。しかし、黒の線が輪郭のエッジであるならば、これは起こらないだろう。そして、相補的なピクセルの距離は任意の値になる。これらのケースはポストプロセスについて話すときにもう一度やって来るだろう。

これらの距離ヒントはエッジがアンチエイリアシングを必要とするか否かに関わらず、何があろうと書き込まれることにも注意。

# ポストプロセス[The postprocess]

どのようにポストプロセスが動作するかを説明するために、1Dの場合から始めよう。

上の画像は2つのケースを示す。緑と青の長方形はラスタライズされたジオメトリの2つの要素[pieces]を示している。これらは2つのケースで若干異なる。p0、p1、p2の3ピクセルが含まれている。赤の縦長の線は、ラスタライザがジオメトリをサンプルし、この後のパスのピクセルシェーダで実行される所の位置に対応するピクセル中心を示す。黒の短い縦線はピクセル中心の間の中点を示す。矢印はピクセル中心ごとに格納されるdistance-to-edgeを示す。最大距離は1ピクセルにクランプされる。

ダイアグラムでは、立方体が緑色の領域で、空が青色であるとする。ピクセルp1は立方体の一部であり、ピクセルp2は空の一部である。立方体がラスタライズされたとき、p1に書き込み、distance-to-edgeの値をセットアップするが、p2は大きな空のトライアングルの一部であり、関連するdistance-to-edgeヒントを持たない。

この場合、隣り合うペアのひとつのピクセルのみがdistance-to-edgeの値を持つ。これはすべての輪郭のエッジや非多様体[non-manifold]に近いエッジに沿って発生するだろう。

考慮すべき他2つのケースがある。2つの隣り合うピクセルは相補的なdistance-to-edgeの値を持つかもしれない --- これは2つのピクセルがエッジを共有する2つの隣接するトライアングルの中にあるときに起こるだろう。あるいは、距離が両方とも定義されるが相補的でないかもしれない。これはサブピクセルトライアングルが大量にあると発生するだろう。

<!-- p.9 -->

TODO
