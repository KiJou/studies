---
title: >
Jimenez's MLAA & SMAA: Subpixel Morphological Anti-Aliasing
numberSections: false
---
# 重要な機能[Key Features]

- **高品質**
    - 16階調(または、それ以上！)
    - 耐ノイズ性[noise proof] → **時間的に安定**
    - 鮮鋭さ[sharpness]の保存
- **高速**
    - 720pで0.28ms (GeForce GTX 470)
    - MSAAより約1180%速い[beats MSAA by about a 1180%] (GeForce 9800 GTX+)
- **低メモリフットプリント**
    - バックバッファサイズの2倍
- **ポータブル**
- **カスタマイズ可能なエッジ検出**

テクニックの開発中に、我々はいくつかのトレードオフを決めておかなければならなかった。

<!-- p.6 -->

まずはじめに、できる限りの最高品質を達成することに最も重点を置いている。

- 16xMSAAによって生み出されるこれらを凌ぐオブジェクトの輪郭でのグラデーションを得る。
- 最新バージョンでは、更に時間的に安定であり、より良いノイズ管理を持つ。
- より良い鮮鋭さの保存となる、本当に必要な所だけに触れるので、画像に対して保守的である。

<!-- p.7 -->

高品質の次に、できる限りの最高のパフォーマンスを達成しようとした。

ミッドレンジからハイエンドのGPUで極めて高速である。これはGeForce GTX 470上で0.28msで動作し、我々の古いテストマシンではMSAAより12倍速い。

<!-- p.8 -->

また、低メモリフットプリントを持ち、容易に持ち運びできる。

<!-- p.9 -->

Alexanderがすでに言及したように、エッジ検出ステップは色、深度、インスタンスID、法線、プリミティブID、または、いずれかの組み合わせを用いるようカスタマイズできる。

これは特定のシナリオに対して最適な手法を選択することができる。

我々は、Tobiasにより後で説明されるKillzone3で使われた手法は最良のエッジ検出アプローチのひとつであるかもしれないと思っている。

# 重要なアイデア[Key Ideas]

- 単純なテクスチャを使うためにMLAAを解釈する。
- 事前計算したテクスチャを使う。
    - 動的分岐を回避する。
    - オンザフライで面積[area]を計算するのを避ける。
- 限界までバイリニアフィルタリングを活用する。
- ピクセル間で計算を共有する。(ピクセルはエッジを共有する！)
- ステンシルバッファを用いることによるマスク処理

テクニックの重要な高レベルのアイデアから始めたいと思う。

このために、この退屈なスライドについては忘れて、オリジナルのCPUベースのアプローチが行っていること、そして、各要素をよりGPUフレンドリーな形式に置き換える方法から始めよう。

# MLAAの高レベルアルゴリズム[MLAA High-Level Algorithm]

では、この画像をアンチエイリアスしたいとしよう。

<!-- p.12 -->

このために、このピクセルパターンの再ベクトル化を示す、青い線を理解しなければならない。

<!-- p.13 -->

この再ベクトル化を用いて、各ピクセルで反対の色を用いて線の下の領域を埋める。

つまり、左は黒で埋められ、右は白で埋められる。

これは、こう解釈される。

<!-- p.14 -->

現実の形状を近似する灰色レベルとして。

<!-- p.15 -->

それでは、話を戻そう。

第1ステップは、緑でマークした線である、エッジのある所を検出することである。

<!-- p.16 -->

そして、先の左終端と右終端を探さなければならない。


<!-- p.17 -->

そして、線の各側で交差するエッジを得る。

<!-- p.18 -->

手前の距離と交差するエッジで、再ベクトル化した線の下の面積を計算するのに十分な情報がある。

簡単でしょう？

# 問題[Problems]

- 終端の検索は低速である。
- 交差するエッジのフェッチはコストが高い。

ただし、その美しさは問題なしにはやってこない。

検索や交差するエッジのためにエッジをフェッチすることは、大量のメモリ帯域幅を必要とするので、低速である。

<!-- p.20 -->

- 再ベクトル化は分岐が多い[branchy]
    - 2^4 = 16通り！
- 面積計算は安価ではない。

手前の交差するエッジでさえ、可能性のあるパターン数が多ければ、再ベクトル化は自明ではない。

<!-- p.21 -->

- ピクセルあたり最大4つの線！

さらには、これらの計算をピクセルあたり最大4回、境界あたり1回繰り返さなければならない。これは非常に大きなパフォーマンス的なペナルティーを引き起こす。

では、我々はどのようにしてMLAAの品質を落とさずにこれらの問題を解決できるだろうか？

# 解決法[Solutions]

- 終端の検索は低速である。
- 交差するエッジのフェッチはコストが高い。
- 解決法: ポストプロセッシングアンチエイリアシングにバイリニアフィルタリングを導入する。
    - これは一回のアクセスで複数の値をフェッチすることができる。

MLAAの最も高価な要素である、線の終端の検索とと交差するエッジのフェッチを改善するため、ポストプロセッシングアンチエイリアシングを高速化するためにバイリニアフィルタリングを導入する。

これは一回のアクセスで複数の値をフェッチすることができる。

<!-- p.23 -->

- 再ベクトル化の計算は簡単でも高速でもない。
- 正確な面積計算は安価ではない。
- 解決法: 事前計算したテクスチャを用いることで分岐の多いコードを回避する。

再ベクトル化と面積計算を容易にするため、距離と交差するエッジを入力に線の下の面積を出力するテクスチャを作った。

これは16通りを見分けるために分岐の多いコードを変換し、面積計算を単一のテクスチャアクセスにする。

<!-- p.24 -->

- 最大4つの線がひとつのピクセルを通過する可能性がある。
- 解決法: 馬鹿な観察結果として、ピクセルはエッジを共有し、計算を繰り返さない！

4つの線がひとつのピクセルを通る可能性がある一方で、これらは近傍で共有される。

4つの線の検索の代わりに、上と左の線だけを検索する。

そして、対応する面積を計算し、一時バッファに格納する。

これはもうひとつのパスを導入することを代償にこの情報を近傍と共有することが可能になる。

# 新しい問題！[New Problem!]

- 今や3つのフルスクリーンバスを必要とする。
- 解決法: ステンシルバッファを使う！

しかし、3つのフルスクリーンパスを必要とする、という新しい問題が生まれた。

しかしながら、その解決法は簡単である。

ステンシルバッファを用いて第1パスで処理が必要なピクセルをマスクする。

# ワークフロー[Workflow]

では、高レベルのアイデアは終わりにして、我々の実装の詳細に入っていこう。

ここでは、我々のテクニックの全体像[big picture]がある。

これは3パスで構成する。

<!-- p.27 -->

第1パスでは、エッジ検出を行い、エッジテクスチャを得る。

<!-- p.28 -->

第2パスでは、各エッジを処理し、再ベクトル化を計算し、対応する面積を得る。

<!-- p.29 -->

第3およぴ最終パスでは、第2パスからの面積を用いて4近傍で各ピクセルをブレンドする。

エッジ検出ステップをスキップして、より面白い実装がある第2パスに進もうと思う。

# エッジ検出 第1パス[Edge Detection 1st Pass]

- **色**: (ITU-R勧告 BT.709)
    - $Y' = 0.2126 \cdot R' + 0.7152 \cdot G' + 0.0722 \cdot B'$
- **深度**: より安価でより明確なエッジを持つが、あらゆるオブジェクト尺度では動作しない可能性がある。
- **インスタンスID/深度＋法線**: この情報が使える場合に最適

第1パスから始めよう。

エッジ検出は最終画像のクオリティに対する重要な工程てある。

各未検出エッジは最終画像でエイリアスしたままであるので、すべての知覚できるエッジを検出することは重要である。

良好なエッジ検出は時間的な安定性を高めるとすると、このステップでのロバスト性もまた望ましい。

複数の選択肢がある。どれが最適かは特定のシナリオに強く依存するだろう。

<!-- p.31 -->

色は、常に利用可能であるため、最も普遍的でより簡単な解決法と見なされる可能性がある。

色による処理は、いくつかのシナリオでクオリティを改善する、シェーディングエイリアシングのシームレスハンドリングを追加で提供する。

欠点として、モデルに現れるテキストやその他の高周波な特徴で若干のブラーをもたらすかもしれない。

<!-- p.32 -->

幾何学的なエッジのより良い推定器であるため、深度、法線、または、オブジェクトIDも使うことができ、最大画像鮮鋭度を維持することができる。

Peteが後に示すように、すべてのオブジェクトの尺度を適切に管理することが本当に難しいので、深度のみを使うことはトリッキーである。

<!-- p.33 -->

深度およびインスタンスIDを法線と組み合わせることは、本当に明確で完璧なエッジを生み出すので、一般にとても良い結果をもたらし、画像鮮鋭度のほとんどを保存するために管理する。

しかし、エッジ検出パスは、追加の処理が必要になるとすると、より高価である。

ときどき、これらもまた色では起こらないアーティファクトを引き起こすが、これの説明はこのトークの範疇ではない。

<!-- p.34 -->

- 色バージョン

```hlsl
float4 ColorEdgeDetectionPS(float4 position : SV_POSITION, float2 texcoord : TEXCOORD0) : SV_TARGET {
    float3 weights = float3(0.2126, 0.7152, 0.0722);

    // 輝度計算はガンマ補正済みの色を必要とするので、'colorTex'はsRGBでないテクスチャとすべき。
    float L = dot(colorTex.SampleLevel(PointSampler, texcoord, 0).rgb, weights);
    float Lleft   = dot(colorTex.SampleLevel(PointSampler, texcoord, 0, -int2(1, 0)).rgb, weights);
    float Ltop    = dot(colorTex.SampleLevel(PointSampler, texcoord, 0, -int2(0, 1)).rgb, weights);
    float Lright  = dot(colorTex.SampleLevel(PointSampler, texcoord, 0,  int2(1, 0)).rgb, weights);
    float Lbottom = dot(colorTex.SampleLevel(PointSampler, texcoord, 0,  int2(0, 1)).rgb, weights);

    float4 delta = abs(L.xxxx - float4(Lleft, Ltop, Lright, Lbottom));
    float4 edges = step(threshold.xxxx, delta);

    if (dot(edges, 1.0) == 0.0)
        discard;

    return edges;
}
```

ここでは、色の入力データを用いる、エッジ検出の最も単純な形式を確認できる。

5回のメモリアクセスといくつかの算術命令を用いる。

Gather4が使えるプラットフォームでは…

<!-- p.35 -->

```hlsl
float4 ColorEdgeDetectionPS(float4 position : SV_POSITION, float2 texcoord : TEXCOORD0) : SV_TARGET {
    float3 weights = float3(0.2126, 0.7152, 0.0722);

    // 輝度計算はガンマ補正済みの色を必要とするので、'colorTex'はsRGBでないテクスチャとすべき。
    float topLeft     = lumaTex.Gather(LinearSampler, texcoord + PIXEL_SIZE * float2(-0.5, -0.5), 0);
    float bottomRight = lumaTex.Gather(LinearSampler, texcoord + PIXEL_SIZE * float2( 0.5,  0.5), 0);
    float L = topLeft.g;
    float Lleft = topLeft.r;
    float Ltop = topLeft.b;
    float Lright = bottomRight.b;
    float Lbottom = bottomRight.r;

    float4 delta = abs(L.xxxx - float4(Lleft, Ltop, Lright, Lbottom));
    float4 edges = step(threshold.xxxx, delta);

    if (dot(edges, 1.0) == 0.0)
        discard;

    return edges;
}
```

…輝度が事前計算されるとすれば、アクセス数を3回に減らし、すべての内積を取り除くことができる。

# ブレンディング重み計算 第2パス[Blending Weights Calculation 2nd Pass]

TODO

# 参考文献[References]
