---
title: >
Jimenez's MLAA & SMAA: Subpixel Morphological Anti-Aliasing
numberSections: false
---
# 重要な機能[Key Features]

- **高品質**
    - 16階調(または、それ以上！)
    - 耐ノイズ性[noise proof] → **時間的に安定**
    - 鮮鋭さ[sharpness]の保存
- **高速**
    - 720pで0.28ms (GeForce GTX 470)
    - MSAAより約1180%速い[beats MSAA by about a 1180%] (GeForce 9800 GTX+)
- **低メモリフットプリント**
    - バックバッファサイズの2倍
- **ポータブル**
- **カスタマイズ可能なエッジ検出**

テクニックの開発中に、我々はいくつかのトレードオフを決めておかなければならなかった。

<!-- p.6 -->

まずはじめに、できる限りの最高品質を達成することに最も重点を置いている。

- 16xMSAAによって生み出されるこれらを凌ぐオブジェクトの輪郭でのグラデーションを得る。
- 最新バージョンでは、更に時間的に安定であり、より良いノイズ管理を持つ。
- より良い鮮鋭さの保存となる、本当に必要な所だけに触れるので、画像に対して保守的である。

<!-- p.7 -->

高品質の次に、できる限りの最高のパフォーマンスを達成しようとした。

ミッドレンジからハイエンドのGPUで極めて高速である。これはGeForce GTX 470上で0.28msで動作し、我々の古いテストマシンではMSAAより12倍速い。

<!-- p.8 -->

また、低メモリフットプリントを持ち、容易に持ち運びできる。

<!-- p.9 -->

Alexanderがすでに言及したように、エッジ検出ステップは色、深度、インスタンスID、法線、プリミティブID、または、いずれかの組み合わせを用いるようカスタマイズできる。

これは特定のシナリオに対して最適な手法を選択することができる。

我々は、Tobiasにより後で説明されるKillzone3で使われた手法は最良のエッジ検出アプローチのひとつであるかもしれないと思っている。

# 重要なアイデア[Key Ideas]

- 単純なテクスチャを使うためにMLAAを解釈する。
- 事前計算したテクスチャを使う。
    - 動的分岐を回避する。
    - オンザフライで面積[area]を計算するのを避ける。
- 限界までバイリニアフィルタリングを活用する。
- ピクセル間で計算を共有する。(ピクセルはエッジを共有する！)
- ステンシルバッファを用いることによるマスク処理

テクニックの重要な高レベルのアイデアから始めたいと思う。

このために、この退屈なスライドについては忘れて、オリジナルのCPUベースのアプローチが行っていること、そして、各要素をよりGPUフレンドリーな形式に置き換える方法から始めよう。

# MLAAの高レベルアルゴリズム[MLAA High-Level Algorithm]

では、この画像をアンチエイリアスしたいとしよう。

<!-- p.12 -->

このために、このピクセルパターンの再ベクトル化を示す、青い線を理解しなければならない。

<!-- p.13 -->

この再ベクトル化を用いて、各ピクセルで反対の色を用いて線の下の領域を埋める。

つまり、左は黒で埋められ、右は白で埋められる。

これは、こう解釈される。

<!-- p.14 -->

現実の形状を近似する灰色レベルとして。

<!-- p.15 -->

それでは、話を戻そう。

第1ステップは、緑でマークした線である、エッジのある所を検出することである。

<!-- p.16 -->

そして、先の左終端と右終端を探さなければならない。


<!-- p.17 -->

そして、線の各側で交差するエッジを得る。

<!-- p.18 -->

手前の距離と交差するエッジで、再ベクトル化した線の下の面積を計算するのに十分な情報がある。

簡単でしょう？

# 問題[Problems]

- 終端の検索は低速である。
- 交差するエッジのフェッチはコストが高い。

ただし、その美しさは問題なしにはやってこない。

検索や交差するエッジのためにエッジをフェッチすることは、大量のメモリ帯域幅を必要とするので、低速である。

<!-- p.20 -->

- 再ベクトル化は分岐が多い[branchy]
    - 2^4 = 16通り！
- 面積計算は安価ではない。

手前の交差するエッジでさえ、可能性のあるパターン数が多ければ、再ベクトル化は自明ではない。

<!-- p.21 -->

- ピクセルあたり最大4つの線！

さらには、これらの計算をピクセルあたり最大4回、境界あたり1回繰り返さなければならない。これは非常に大きなパフォーマンス的なペナルティーを引き起こす。

では、我々はどのようにしてMLAAの品質を落とさずにこれらの問題を解決できるだろうか？

# 解決法[Solutions]

- 終端の検索は低速である。
- 交差するエッジのフェッチはコストが高い。
- 解決法: ポストプロセッシングアンチエイリアシングにバイリニアフィルタリングを導入する。
    - これは一回のアクセスで複数の値をフェッチすることができる。

MLAAの最も高価な要素である、線の終端の検索とと交差するエッジのフェッチを改善するため、ポストプロセッシングアンチエイリアシングを高速化するためにバイリニアフィルタリングを導入する。

これは一回のアクセスで複数の値をフェッチすることができる。

<!-- p.23 -->

- 再ベクトル化の計算は簡単でも高速でもない。
- 正確な面積計算は安価ではない。
- 解決法: 事前計算したテクスチャを用いることで分岐の多いコードを回避する。

再ベクトル化と面積計算を容易にするため、距離と交差するエッジを入力に線の下の面積を出力するテクスチャを作った。

これは16通りを見分けるために分岐の多いコードを変換し、面積計算を単一のテクスチャアクセスにする。

<!-- p.24 -->

- 最大4つの線がひとつのピクセルを通過する可能性がある。
- 解決法: 馬鹿な観察結果として、ピクセルはエッジを共有し、計算を繰り返さない！

4つの線がひとつのピクセルを通る可能性がある一方で、これらは近傍で共有される。

4つの線の検索の代わりに、上と左の線だけを検索する。

そして、対応する面積を計算し、一時バッファに格納する。

これはもうひとつのパスを導入することを代償にこの情報を近傍と共有することが可能になる。

# 新しい問題！[New Problem!]

TODO

# 参考文献[References]
