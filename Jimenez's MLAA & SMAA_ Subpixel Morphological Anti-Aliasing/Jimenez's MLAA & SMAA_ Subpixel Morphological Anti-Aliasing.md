---
title: >
Jimenez's MLAA & SMAA: Subpixel Morphological Anti-Aliasing
numberSections: false
---
# 重要な機能[Key Features]

- **高品質**
    - 16階調(または、それ以上！)
    - 耐ノイズ性[noise proof] → **時間的に安定**
    - 鮮鋭さ[sharpness]の保存
- **高速**
    - 720pで0.28ms (GeForce GTX 470)
    - MSAAより約1180%速い[beats MSAA by about a 1180%] (GeForce 9800 GTX+)
- **低メモリフットプリント**
    - バックバッファサイズの2倍
- **ポータブル**
- **カスタマイズ可能なエッジ検出**

テクニックの開発中に、我々はいくつかのトレードオフを決めておかなければならなかった。

<!-- p.6 -->

まずはじめに、できる限りの最高品質を達成することに最も重点を置いている。

- 16xMSAAによって生み出されるこれらを凌ぐオブジェクトの輪郭でのグラデーションを得る。
- 最新バージョンでは、更に時間的に安定であり、より良いノイズ管理を持つ。
- より良い鮮鋭さの保存となる、本当に必要な所だけに触れるので、画像に対して保守的である。

<!-- p.7 -->

高品質の次に、できる限りの最高のパフォーマンスを達成しようとした。

ミッドレンジからハイエンドのGPUで極めて高速である。これはGeForce GTX 470上で0.28msで動作し、我々の古いテストマシンではMSAAより12倍速い。

<!-- p.8 -->

また、低メモリフットプリントを持ち、容易に持ち運びできる。

<!-- p.9 -->

Alexanderがすでに言及したように、エッジ検出ステップは色、深度、インスタンスID、法線、プリミティブID、または、いずれかの組み合わせを用いるようカスタマイズできる。

これは特定のシナリオに対して最適な手法を選択することができる。

我々は、Tobiasにより後で説明されるKillzone3で使われた手法は最良のエッジ検出アプローチのひとつであるかもしれないと思っている。

# 重要なアイデア[Key Ideas]

- 単純なテクスチャを使うためにMLAAを解釈する。
- 事前計算したテクスチャを使う。
    - 動的分岐を回避する。
    - オンザフライで面積[area]を計算するのを避ける。
- 限界までバイリニアフィルタリングを活用する。
- ピクセル間で計算を共有する。(ピクセルはエッジを共有する！)
- ステンシルバッファを用いることによるマスク処理

テクニックの重要な高レベルのアイデアから始めたいと思う。

このために、この退屈なスライドについては忘れて、オリジナルのCPUベースのアプローチが行っていること、そして、各要素をよりGPUフレンドリーな形式に置き換える方法から始めよう。

# MLAAの高レベルアルゴリズム[MLAA High-Level Algorithm]

では、この画像をアンチエイリアスしたいとしよう。

<!-- p.12 -->

このために、このピクセルパターンの再ベクトル化を示す、青い線を理解しなければならない。

<!-- p.13 -->

この再ベクトル化を用いて、各ピクセルで反対の色を用いて線の下の領域を埋める。

つまり、左は黒で埋められ、右は白で埋められる。

これは、こう解釈される。

<!-- p.14 -->

現実の形状を近似する灰色レベルとして。

<!-- p.15 -->

それでは、話を戻そう。

第1ステップは、緑でマークした線である、エッジのある所を検出することである。

<!-- p.16 -->

そして、先の左終端と右終端を探さなければならない。


<!-- p.17 -->

そして、線の各側で交差するエッジを得る。

<!-- p.18 -->

手前の距離と交差するエッジで、再ベクトル化した線の下の面積を計算するのに十分な情報がある。

簡単でしょう？

# 問題[Problems]

- 終端の検索は低速である。
- 交差するエッジのフェッチはコストが高い。

ただし、その美しさは問題なしにはやってこない。

検索や交差するエッジのためにエッジをフェッチすることは、大量のメモリ帯域幅を必要とするので、低速である。

<!-- p.20 -->

- 再ベクトル化は分岐が多い[branchy]
    - 2^4 = 16通り！
- 面積計算は安価ではない。

手前の交差するエッジでさえ、可能性のあるパターン数が多ければ、再ベクトル化は自明ではない。

<!-- p.21 -->

- ピクセルあたり最大4つの線！

さらには、これらの計算をピクセルあたり最大4回、境界あたり1回繰り返さなければならない。これは非常に大きなパフォーマンス的なペナルティーを引き起こす。

では、我々はどのようにしてMLAAの品質を落とさずにこれらの問題を解決できるだろうか？

# 解決法[Solutions]

- 終端の検索は低速である。
- 交差するエッジのフェッチはコストが高い。
- 解決法: ポストプロセッシングアンチエイリアシングにバイリニアフィルタリングを導入する。
    - これは一回のアクセスで複数の値をフェッチすることができる。

MLAAの最も高価な要素である、線の終端の検索とと交差するエッジのフェッチを改善するため、ポストプロセッシングアンチエイリアシングを高速化するためにバイリニアフィルタリングを導入する。

これは一回のアクセスで複数の値をフェッチすることができる。

<!-- p.23 -->

- 再ベクトル化の計算は簡単でも高速でもない。
- 正確な面積計算は安価ではない。
- 解決法: 事前計算したテクスチャを用いることで分岐の多いコードを回避する。

再ベクトル化と面積計算を容易にするため、距離と交差するエッジを入力に線の下の面積を出力するテクスチャを作った。

これは16通りを見分けるために分岐の多いコードを変換し、面積計算を単一のテクスチャアクセスにする。

<!-- p.24 -->

- 最大4つの線がひとつのピクセルを通過する可能性がある。
- 解決法: 馬鹿な観察結果として、ピクセルはエッジを共有し、計算を繰り返さない！

4つの線がひとつのピクセルを通る可能性がある一方で、これらは近傍で共有される。

4つの線の検索の代わりに、上と左の線だけを検索する。

そして、対応する面積を計算し、一時バッファに格納する。

これはもうひとつのパスを導入することを代償にこの情報を近傍と共有することが可能になる。

# 新しい問題！[New Problem!]

- 今や3つのフルスクリーンバスを必要とする。
- 解決法: ステンシルバッファを使う！

しかし、3つのフルスクリーンパスを必要とする、という新しい問題が生まれた。

しかしながら、その解決法は簡単である。

ステンシルバッファを用いて第1パスで処理が必要なピクセルをマスクする。

# ワークフロー[Workflow]

では、高レベルのアイデアは終わりにして、我々の実装の詳細に入っていこう。

ここでは、我々のテクニックの全体像[big picture]がある。

これは3パスで構成する。

<!-- p.27 -->

第1パスでは、エッジ検出を行い、エッジテクスチャを得る。

<!-- p.28 -->

第2パスでは、各エッジを処理し、再ベクトル化を計算し、対応する面積を得る。

<!-- p.29 -->

第3およぴ最終パスでは、第2パスからの面積を用いて4近傍で各ピクセルをブレンドする。

エッジ検出ステップをスキップして、より面白い実装がある第2パスに進もうと思う。

# エッジ検出 第1パス[Edge Detection 1st Pass]

- **色**: (ITU-R勧告 BT.709)
    - $Y' = 0.2126 \cdot R' + 0.7152 \cdot G' + 0.0722 \cdot B'$
- **深度**: より安価でより明確なエッジを持つが、あらゆるオブジェクト尺度では動作しない可能性がある。
- **インスタンスID/深度＋法線**: この情報が使える場合に最適

第1パスから始めよう。

エッジ検出は最終画像のクオリティに対する重要な工程てある。

各未検出エッジは最終画像でエイリアスしたままであるので、すべての知覚できるエッジを検出することは重要である。

良好なエッジ検出は時間的な安定性を高めるとすると、このステップでのロバスト性もまた望ましい。

複数の選択肢がある。どれが最適かは特定のシナリオに強く依存するだろう。

<!-- p.31 -->

色は、常に利用可能であるため、最も普遍的でより簡単な解決法と見なされる可能性がある。

色による処理は、いくつかのシナリオでクオリティを改善する、シェーディングエイリアシングのシームレスハンドリングを追加で提供する。

欠点として、モデルに現れるテキストやその他の高周波な特徴で若干のブラーをもたらすかもしれない。

<!-- p.32 -->

幾何学的なエッジのより良い推定器であるため、深度、法線、または、オブジェクトIDも使うことができ、最大画像鮮鋭度を維持することができる。

Peteが後に示すように、すべてのオブジェクトの尺度を適切に管理することが本当に難しいので、深度のみを使うことはトリッキーである。

<!-- p.33 -->

深度およびインスタンスIDを法線と組み合わせることは、本当に明確で完璧なエッジを生み出すので、一般にとても良い結果をもたらし、画像鮮鋭度のほとんどを保存するために管理する。

しかし、エッジ検出パスは、追加の処理が必要になるとすると、より高価である。

ときどき、これらもまた色では起こらないアーティファクトを引き起こすが、これの説明はこのトークの範疇ではない。

<!-- p.34 -->

- 色バージョン

```hlsl
float4 ColorEdgeDetectionPS(float4 position : SV_POSITION, float2 texcoord : TEXCOORD0) : SV_TARGET {
    float3 weights = float3(0.2126, 0.7152, 0.0722);

    // 輝度計算はガンマ補正済みの色を必要とするので、'colorTex'はsRGBでないテクスチャとすべき。
    float L = dot(colorTex.SampleLevel(PointSampler, texcoord, 0).rgb, weights);
    float Lleft   = dot(colorTex.SampleLevel(PointSampler, texcoord, 0, -int2(1, 0)).rgb, weights);
    float Ltop    = dot(colorTex.SampleLevel(PointSampler, texcoord, 0, -int2(0, 1)).rgb, weights);
    float Lright  = dot(colorTex.SampleLevel(PointSampler, texcoord, 0,  int2(1, 0)).rgb, weights);
    float Lbottom = dot(colorTex.SampleLevel(PointSampler, texcoord, 0,  int2(0, 1)).rgb, weights);

    float4 delta = abs(L.xxxx - float4(Lleft, Ltop, Lright, Lbottom));
    float4 edges = step(threshold.xxxx, delta);

    if (dot(edges, 1.0) == 0.0)
        discard;

    return edges;
}
```

ここでは、色の入力データを用いる、エッジ検出の最も単純な形式を確認できる。

5回のメモリアクセスといくつかの算術命令を用いる。

Gather4が使えるプラットフォームでは…

<!-- p.35 -->

```hlsl
float4 ColorEdgeDetectionPS(float4 position : SV_POSITION, float2 texcoord : TEXCOORD0) : SV_TARGET {
    float3 weights = float3(0.2126, 0.7152, 0.0722);

    // 輝度計算はガンマ補正済みの色を必要とするので、'colorTex'はsRGBでないテクスチャとすべき。
    float topLeft     = lumaTex.Gather(LinearSampler, texcoord + PIXEL_SIZE * float2(-0.5, -0.5), 0);
    float bottomRight = lumaTex.Gather(LinearSampler, texcoord + PIXEL_SIZE * float2( 0.5,  0.5), 0);
    float L = topLeft.g;
    float Lleft = topLeft.r;
    float Ltop = topLeft.b;
    float Lright = bottomRight.b;
    float Lbottom = bottomRight.r;

    float4 delta = abs(L.xxxx - float4(Lleft, Ltop, Lright, Lbottom));
    float4 edges = step(threshold.xxxx, delta);

    if (dot(edges, 1.0) == 0.0)
        discard;

    return edges;
}
```

…輝度が事前計算されるとすれば、アクセス数を3回に減らし、すべての内積を取り除くことができる。

# ブレンディング重み計算 第2パス[Blending Weights Calculation 2nd Pass]

- 3つの部分で構成する。
    - 現在の線の終端への距離$d_{left}$と$d_{right}$を検索する。
    - 交差するエッジ$e_{left}$と$e_{right}$をフェッチする。
    - $d$と$e$を用いて、このピクセルのカパレッジ$a$を計算する。

この第2パスでは、再ベクトル化した線の下の面積を計算したい。

このパスでは、線の終端を検索し、交差するエッジをフェッチし、このピクセルのカバレッジ面積を計算するためにこの情報を使わなければならない。

# 距離の検索[Searching for Distances]

- バイリニアフィルタリングを利用することで行われる。

終端の検索はメモリ集約的なタスクである。

帯域幅の使用率を改善するため、バイリニアフィルタリングがほとんどのプラットフォームでタダであるという事実を活用する。

この画像には、エッジバッファの値を表す点の色と一緒に、青でマークしたエッジがある。

So starting from here, we are going to jump two pixels at time, between them...

<!-- p.38 -->

このひし形[rhombus]は最初のフェッチを表す。

バイリニアフィルタリングは1を返すので、両ピクセルにはエッジがある。

<!-- p.39 -->

ここも同じ…

<!-- p.40 -->

このフェッチでは、エッジの片方が有効でないことを意味する0.5を得るので、検索が終了した。

この方法でバイリニアフィルタリングを用いることにより、検索を2倍に高速化することができるので、パフォーマンスが低下しない本当に長い距離の検索に到達することが可能になる。

<!-- p.41 -->

- 検索のコード例

```hlsl
float SearchXLeft(float2 texcoord) {
    texcoord -= float2(1.5, 0.0) * PIXEL_SIZE;
    float e = 0.0;

    // エッジ間をサンプルするために0.5だけオフセットする。すなわち、横一列の2つをフェッチする。
    for (int i = 0; i < maxSearchSteps; i++) {
        e = edgesTex.SampleLevel(LinearSampler, texcoord, 0).g;

        // バイリニアのアクセス精度の問題を軽減するために0.9と比較する。
        [flatten] if (e < 0.9) break;
        texcoord -= float2(2.0, 0.0) * PIXEL_SIZE;
    }

    // 終端を見つけられずにループを脱出した場合、-2 * maxSearchStepsを返したい。
    return max(-2.0 * i - 2.0 * e, -2.0 * maxSearchSteps);
}
```

ここには、左への検索を扱う単純なコードがある。

どのように一度に2つのピクセルを飛び越えるか、

そして、どのようにフェッチが1でない何か他の値を返すときにストップするか、を確認できる。

# 交差するエッジのフェッチ[Fetching crossing edges]

線の終端への距離が分かったら、それを使って交差するエッジを得る。

交差するエッジをフェッチするナイーブなアプローチは4つのエッジのクエリを暗に示すだろう。

<!-- p.43 -->

- 再び、バイリニアフィルタリングを利用することで行われる。

代わりに、より効率的なアプローチは、距離の検索と同様に、一度に両方のエッジをフェッチするのにバイリニアフィルタリングを使うことである。

だが、少し問題がある。

戻り値が0.5のとき、この場合を扱うのか、または、もう一方の場合を扱うのか？

<!-- p.44 -->

- 解決法: 座標をオフセットする！

その解決法はクエリを0.25だけオフセットすることである。これは、それぞれの場合で戻り値が異なるので、これらを区別することが可能となる。

# カバレッジの計算[Calculating the coverage]

- 以下を回避するために事前計算したテクスチャを使う。
    - 動的分岐
    - 高価な面積計算

カバレッジ計算での重要な貢献は、16の異なるパターンを扱う代わりに、分岐コードを回避する4Dテクスチャでこれらを事前計算することである。

<!-- p.46 -->

このテクスキャへのアクセスは次のようになる。

まず、パターンのタイプまたはブロックが選択される…

<!-- p.47 -->

…交差するエッジ情報を用いることで。

<!-- p.48 -->

そして、線の終端への距離を用いることで適切な面積が選択される。

<!-- p.49 -->

なぜ事前計算した面積テクスチャが2チャンネルを持つか、を考えているかもしれない。

答えはかなり簡単で、2チャンネルあると、ブレンド方向の曖昧さをなくすことが可能になるためである。

赤の値は下のピクセルを上のものとブレンドすることを意味する。

一方、緑の値はその逆である。

# 面積テクスチャの利点[Area Texture Advantages]

- 対称的なパターンの扱い
- 非対称な再ベクトル化　→　パターンの微調整

事前計算した面積も用いることには複数の利点がある。

そこには、すべてのパターンが同じ方法で扱われる、すなわち、単純なテクスチャアクセスであるという事実を含む。

一方で、テクスチャそれ自体がカスタマイズできるので、あるパターンを微調整することができる。

<!-- p.51 -->

これらの再ベクトル化は通常アーティファクトをもたらすので、これらのパターンをフィルタリングするのを回避する。

その他の再ベクトル化をカスタマイズして、単純なZパターンとして扱った。

この微調整は、必要に応じて高品質なアンチエイリアシングを提供しつつ、できる限り綺麗なままの画像を維持するのに役立つ。

# ブレンディング重み計算 第2パス[Blending Weights Calculation 2nd Pass]

- シェーダコード(I)

```hlsl
float4 BlendingWeightCalculationPS(float4 position : SV_POSITION, float2 texcoord : TEXCOORD0) : SV_TARGET {
    float4 weights = 0.0;

    float2 e = edgesTex.SmapleLevel(PointSampler, texcoord, 0).rg;

    [branch]
    if (e.g) {  // 北のエッジ
        // 左と右への距離を検索する。
        float2 d = float2(SearchXLeft(texcoord), SearchXRight(texcoord));

        // 交差するエッジをフェッチする。edgel^[edge + pixel?]の間をサンプルする代わりに、どの値がそれぞれのedgelを持つかを見分けられるように、-0.25の地点をサンプルする。
        float4 coords = mad(float4(d.x, -0.25, d.y + 1.0, -0.25), PIXEL_SIZE.xyxy, texcoord.xyxy);
        float e1 = edgesTex.SampleLevel(LinearSampler, coords.xy, 0).r;
        float e2 = edgesTex.SampleLevel(LinearSampler, coords.zw, 0).r;

        // このパターンがどう見えているかが分かったので、今や実際の面積を得る時である。
        weights.rg = Area(abs(d), e1, e2);
    }
```

ここには、パス全体のコードがある。

まず、線の終端を検索して、

そして、交差するエッジをフェッチして、

最後に、カバレッジ面積を求める。

<!-- p.53 -->

- シェーダコード(II)

```hlsl
    [branch]
    if (e.r) {  // 西のエッジ
        // 上と下への距離を検索する。
        float2 d = float2(SearchYUp(texcoord), SearchYDown(texcoord));

        // (またまた)交差するエッジをフェッチする。
        float4 coords = mad(float4(-0.25, d.x, -0.25, d.y + 1.0), PIXEL_SIZE.xyxy, texcoord.xyxy);
        float e1 = edgesTex.SampleLevel(LinearSampler, coords.xy, 0).g;
        float e2 = edgesTex.SampleLevel(LinearSampler, coords.zw, 0).g;

        // この方向の面積を得る。
        weights.ba = Area(abs(d), e1, e2);
    }

    return wieghts;
}
```

これは、見ての通り、かなり似通った垂直のケースのコードを示す。

# 近傍ブレンディング 第3パス[Neighborhood Blending 3rd Pass]

- 前のパスで計算した面積を用いて近傍をブレンドする。

$$
c_{new} = (1 - a) \cdot c_{old} + a \cdot c_{opp}
$$

TODO

# 参考文献[References]
