---
title: >
    Volumetric Fog: Unified compute shader based solution to atmospheric scattering [@Wronski2014]
---
# SIGGRAPH 2014

# Volumetric Fog: Unified compute shader based solution to atmospheric scattering

# プレゼンテーションの概要

- 大気散乱[atmospheric scattering]のイントロダクション
- 既存のゲームの解法
- アルゴリズムの概要
- 実装の詳細
- …Assasin's Creed 4の先へ

# 大気散乱

- 空の色
- フォグ
- 雲
- "ゴッドレイ"
- ライトシャフト
- ボリューメトリックシャドウ

# ゲームにおける大気散乱

- 現実感のあるレンダリングのために必要とされる
- 距離差を知覚するのに役立つ
- LODやストリーミングを隠すのに役立つ
- 雰囲気[mood]や大気を作る
- "特殊な"効果のために使われるアートの道具

# 大気散乱

大気散乱の現象はいずれかの輸送媒質[transporting media]を形成する粒子[particles]とフォトンの相互作用によって引き起こされる。光がいずれかの空でない媒質を横断する[traverse]とき、フォトンまたは光線[light rays]はそのような媒質を作り出す粒子と衝突するかもしれない。衝突では、これらは衝突して拡散[diffuse]か吸収[absorb]かのいずれかが行われるかもしれない(そして、熱エネルギーに変換される)。光学において、そのような処理は通常では統計的にモデル化され、我々は以下の処理に加わるエネルギー量を定義することができる。

- 透過[transmission]
- 散乱
- 吸収[absorbtion]

エネルギーは常に保存されるので、我々は以下と記述することができる。

$$
L_{\text{incoming}} = L_{\text{transmitted}} + L_{\text{absorbed}} + L_{\text{scattered}}
$$

# 散乱なし

光散乱なし/非関与輸送媒質[non-participating transport media]

我々は輸送媒質が真空のように振る舞うと仮定する --- オブジェクト間の光路上で放射輝度の損失および利得はない。
典型的なレンダリングシナリオ --- 光源からの光が一方のオブジェクトからもう一方へ表面のBRDF関数に従ってバウンスして、最終的にカメラ/目に到達する。
最も単純なあり得るケースはバウンスする光/GIがない、単なる直接ライティングである。

# 光の散乱

媒質が光輸送に関与するとき、フォトン/光線に影響を与えるのに十分なほど大きいすべての粒子は光輸送の等式に加えられる。
例えば、塵や水の粒子は光線/フォトンを無作為な方向にバウンスさせ、いくつかの光を光路に侵入させる(in-scattering)。
また、その一方で、いくつかの光はバウンスして脱出するので、光路を外れ、より暗くなる(out-scattering)。

一目瞭然だが、現実では、すべての粒子が位相関数[phase functions]に従っていくつかの光に対してout-scatterおよびin-scatterの両方を行うので、これらは非常に複雑である。つまり、複数のレイが光路を何回も出たり入ったりする。しかし、通常、リアルタイムレンダリングでは、複数散乱[multiple scattering]を無視しなければならない。

# Beer-Lambertの法則

光の散乱の計算に非常に有用である物理法則は入射光の消散[extinction]\(光のout-scattering)を説明するBeer-Lambertの法則である。この法則は透過率(与えられる方向からの入射光に対する媒質を通って輸送される光の割合)の値を定義する。通常では以下のように定義される。

$$
T(A \to B) = e^{-\int_A^B \beta e(x) dx}
$$

記号$\beta e$は消散係数であり、散乱係数と吸収係数の合計として定義される。我々は、光の消散が与えられる媒質における光によって伝わる[travelled]距離の指数関数である、ということをBeer-Lambertの法則から確認できる。

# 異なる散乱の種類

媒質の粒子に依存して、これらの処理に加えられる光の量は異なり得る。散乱モデルの例のひとつはRayleigh散乱である。これは(空気の粒子のような)非常に小さな粒子の散乱であり、空の青色の原因である[responsible for]。これは非常に等方的で一様であるが、波長依存である --- 散乱は波長が短いほど強く、吸収は無視できる。

一方で、(エアロゾルや塵のような)より大きな粒子のいわゆるMie散乱は強力な前向きのローブ[strong forward lobe]を伴う非常に異方的な形状やさらにより高い吸収率を持つ。

# 位相関数

方向$T(\alpha)$に散乱する光

エネルギー保存
$$
\int_0^{2\pi} \int_0^\pi P(\theta) d\theta d\varphi = 1
$$

位相関数は非常に複雑になり得る
例:雲の位相関数
情報源: Bouthors et al. "Real-time realistic illumination and shading of stratiform clouds"

位相関数はすべての方向における光の散乱量を説明する関数である。
これは光ベクトルと出射方向ベクトルとのなす角の関数である。
これはエネルギー保存の特性を持つ。つまり、すべての方向の積分は1と等しく(、または、そこに焼き込まれた吸収に関する情報を含む場合は1以下となら)なければならない。
いくつかの位相関数は非常に複雑であり、様々なモデルや現実のキャプチャされたデータから説明される可能性がある。

# 解析的位相関数

**Henyey-Greensteinの位相関数**

- 可変の異方性ファクタ
- 解析的ライトに対する小さな計算コスト(ほとんど事前計算される)
- 球面調和関数への自明な拡張
- Zonal Spherical Harmonics $(1, g, g^2, g^3)$

$$
p(\theta) = \frac{1}{4\pi} \frac{1 - g^2}{[1 + g^2 - 2g\cos\theta]^{3/2}}
$$

Mieのような異方的な散乱をシミュレートする最も一般的な位相関数はHenyey-Greensteinの位相関数である。これは数々の利点を持つ --- 実行時に計算するのが効率的であり、球面調和関数へ自明に拡張し、可変の異方性ファクタをサポートする。
いくつかのより複雑な位相関数は複数のHenyey-Greensteinの位相関数の加重和[weighted sum]から構築できる。

# 散乱の異方性

# ゲームでの近似

- 解析解(単純な媒質密度関数)
- ビルボード/パーティクルベース

ゲームでは、異なる大気および散乱現象は多くのアプローチを用いて近似された。
90年代以降に使われた最初のものと初期のOpenGL仕様は解析解である。最初の近似は非常に単純な深度ベースのフォグを使った。
前世代のコンソールでのフォグレンダリングの最新技術は解析的で指数関数的な距離ベースのフォグであった。これは"Real-time atmospheric effects in games revisited"のプレゼンテーションにおいてWenzelが非常に上手く説明してくれた。これは現実の散乱現象に基づいており、それに対する解析解をもたらす --- ただし、残念ながら、変化する媒質密度とシャドウイングを扱わない。

第二の、恐らく最も使いやすい(それほどプログラマのサポートを必要としない)ものは、(カメラとの交差でのフェードアウトを伴う)アーティストが制作した、カメラの正面を向くビルボードまたはパーティクルである。このアプローチは、アーティスト依存であり、セットアップするのが退屈であり、堅牢でなく(例えば、時刻変化[time of day]があるとき、ある角度では回転が"誤っている"ように見え得る)、十分に動的でない(ライティングやシャドウイングにおける変化に適切に反応しない)、という明確な欠点を持つ。

# ゲームでの近似

- ポストエフェクトベース
- レイマーチング

UE3やCryEngineのために人気を得た第三のアプローチはポストエフェクトであり、放射ブラーベースのスクリーンスペースエフェクトである。これは非常に効果的に見える可能性があるが、残念ながら、光源がスクリーン上に見えないときに完全に消失する。

最後に、レイマーチングの解法がある。これらは(特にepipolarサンプリングの拡張機能[extension]付きで)非常に上手く機能するが、通常は、極短距離用であり、制限を持つ --- 次のスライド。

# なぜ2Dレイマーチングでは駄目なのか？

- 通常、物理ベースではない
- ループはGPUの並列性を十分に用いない[poorly uses]
    - サンプルは、並列にではなく、順次に[sequentially]計算される
- epipolarサンプリングのような解法は制約を受ける
    - 変化する媒質密度を持てない
    - 複数の光源を持てない
- フォワードシェーディングと互換性がない
    - エフェクトの単一層、情報は1つの深度に対して格納される
    - 低解像度でのエッジのアーティファクト

レイマーチングのボリューメトリックシャドウは、複数の他のタイトルで使われ、最も大きなビジュアル上の改善をもたらし得ることから、最もモダンな解法のように思えた。しかしながら、我々は通常の2Dレイマーチングのいくつかの制限に気付いた。

- これらの実装のほとんどは近距離[close range]の"ボリューメトリックシャドウ"/"ライトシャフト"のためのものであり、本物の物理ベースではなく、長距離のフォグをサポートするのには適さない。これらは単にアーティスト固有のブレンディングモードをしばしば用いる。
- これらは、モダンなGPUでは逆効果の[counter-productive]、ループで操作する。特に何千ものthread wavesを起動できるAMDのGCNのようなモダンなアーキテクチャでは、GPUパワーの大きな無駄である。これは通常、高解像度のシャドウマップから情報をフェッチするということであり、ここではレイテンシの隠蔽が利益をもたらす可能性がある。
- epipolarサンプリングのような最近人気を得ているいくつかの賢い最適化は、媒質密度を変化させられない、複数の光源を扱えない、といった多くの制約/制限の下で機能する。すべての異なる光源は　異なるepipolarサンプリングスキームを必要とする。
- 最後に、すべての最新の実装はポストエフェクトとして設計され、透明物[transparencies]やパーティクルのようなフォーワードシェーディングされるオブジェクトを適切に扱わなかった。
- すべてのモダンなレイマーチング実装はより低解像度で機能する。通常、信号は低周波であり、平坦な表面では大きな問題にならないが、回避し辛いアンダーサンプリング、エイリアシング、エッジのアーティファクトを生み出す。

# インスピレーション

Kaplanyan, "*Light Propagation Volumes*", SIGGRAPH 2009

数々の"典型的"な技術のプロトタイピングの後、我々の最も大きなインスピレーションはSIGGRAPH 2009にて提示されたAnton Kaplanyanによる"Light Propagation Volumes"のGI技術に由来する。
技術のまとめと今後の研究の章で、著者は関与媒質の光輸送を計算するためにlit volumetric texture --- GIをシミュレートするための注入[injecting]と伝播[propagating]の結果 --- を使うことに言及している。
これは、光源の数に依存せずにレイマーチングを1回だけ行えば良い、という利点を持つ。関与媒質中の光輸送全体は統一できる。我々は、単純なシャドウイング項を追加すれば、シャドウイングを計算するコストだけでライトシャフト/ゴッドレイを生み出せるだろうと考えた。
我々はこの方針に従うことを決めた。

# ボリューメトリックフォグ

このレイマーチングの解法と合わせたインスピレーションは我々が"ボリューメトリックフォグ[Volumetric Fog]"と呼ぶ新しい解法の開発へと我々を導いた。

#

映像

#

映像

複数の光源で、一貫して、正しく、かつ、完全に機能している。

# アルゴリズムの概要

# アルゴリズムの概要

- 中間ストレージとしてのボリューメトリックテクスチャ
- 効率的にレイマーチおよび書き込みを行うためにコンピュートシェーダおよびUAVを使う

パスを効率的に分割し、個別にそれらを起動することを可能にするため、中間的かつ部分的な結果に対するストレージとしてボリューメトリックテクスチャを使った。
我々は効率的かつ非常に便利な方法でボリューメトリックデータを書き込むためにコンピュートシェーダと3DテクスチャUAVを用いた。

# アルゴリズムの概要

- 典型的な散乱の工程を分割する
    - 関与媒質の密度推定
    - in-scatterされるライティングの計算
    - レイマーチング
    - エフェクトの適用

我々のアルゴリズムの鍵となるアイデアはレイマーチングアルゴリズムの典型的な工程を分離して並列化し、それらを個々に起動することである。
この方法で、我々は個々にアルゴリズムのすべての要素のスワップおよび調整の並列性や可能性を達成する。

# アルゴリズムの概要

密度推定　　　　←直列/並列に組み合わせられる/実行される →　ライティング計算
⬇　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　⬇
3Dテクスチャ 　　　　　　　　　　　　　　　　　　　　　　　　3Dテクスチャ
↓　　　　　　　　　　　　　　　　　　　　　　　　　　　　　↙
レイマーチング←ーーーーーーーーーーーーーーーーーーーーー
⬇
3Dテクスチャ
↓
フォーワード/ディファードで適用する
⬇
シェーディングされたオブジェクト

我々は複数パスによるアルゴリズムの分割方法をこの図で確認できる。

1. 最初で最も重要な部分はすべてのボリューメトリックセルに対してライティングおよびシャドウイング計算を行うことである。
2. 並列(同じパス、または、並列パス)、または、直列に、関与物質の密度を推定しアニメーションした。
3. ボリュームテクスチャに格納したこの情報を用いて、ボリュームを通して2Dレイマーチングを行い、ボリュームスライスに結果を格納した。
4. そして、最後に、ピクセルシェーダを用いて、フォーワードまたはディファードシェーディングされるオブジェクトに対してスクリーン上で情報を適用した。

# ボリュームテクスチャレイアウト

視錐台→

デバイス座標X
デバイス座標Y
指数関数的な深度分布

16ビットfloat RGBA
160x90x64
160x90x128

我々のボリューメトリックフォグの中間ストレージはどのように見えるか？

まず、我々は最も単純なデータレイアウトを試した --- ワールド空間座標に並行な直方体[cuboid]。これは複数の利点をもたらした --- 例えば、非常に簡単なテンポラルフィルタリングは、そのようなボリュームを通したレイマーチングは複数のサンプルを必要としたのだが、低速でありエイリアシングアーティファクトを生み出した。

代わりに、我々はカメラ錐台に並行なレイアウトを用いることを決めた。我々は幅と高さに正規化済みデバイス座標[normalized device coordinates]を用いる直方体に錐台を直接対応させ、深度スライスには、指数関数的な深度分布を用いる。
我々は様々な深度分布を試し、最終的にカメラ近くに集中したものとなった --- これは最も精度を必要とし、エイリアシングアーティファクトが簡単に現れる所である。
テクスチャを視錐台に並行とすることはテンポラルエイリアシングやフリッカリングが起こりがちになるというようないくつかの欠点を持つが、レイマーチングは深度スライスを通した単なる並列スキャンである。
我々はプラットフォームに依存する160x90x64か160x90x128の大きさのボリュームを用いた。これはほぼすべてのパスの固定コストをもたらし、スクリーン解像度に依存しない。
160x90x64レイアウトでは、テクセル数は720pのサーフェスにおけるテクセル数と等しい --- だが、すべてのセルに対して、一度だけライティング計算を行う。
エフェクトの範囲はアーティストが定義した設定に依存するが、50から128メートルの間の距離をあける --- 長い距離フォグを現世代のアートディレクションと矛盾しないように保つため --- しかし、より長距離のフォグを行うことができないであろう理由はない(指数関数的な深度分布かカスケードされたアプローチを用いて)。

#

このボリューメトリックテクスチャ解像度は十分か？

# ボリューメトリック解像度 --- 低すぎる？

- 視線[view ray]全体に対して情報を格納する
- かつ、それに沿ったすべての深度に対して --- tex3Dフィルタリング
- すべての1080pピクセルは適した情報を得る
- エッジアーティファクトなし！
- 欠点 --- ソフトな結果

ボリュームテクスチャの解像度は極めて低いように見えるかもしれないが、これで十分である。

1. レイに沿って格納されるすべての深度に対して低周波の情報を格納する。
2. エフェクトを適用するとき、ボリューメトリックデータにquadrilinearフィルタリングを用いるという事から、ボリュームテクスチャの1つのテクセルを見ることは不可能である。
3. すべての対象のピクセルはネイティブ解像度から適切で精細な深度に関する情報を受け取る。
4. perspective correctionやボリューム形状は情報が正しく分布されることを確実にする。
5. 深度の不連続性におけるエッジアーティファクトを得ない(次のスライドで説明される)。

明らかに、生み出されるエフェクトは非常にソフトであり、高周波のジオメトリ詳細を損なうが、これは我々のアートディレクションにフィットしており、現実にかなり似ている(現実の大気では、複数散乱エフェクトが起こり、ライトシャフトの見た目を十分にソフトにするため)。

シーン深度に頼らない最後の利点はシャドウが準備され次第通常のシーンレンダリングと並行してこのパスを計算する可能性である --- 例えば、コンソールAPIやMantleでのAMDハードウェア上の非同期コンピュートを用いて。

# 2Dアプローチ --- エッジアーティファクト

通常の2D低解像度レンダリングを用いるとき、主な問題はエッジの不連続性に関する挙動である。低解像度のポストエフェクト計算に対して、我々は多くの取り得る深度フラグメントからある特定の深度を選び出さなければならない --- こうして、いくつかの最終的にシェーディングされるフラグメントは不適切な情報を持つだろう --- 近傍から補間または選択のいずれかが行われて(バイラテラルアップサンプリング)。

# 3Dテクスチャ --- 適切なエッジ

幸いにも、3Dテクスチャと3D補間を用いると、そのような問題を抱えない。
すべてのフル解像度フラグメントとその深度は計算される関数の適切な区間線形補間を得る。
これは依然として低解像度であり、"ギザギザしている[jagged]"可能性がある一方で、エッジの不連続性アーティファクトを持たない。

# エイリアシング問題

ローパスフィルタリングが高周波源の情報のテンポラルエイリアシング/フリッカリング問題を取り除く方法をこの図で確認できる。

# エイリアシング問題

- 4つのシャドウカスケード 1536x1536
    - 細かすぎる
    - ボリュームのナイキスト周波数以上のシャドウイング
    - 大量のエイリアシング、フリッカリング
    - ローパスフィルタを適用する必要がある
    - ナイーブな32タップのPCF = 許容できないパフォーマンス

我々のアルゴリズムの最初の工程はフォグが太陽の散乱のシャドウイングを計算するのに使われるシャドウマップを準備することである。

なぜ必要なのか？

通常のシャドウイングカスケードは非常に高解像度であり(4つのカスケード、プラットフォームに依存する1536x1536または1Kx1K)、それらの密な高解像度情報を持つ。
これは我々にはかなり細かすぎた。特に、近距離で、かつ、最初の2つのカスケードでは、最初の2メートルに凝縮した。
なめらかで近似的なボリューメトリックフォグでは、動く草木などによるフリッカリング/エイリアシングアーティファクトを減らすためにさらに低解像度のものを必要とした。広いカーネルのPCFを用いる最初の実装は非常に乏しいパフォーマンスや依然としていくつかのフリッカリングやエイリアシングアーティファクトを持った。

# 指数シャドウマップ

TODO
