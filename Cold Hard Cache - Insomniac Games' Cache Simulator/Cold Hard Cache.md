---
title: Cold, Hard Cache - Insomniac Games' Cache Simulator [@Fredriksson2017]
---
# Cold, Hard Cache - Insomniac Games' Cache Simulator

# Andreasと申します

- Insomniacでコアツール＆基盤チームを率いている

# Andreasと申します

- Insomniacでコアツール＆基盤チームを率いている
- 今日のトピック: Insomniac GamesのCacheSim
    - キャッシュ効率を測定するための独自のツール群

# Andreasと申します

- Insomniacでコアツール＆基盤チームを率いている
- 今日のトピック: Insomniac GamesのCacheSim
    - キャッシュ効率を測定するための独自のツール群
    - 本日、これをオープンソース化して、あなた方と共有しようとすることに興奮している

# 目で解るキャッシュとメモリのサイズ

# 目で解るキャッシュとメモリのサイズ

# 目で解るキャッシュとメモリのサイズ

# 目で解るキャッシュとメモリのサイズ

# 目で解るキャッシュとメモリのサイズ

# サイクルでのキャッシュおよびメモリのアクセス速度

# 背景

- キャッシュはRAMより何倍も高速で小さい
    - そこに入れるものは大きく異なる

# 背景

- キャッシュはRAMより何倍も高速で小さい
    - そこに入れるものは大きく異なる
- メモリ操作はプログラムに追加するのが極めて簡単である
    - コストは隠蔽され、不明確である

# 背景

- キャッシュはRAMより何倍も高速で小さい
    - そこに入れるものは大きく異なる
- メモリ操作はプログラムに追加するのが極めて簡単である
    - コストは隠蔽され、不明確である
- アクセスパターンで使えるデータを是非とも必要としている
    - パフォーマンスを意識したプログラマーには選択肢がそれほど豊富ではない

# サンプリングプロファイラ

- 基本的には上手くいった --- ほとんどのプロファイラはサンプルベースである
    - 多くのワークフローに対して優秀である
    - キャッシュに関するハードウェアの状態を収集するためにCPUの機能を活用する

# サンプリングプロファイラ

- 基本的には上手くいった --- ほとんどのプロファイラはサンプルベースである
    - 多くのワークフローに対して優秀である
    - キャッシュに関するハードウェアの状態を収集するためにCPUの機能を活用する
- 制限: N個の命令に1回だけサンプルされる(Nは大きい)

# サンプリングプロファイラ

- 基本的には上手くいった --- ほとんどのプロファイラはサンプルベースである
    - 多くのワークフローに対して優秀である
    - キャッシュに関するハードウェアの状態を収集するためにCPUの機能を活用する
- 制限: N個の命令に1回だけサンプルされる(Nは大きい)
- より小さく、"バースト性の高い[bursty]^[＝バースト(一時的に作業量が増加すること)が高頻度で発生すること]"ワークロードには理想的ではない
    - 統計学的には、ものが小さければ小さいほど再現可能性が低下すると言える
    - 正しい方向を指し示すが、ズバリではない

# サンプリング空間の外側

- cachegrind --- valgrindの一部
    - プログラムの命令ストリームに基づいてキャッシュをシミュレートする

# サンプリング空間の外側

- cachegrind --- valgrindの一部
    - プログラムの命令ストリームに基づいてキャッシュをシミュレートする
- 利点:
    - 極めて徹底的 --- すべてのメモリアクセスがシミュレートされる

# サンプリング空間の外側

- cachegrind --- valgrindの一部
    - プログラムの命令ストリームに基づいてキャッシュをシミュレートする
- 利点:
    - 極めて徹底的 --- すべてのメモリアクセスがシミュレートされる
- 欠点:
    - Linuxのみ
    - 二者択一
    - 興味のある所までたどり着くのが極めて遅い

# サンプリング空間の外側

- cachegrind --- valgrindの一部
    - プログラムの命令ストリームに基づいてキャッシュをシミュレートする
- 利点:
    - 極めて徹底的 --- すべてのメモリアクセスがシミュレートされる
- 欠点:
    - Linuxのみ
    - 二者択一
    - 興味のある所までたどり着くのが極めて遅い
- ちなみに、前世代にあったベンダ固有のツールは素晴らしかった
    - 短時間で要求に応じてシミュレートされたキャプチャを行うことができた

# キャッシュシミュレーションツール群が欲しい理由

```cpp
void PushBuffer::SetTextureAssets(uint32_t start_slot, uint32_t slot_count,
                                  const TextureAsset** textures_assets,
                                  uint32_t slot_mask, uint32_t hq_mask) {
  // ...
  for (uint32_t itex = 0; itex < slot_count; ++itex, tex_unit_test <<= 1) {
    Texture const* tex = (slot_mask & tex_unit_test)
                             ? textures_assets[itex]->GetTexture()
                             : NULL;
    // ...
    if (tex != NULL) {
      view = (textures_assets[itex]->GetFormatFlags() &
              TextureFormatFlags ::kIsCube)
                 ? tex->m_View
                 : tex->m_ViewArray;
      samp = (hq_mask & tex_unit_test)
                 ? textures_assets[itex]->GetAnisoSampler()
                 : tex->m_SamplerState;
    }
    // ..
  }
  // ..
}
```

# キャッシュシミュレーションツール群が欲しい理由

1フレームで2800回のL2キャッシュミス

# 小さきことなり

- メンバはキャッシュラインを移動していた
    - 16ビットのFormatFlagsフィールドへのアクセスはそのときは約束されたL2キャッシュミスであった

# 小さきことなり

- メンバはキャッシュラインを移動していた
    - 16ビットのFormatFlagsフィールドへのアクセスはそのときは約束されたL2キャッシュミスであった

# 小さきことなり

- メンバはキャッシュラインを移動していた
    - 16ビットのFormatFlagsフィールドへのアクセスはそのときは約束されたL2キャッシュミスであった
- 修正: ヘッダにて2つの行を文字通り入れ替える

# 小さきことなり

- メンバはキャッシュラインを移動していた
    - 16ビットのFormatFlagsフィールドへのアクセスはそのときは約束されたL2キャッシュミスであった
- 修正: ヘッダにて2つの行を文字通り入れ替える
- ビュー次第では150〜250usの節約となる

# 小さきことなり

- メンバはキャッシュラインを移動していた
    - 16ビットのFormatFlagsフィールドへのアクセスはそのときは約束されたL2キャッシュミスであった
- 修正: ヘッダにて2つの行を文字通り入れ替える
- ビュー次第では150〜250usの節約となる
- かけた時間[time investment]: 30分

# キャッシュシミュレーションツール群が欲しい更なる理由

- 小さなユーティリティが時折大量にキャッシュミスを引き起こす
    - `Vec3 SceneObject::GetPosition() { return m_ObjToWorld.v[3]; }`

# キャッシュシミュレーションツール群が欲しい更なる理由

- 小さなユーティリティが時折大量にキャッシュミスを引き起こす
    - `Vec3 SceneObject::GetPosition() { return m_ObjToWorld.v[3]; }`
- 単一のreturn文を最適化できない！ (ノಠ益ಠ)ノ彡┻━┻
    - でも、less naiveとなるためにその関数の呼び出し元を最適化できる

# キャッシュシミュレーションツール群が欲しい更なる理由

- 小さなユーティリティが時折大量にキャッシュミスを引き起こす
    - `Vec3 SceneObject::GetPosition() { return m_ObjToWorld.v[3]; }`
- 単一のreturn文を最適化できない！ (ノಠ益ಠ)ノ彡┻━┻
    - でも、less naiveとなるためにその関数の呼び出し元を最適化できる
- 同様にコールスタックを追跡する必要があり、passはスタックのせいにする

# キャッシュシミュレーションツール群が欲しい更なる理由

- 小さなユーティリティが時折大量にキャッシュミスを引き起こす
    - `Vec3 SceneObject::GetPosition() { return m_ObjToWorld.v[3]; }`
- 単一のreturn文を最適化できない！ (ノಠ益ಠ)ノ彡┻━┻
    - でも、less naiveとなるためにその関数の呼び出し元を最適化できる
- 同様にコールスタックを追跡する必要があり、passはスタックのせいにする
- ひとつのゲームプレイシステムに起因するGetPosition()における14kのキャッシュミスのうち12k個を見つけた 😊

# コールドデータとしてSceneObject::GetPosition()を呼び出しているのは誰？

```cpp
uint32_t num_groups = 0;
// Get a ton of stuff to work on
ComponentHandle* groups = g_PlacedPedestrianSystem.GetGroups(num_groups);
for (uint32_t idx = 0; idx < num_groups; ++idx) {
  PlacedPedestrianGroup* group = (PlacedPedestrianGroup*)groups[idx].Resolve();
  if (!group) continue;
  const Vec3 &group_pos = group->GetActorPosition();
  // ...
}
```

# コールドデータとしてSceneObject::GetPosition()を呼び出しているのは誰？

1フレームで約12000回のL2キャッシュミス

# すでに知っていることについて尋ねたりはしない

- PCでは1フレームあたり約1ms
    - フレームごとに処理される幾千もの(順不同な)項目

# すでに知っていることについて尋ねたりはしない

- PCでは1フレームあたり約1ms
    - フレームごとに処理される幾千もの(順不同な)項目
- 調査: これらは動かない

# すでに知っていることについて尋ねたりはしない

- PCでは1フレームあたり約1ms
    - フレームごとに処理される幾千もの(順不同な)項目
- 調査: これらは動かない
- 修正: 並列な配列に位置のローカルキャッシュを保持する
    - 完全にGetPosition()の呼び出しを回避する

# すでに知っていることについて尋ねたりはしない

- PCでは1フレームあたり約1ms
    - フレームごとに処理される幾千もの(順不同な)項目
- 調査: これらは動かない
- 修正: 並列な配列に位置のローカルキャッシュを保持する
    - 完全にGetPosition()の呼び出しを回避する
- 結果: フレーム当たり650usの節約

# すでに知っていることについて尋ねたりはしない

- PCでは1フレームあたり約1ms
    - フレームごとに処理される幾千もの(順不同な)項目
- 調査: これらは動かない
- 修正: 並列な配列に位置のローカルキャッシュを保持する
    - 完全にGetPosition()の呼び出しを回避する
- 結果: フレーム当たり650usの節約
- かけた時間: 2時間

# 命令、命令

- 我々の欲しいデータすべてはすぐそこ、命令ストリームにある
    - 我々はそれが実行するかのように各命令を調べる方法が欲しい"だけ"である

# 命令、命令

- 我々の欲しいデータすべてはすぐそこ、命令ストリームにある
    - 我々はそれが実行するかのように各命令を調べる方法が欲しい"だけ"である
- 計画:
    - 興味のある地点に到達するときにスイッチを切り替える
    - すべての命令を追跡する(何とかして)
    - メモリアクセスごとにシミュレートされたキャッシュを更新する
    - (フレーム終わりになったら)追跡を切って、報告する！

# 命令、命令

- 我々の欲しいデータすべてはすぐそこ、命令ストリームにある
    - 我々はそれが実行するかのように各命令を調べる方法が欲しい"だけ"である
- 計画:
    - 興味のある地点に到達するときにスイッチを切り替える
    - すべての命令を追跡する(何とかして)
    - メモリアクセスごとにシミュレートされたキャッシュを更新する
    - (フレーム終わりになったら)追跡を切って、報告する！
- でも、どうやって？

# どこから始めよう？

TODO
