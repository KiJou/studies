---
title: GPU driven rendering experiments [@Anagnostou2018]
---
# GPU driven rendering experiments

# 自己紹介

- Unit 2 Gamesのリードグラフィクスプログラマ
- 以前はRadiant Worldsのリードグラフィクス/エンジンプログラマで、5年ほどSkysaga: Infinite Islesの開発に従事していた
- Blitz Games Studiosのシニアグラフィクスプログラマ
- Rareのレンダリングエンジニア
- コンピュータグラフィックスでのPhDに加えていくつかの学術的なグラフィクスを修め、地方の大学でコンピュータグラフィックスを教えていた
- 時々、[https://interplayoflight.wordpress.com](https://interplayoflight.wordpress.com)でブログを書いている

#

# ジオメトリカリング: とは？

- 最終的にレンダリングされる画像に(大幅に)寄与しないジオメトリをGPUパイプラインに流さないこと
- オクルージョンカリングはこのサブセットであり、他(ソリッドメッシュ)の背後に位置するジオメトリに関係する
- 錐台[frustum]カリング、後面[backface]カリング、スクリーンサイズカリングはカリングのその他の形である

# ジオメトリカリングを気にする理由

- 長年ピクセルシェーダのコストを減らそうと奮闘してきた
    - 後面カリング、Early-Z、Hi-Z、Zプリパス、ステンシル処理、ディファードレンダリング、動的解像度、マルチ解像度、など
- 頂点シェーディングをあまり好いてこなかった[?]
- ポリゴン数は同様に増加している
    - Zプリパス、シャドウパス、ディファードパスはメモリ帯域幅や処理要件を増加させる
    - 開発者の制御外のゲームコンテンツ(UGC)
- ナイーブ/ブルートフォースな頂点シェーディングはGPU処理を無駄にする可能性がある
    - このことは、フレーム時間の削減を逃す可能性がある
    - または、(おそらく)よりきれいなピクセルをシェーディングするのに使われる[時間を]
    - または、さらなる非同期コンピュートを行う[時間を]
    - または、GPUを冷やし続ける[時間を]
- これは同様にCPUに利を成す可能性がある(API呼び出しが少なくなる)

#

# 小道具いっぱい！

- ゲームはすぐにジオメトリに縛られるようになる
- 加えて、不十分なバッチングによる大量のドローコール

# オクルージョンカリング

- 元のオクルージョンカリングはボクセルチャンクの連結グラフに基づいていた[@Checchi2014]
- 建物内の大量の小道具やかなりのオープンスペースには十分に効率的でなかった

# オクルージョンカリング: ハードウェアクエリ

- GPUはオクルージョンクエリのオクルージョンカリングをサポートする
- メッシュインスタンシングを用いるとすると十分な粒度ではない
- 同じフレーム中にその結果を使用できない(ポッピング)
- 依然として、有用な選択肢であり、Unrealのデフォルトのオクルージョンカリングシステムである

# オクルージョンカリング: CPUラスタライゼーション

- CPUで遮蔽物を小さなZバッファにラスタライズする
- バウンディングボックスをラスタライズしてテストする
- 同じフレームに結果を使える！
- CPUコストを増加させる
- Frostbite[@Collin2011]やKillzone3[@Valient2011]はこれを実装しており、Intel[@Kuah2016]にはソフトウェアラスタライザのソリューションがある

# オクルージョンカリング: GPU(DX10までの時代)

- GPUは高速なラスタライザであり、そこで遮蔽物のZバッファを生み出す
- 階層的なミップチェインを生み出し、ピクセルシェーダでカリングを行う
- レンダリングを操るためにCPUで結果を読み戻す
- GPUオクルージョンパス -> CPUの小道具のカリング -> GPUレンダリングパス
- ラグがあり、同じフレームに結果が使えない

# オクルージョンカリング: GPU(コンピュート、DX11+)

- CPUに結果を送り戻さないとしたらどうする？
- オクルージョンパス -> GPUの小道具のカリング -> GPUレンダリングパス
- この分野での素晴らしい進歩
- [@Haar2015]や[@Wihlidal2016]のプレゼンテーションを参照
    - 均一なメッシュクラスタ
    - メッシュクラスタのHi-Zカリング
    - トライアングルフィルタリング(錐台、大きさ、向き、など)
    - MultiDrawIndirectによるメッシュバッチングとレンダリング

# オクルージョンカリング: GPU(コンピュート、DX11+)

- そのゲームでは、追加できそうな簡単な何かを必要とした
- DX11、理想的には拡張に依存しない
- 小道具メッシュレベルで動作し、コンテンツパイプラインへの変更がない
- 譲歩して、階層的Zバッファのアイデアを再検討する[@Oat2008; @Hill2011]

# Hi-Zカリング

- Zバッファに遮蔽物をレンダリングする
- ミップチェインを作るためにZバッファをダウンスケールする
- すべての小道具のバウンディングボックスを追加し、コンピュートシェーダに渡す
- Zバッファのミップチェインを用いてカリングを行う
- 可視の小道具をレンダリングするのにDrawIndexedInstancedIndirectを使う
- やったぜ。

# Hi-Zカリング

- ドローコール
    - インデックス数
    - インスタンス数
    - インデックスバッファのオフセット
    - 頂点バッファのオフセット
    - インスタンスバッファのオフセット
- ドローコールリスト
- メッシュリスト
- インスタンスリスト

# 階層的Zバッファ

- 生成は素直で、空のピクセルシェーダを用いて大きなメッシュをレンダリングする
- max()を用いてN回ダウンスケールするのにコンピュートまたはピクセルシェーダを使う
- 一度に4つの深度サンプルを得るためにGather4を使うことができる
- または、D3D11_FILTER_MAXIMUM_MIN_MAG_MIP_POINTテクスチャフィルタモードを使う(DX11.2が必要)

<div class="note">
大きな遮蔽物メッシュ(壁、大きな小道具、地形)を選び、D16のZバッファにレンダリングする。16ビット精度が十分か否かは状況やカリング範囲などに依存するだろう。一般に、カメラに近いほぼ精度が良い。その範囲に渡って精度を改善するために反転Zバッファを試すことができるだろう。

max操作を用いてミップチェインを作るために続いてZバッファをダウンスケールする。これは低ミップで遮蔽物の"ジオメトリ"を大幅に変化させるだろうが、より正確なオクルージョンを提供する(見えている小道具をカリングしない)

すべての4サンプルを得るためにGatherを用いることができるだろうが、これはミップをサポートせず、ミップあたりSRV/RTVを生成する必要があるだろう。または、DX11.2を使えるなら、最大テクスチャフィルタモードを用いる。これはミップマップミップマップをサポートし、Gather4より使うVGPRが少ない(このtipについてSebastian Aaltonenに感謝)

Zバッファのレンダリングはレンダリングフレームへの追加コストである(頂点bound)。これは、低メッシュLODをレンダリングしたり、フルスクリーンをレンダリングしてGプリパスをレンダリングするときに使ってオーバーヘッドを軽減させる、といった軽減策がある。入力としてZバッファをバインドするとdecompressされて、後続のZ操作をより高価にすることを、いくつかのGPUでは気に留めておく価値がある(例えば、Gプリパスに影響を与えるかもしれない)。
</div>

# 小道具のカリング

# 小道具のカリング

# 小道具のカリング

- ミップのサポートがないので、一度に4サンプルを得るためにGather4を使用できない
- DX11はSampleLevelCmpと同等のものを公開していない :-(
- (DX11.2でなら)D3D11_FILTER_MAXIMUM_MIN_MAG_MIP_POINTテクスチャフィルタモードを使う
- そうでなければ、4つのSampleLevel命令を使う
- [@Wihlidal2016]や[@Haar2015]のようにトライアングルをフィルタできないが、錐台カリングやスクリーン上メッシュサイズカリングのようないくつかの追加の処理を行うことができる

# 小道具のカリング

# 小道具のカリング

- オクルージョンパスは遮蔽された小道具に対するインスタンスバッファにある"ギャップ"をそのままにするだろう
- それらのレンダリングを回避できないので、取り除く必要がある

# 小道具のカリング

- ナイーブな最初の試み: AppendBufferを使う
- インスタンスがバッチされず、順番が保存されないときに上手く動作する

# Stream compaction

TODO
