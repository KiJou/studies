---
title: Render graphs and Vulkan - a deep dive [@Themaister2017]
bibliography: bibliography.bib
numberSections: false
---
# Introduction

VulkanやD3D12といったモダンなグラフィクスAPIはエンジン開発者に新たな挑戦をもたらす。これらAPIによりCPUオーバーヘッドは劇的に減少した一方で、ドライバの"良い"経路に当たっているときはGPUパフォーマンスに関するギャップを埋めることは難しくなるのは明らかであり、我々はGPU束縛である。OpenGLやD3D11のドライバは(はっきりと)あらゆる種類のトリックを使ってでもGPUパフォーマンスを改善するためならいかなる苦労も惜しまない。開発者として我々がこれに払うコストは予測不可能なパフォーマンスであり、より高いオーバーヘッドである。我々は柔軟性、パフォーマンス、使いやすさのバランスを取るこれらのAPIのために素晴らしいレンダリングバックエンドを構築する方法を考え出す中にあるため、グラフィクスバックエンドを書くことは再び面白くなっている。

先週、私は自分の見解としてのVulkanレンダリングエンジンであるGraniteというサイドプロジェクトをリリースした。そのようなプロジェクトは界隈にたくさんあり、それぞれにはそれぞれの利点があるが、私は特にレンダグラフ実装を議論したい。

レンダグラフ実装はYuriy O'DonnellのGDC2017でのプレゼンテーション[@ODonnell2017]に端を発する。このトークはD3D12が中心になっているが、私はVulkanで実装した。

(注記:個々ではレンダグラフとフレームグラフは同じことを意味する。また、Vulkanで言及することはD3D12にも当てはまるかもしれない…多分。)

# The problem

レンダグラフはモダンAPIにおけるひどく迷惑な問題を根本的に解決する。どうやって手動による同期を扱うのだろうか？すぐに分かる代替案を見ていこう。

## Just-in-time synchronization

最も素直なアプローチは基本的には直前に同期を行うことである。テクスチャにレンダリングしようとしたり、リソースをバインドしたり、似たようなことをするたび、自分自身に「このリソースは同期する必要がある保留中の仕事があるか？」と問いかける必要がある。そうであれば、その直前でなんとかしてそれを扱う必要がある。読み込みが1000回以上あっても書き込みが一度しかなかったりするため、この種の追跡は非常に辛いものになる。マルチスレッディングは非常に辛いものになる。2つのスレッドが1つのバリアを見つけた場合どうなるだろうか？あるスレッドが"勝つ"必要があるので、これを扱うために大量の役に立たないスレッド間同期に悩まされることになる。

追跡する必要があるのは実行にとどまらず、Vulkanにおいてイメージレイアウトやメモリアクセスの問題もある。特定の方法でリソースを使うには固有のイメージレイアウトが必要になる(または、単にGENERALでもよいが、この場合フレームバッファの圧縮が使えなくなる)。

本質的に、我々が欲しいものがジャストインタイムでの自動的な同期であるならば、基本的にはOpenGLやD3D11に立ち返れば良い。ドライバはすでに死ぬほど最適化されているのに、どうして中途半端に再実装したいと望むのだろうか？

## Fully explicit synchronization

別の側面から見れば、我々の選択するAPI抽象化は自動的な同期の一切を取り除くため、アプリケーションはすべての同期点を手動で扱う必要がある。間違いを犯したときは、"面白い"デバッグ講義の準備をしておいてください。

単純なアプリケーションならこれでうまく行くが、この道を下り始めてしまえば、どれだけ厄介なことになっているかにすぐに気付くことになる。一般的に、レンダリングパイプラインはブロックに区分けされているだろう。あるモジュールにフォワードやディファード、クールな某といったレンダラがあったり、他のモジュールにポストプロセスパスが散財していたり、再投影ステップのコピペが持ち込まれていたりして、あちらこちらに新しいテクニックを追加するので、同期戦略を練り直さなければならなくなる。そうして、モノが腐っていく。

なぜこんなことが起こるのか？

死ぬほど単純なポストプロセスパスの疑似コードをいくつか書いて考えてみよう。

~~~c
// 私が最後にこのイメージから読み出したのはいつだったか？たしかポストチェインの後の最後のフレーム…
// write-after-readハザードを回避したい。
// イメージ全体を書き込もうとしている。
// そうであれば、UNDEFINEDから以前のコンテンツの"破棄"へ遷移したほうがよさそうだ…
// 理想では前のフレームからVkEventの追跡をきちんと行っていたいが、さすがに面倒だ…
// このレンダターゲットはどこから割り当てられた？
BeginRenderPass(RT = BloomTheresholdBuffer)

// このイメージはおそらく前のフレームで書き込まれているだろうが、誰も知らないだろう。
BindTexture(HDR)

DrawMyQuad()
EndRenderPass()
~~~

この種の問題は一般的には大きく幅のあるパイプラインバリアで解決される。パイプラインバリアは**グローバルな**同期問題について**局所的に**推理させるが、常に最適な方法とはならない。

~~~c
// 安全になるようにすべてのフラグメントの実行が完了するのを待つために、これはwrite-after-readとHDRレンダパスの面倒を見ていることになる…
// 非同期コンピュートで使われないと仮定すれば…ふむ、これならうまく行きそうだ。

PipelineBarrier(FRAGMENT -> FRAGMENT,
    RT layout: UNDEFINED -> COLOR_ATTACHMENT_OPTIMAL,
    RT srcAccess: 0 (write-after-read)
    RT dstAccess: COLOR_ATTACHMENT_WRITE_BIT,
    HDR layout: COLOR_ATTACHMENT_OPTIMAL -> SHADER_READ_ONLY,
    HDR srcAccess: COLOR_ATTACHMENT_WRITE_BIT,
    HDR dstAccess: SHADER_READ_BIT)

BeginRenderPass(...)
~~~

そうして、我々はそれが以前のパスであると仮定したのでHDRイメージを遷移したが、今後異なるパスを遷移の間に追加するかもしれない。…つまり、依然としてイメージレイアウトの追跡を続ける必要がある。まぁ、世界の終わりでもなければ。

`FRAGMENT -> FRAGMENT`のワークロードを扱うだけだとすると、これはそれほどひどいことではなく、なんだかんだ言ってレンダパス間で起こるオーバーラップはそれほどない。コンピュートをごちゃまぜにし始めると、頭がどうにかなりそうになる。なぜなら、このようなパイプラインバリアをあちこちにポンポンと置いていくことは**できない**ので、効率的な実行オーバーラップを達成するためにフレームについての非局所的な知識が必要になる。加えて、異なるキューで非同期コンピュートを行うため、セマフォが必要になることもあるかもしれない。

# Render graph implementation

TODO

# References
