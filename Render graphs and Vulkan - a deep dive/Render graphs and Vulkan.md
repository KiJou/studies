---
title: Render graphs and Vulkan - a deep dive [@Themaister2017]
bibliography: bibliography.bib
numberSections: false
---
# Introduction

VulkanやD3D12といったモダンなグラフィクスAPIはエンジン開発者に新たな挑戦をもたらす。これらAPIによりCPUオーバーヘッドは劇的に減少した一方で、ドライバの"良い"経路に当たっているときはGPUパフォーマンスに関するギャップを埋めることは難しくなるのは明らかであり、我々はGPU束縛である。OpenGLやD3D11のドライバは(はっきりと)あらゆる種類のトリックを使ってでもGPUパフォーマンスを改善するためならいかなる苦労も惜しまない。開発者として我々がこれに払うコストは予測不可能なパフォーマンスであり、より高いオーバーヘッドである。我々は柔軟性、パフォーマンス、使いやすさのバランスを取るこれらのAPIのために素晴らしいレンダリングバックエンドを構築する方法を考え出す中にあるため、グラフィクスバックエンドを書くことは再び面白くなっている。

先週、私は自分の見解としてのVulkanレンダリングエンジンであるGraniteというサイドプロジェクトをリリースした。そのようなプロジェクトは界隈にたくさんあり、それぞれにはそれぞれの利点があるが、私は特にレンダグラフ実装を議論したい。

レンダグラフ実装はYuriy O'DonnellのGDC2017でのプレゼンテーション[@ODonnell2017]に端を発する。このトークはD3D12が中心になっているが、私はVulkanで実装した。

(注記:個々ではレンダグラフとフレームグラフは同じことを意味する。また、Vulkanで言及することはD3D12にも当てはまるかもしれない…多分。)

# The problem

レンダグラフはモダンAPIにおけるひどく迷惑な問題を根本的に解決する。どうやって手動による同期を扱うのだろうか？すぐに分かる代替案を見ていこう。

## Just-in-time synchronization

最も素直なアプローチは基本的には直前に同期を行うことである。テクスチャにレンダリングしようとしたり、リソースをバインドしたり、似たようなことをするたび、自分自身に「このリソースは同期する必要がある保留中の仕事があるか？」と問いかける必要がある。そうであれば、その直前でなんとかしてそれを扱う必要がある。読み込みが1000回以上あっても書き込みが一度しかなかったりするため、この種の追跡は非常に辛いものになる。マルチスレッディングは非常に辛いものになる。2つのスレッドが1つのバリアを見つけた場合どうなるだろうか？あるスレッドが"勝つ"必要があるので、これを扱うために大量の役に立たないスレッド間同期に悩まされることになる。

TODO

# References
