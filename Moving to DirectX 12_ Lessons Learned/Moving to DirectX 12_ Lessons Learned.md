---
title: >
    Moving to DirectX 12: Lessons Learned [@Rodrigues2017]
bibliography: bibliography.bib
numberSections: false
---
# Talk goals

- 多くのトークがすでに直接のAPIの使い方のアドバイスに注力していた。[1] - [8]
- このアドバイスのいくつかを実装するためのより高レベルな戦略に焦点を当てる。

# Background : Anvil Next

- Anvil(内製エンジン)は直近の10年で8つのAssassin's Creedをリリースした。Anvil NextはAssassin's Creed Unityのために開発されたメジャーアップグレードであった。
<!--  -->
- ACUでは、我々が"Anvil Next"と呼んだ、重大なアップグレードを行った。このバージョンでリリースされた一番最近のACでその例が確認できる。

<!-- p.4 -->

- CPU処理の削減とGPUパフォーマンスの改善のため、描画バッチ処理と'GPUサブミッション'を行う。[@Haar2015]
- GFXコンピュートを積極的に利用する。(非同期コンピュートや`MultiDrawIndirect`も)
<!--  -->
- 我々はACUに対してドローコールのバッチ処理と(描画/インスタンス/トライアングルクラスタ/トライアングルのカリングのためにGPUを利用する)'GPUサブミッション'に関する多くの仕事をこなした。この話題の詳細はそれを題材にしたGDC2015のUlrichのプレゼンテーション[@Haar2015]から得られる。
- 我々は、(GPUカリングのために非同期コンピュートや`MultiDrawIndirect`といった)とある機能はPCで利用できないため、レンダリングパイプラインにおいてコンソール固有の最適化も行った。DX12ではこれらの機能がPCでも利用可能になる。

# Background : moving to DX12

- パフォーマンスのボトルネックを測りつつAPIへの理解を深めるため、'ナイーブなポート'から始めた。
- 予想通り、結果は、特にGPUで(時間がDX11の倍かかるくらい)、ひどいパフォーマンスだった。
<!--  -->
- DX12APIの詳細は昔のレンダラインターフェイスに隠蔽する形で、とても基本的なポートから始めた。
- 予想通り、極めてひどいパフォーマンスであった(GPU時間はDX11の最大200%となった)。主にハードウェア抽象化レイヤにおいてリソース状態の視野が非常に低レベルで狭いため、一般的なAPIの使い方のアドバイスを実装することが単純に難しすぎる。

<!-- p.6 -->

- 主なGPUパフォーマンスの問題:
    - バリアの乱用。
    - メモリのオーバーコミット(過剰要求)。
- 主なCPUパフォーマンスの問題:
    - PSOコンパイルによるレンダリングスレッドのヒッチング。
    - デスクリプタのコピー量。
<!--  -->
- バリアの乱用:
    - コミット間のバッチ処理時でさえ、大量の個別のバリア呼び出しを行っていた。
    - (大量の不必要な中間の遷移を引き起こす)初期状態の強制化をあらゆるところにばら撒くことをせずに、マルチスレッド化されたコマンドリストレコーディングでバリアを管理するのは極めて難しい。
- メモリ関係:
    - (エイリアシングやタイルリソース/MIPのストリーミングが足りていないため、)大幅にオーバーコミットしていた。
    - コマンドリストの管理と再利用による問題もあった。
- PSOとデスクリプタの管理:
    - PSOのコンパイルにより、レンダリングスレッドでヒッチングを起こす。
    - すべてのユースケースを扱うために共通のroot signatureを使っていたため、デスクリプタの大量コピーが起こっていた。

<!-- p.7 -->

- 以下に基づいてレンダラの再設計を計画し始めた。
    - 初期ポートからの知見。
    - Ubisoftの他のチーム。
    - DX12に関する様々なトークからのアドバイス。

# API guidance recap:

- リソースバリアを最小化してバッチ処理する。[@Oldcorn2015]
- 並列コマンドリストレコーディングの完全な恩恵を得る。[@Thomas2016; @Oldcorn2015]
- いくつかのGPUキューを使うようにする。[@Hart2015]
<!--  -->
- リソースバリアの最小化とバッチ処理は非常に重要である。
    - さもないと、処理のシリアライズや不必要なキャッシュのフラッシュによってGPUパフォーマンスを損なうことになる。
    - DX11ドライバは何年もかけて水面下でこれを最適化してきた。DX12はここで未だに多少の救済を提供している: 単一の呼び出しでバリアをバッチする場合、その呼び出しにおけるすべての遷移に対する最小のバリアアクションの集合を生み出そうとする。
- DX12は、良好なCPUパフォーマンスを得るために不可欠である、完全に機能する低オーバーヘッドな並列コマンドリストレコーディングも提供する。
    - 小さなコマンドリストが大量にあったり、`ExecuteCommandLists`を呼び出しすぎたりすると、CPUパフォーマンスを損なう恐れがある、といった気に留めておくべき注意事項が存在する。
- コピーエンジンや非同期コンピュートキューを使わなければならないDX11ドライバとのすり合わせをしたいと望むなら、そのアクセス権も得られる。
    - また、コンソール開発者として機能セットに関して言えば、PCの機能はかなり近くなっている。これはエンジン設計の視点から見れば素晴らしいことである。

# API guidance recap(2):

- 実行時処理を最小化するために事前コンパイルしたレンダステートを使う。[@Hart2015]
- 効率的にメモリを管理する。[@Hodes2016]
<!--  -->
- 実行時処理を最小化するために効率的に事前コンパイルしたレンダステートを使うこともCPUパフォーマンスに対して極めて重要である。
    - APIは事前コンパイルされたステートブロブに重点を置いているため、高価な処理を一度だけ行い、それをキャッシュして、バインド時にオーバーヘッドを最小にすることが可能になる。
- メモリ管理は大きなトピックであり、私が導入するシステムに関係するいくつかの面のみを述べる。
    - APIはユーザがメモリの割り当てや管理を制御できるようになっている。(このため、例えば、メモリのエイリアシングが実装できる。)

# Systems

TODO

# References
