---
title: >
    Moving to DirectX 12: Lessons Learned [@Rodrigues2017]
bibliography: bibliography.bib
numberSections: false
---
# Talk goals

- 多くのトークがすでに直接のAPIの使い方のアドバイスに注力していた。[1] - [8]
- このアドバイスのいくつかを実装するためのより高レベルな戦略に焦点を当てる。

# Background : Anvil Next

- Anvil(内製エンジン)は直近の10年で8つのAssassin's Creedをリリースした。Anvil NextはAssassin's Creed Unityのために開発されたメジャーアップグレードであった。
<!--  -->
- ACUでは、我々が"Anvil Next"と呼んだ、重大なアップグレードを行った。このバージョンでリリースされた一番最近のACでその例が確認できる。

<!-- p.4 -->

- CPU処理の削減とGPUパフォーマンスの改善のため、描画バッチ処理と'GPUサブミッション'を行う。[@Haar2015]
- GFXコンピュートを積極的に利用する。(非同期コンピュートや`MultiDrawIndirect`も)
<!--  -->
- 我々はACUに対してドローコールのバッチ処理と(描画/インスタンス/トライアングルクラスタ/トライアングルのカリングのためにGPUを利用する)'GPUサブミッション'に関する多くの仕事をこなした。この話題の詳細はそれを題材にしたGDC2015のUlrichのプレゼンテーション[@Haar2015]から得られる。
- 我々は、(GPUカリングのために非同期コンピュートや`MultiDrawIndirect`といった)とある機能はPCで利用できないため、レンダリングパイプラインにおいてコンソール固有の最適化も行った。DX12ではこれらの機能がPCでも利用可能になる。

# Background : moving to DX12

- パフォーマンスのボトルネックを測りつつAPIへの理解を深めるため、'ナイーブなポート'から始めた。
- 予想通り、結果は、特にGPUで(時間がDX11の倍かかるくらい)、ひどいパフォーマンスだった。
<!--  -->
- DX12APIの詳細は昔のレンダラインターフェイスに隠蔽する形で、とても基本的なポートから始めた。
- 予想通り、極めてひどいパフォーマンスであった(GPU時間はDX11の最大200%となった)。主にハードウェア抽象化レイヤにおいてリソース状態の視野が非常に低レベルで狭いため、一般的なAPIの使い方のアドバイスを実装することが単純に難しすぎる。

<!-- p.6 -->

- 主なGPUパフォーマンスの問題:
    - バリアの乱用。
    - メモリのオーバーコミット(過剰要求)。
- 主なCPUパフォーマンスの問題:
    - PSOコンパイルによるレンダリングスレッドのヒッチング。
    - デスクリプタのコピー量。
<!--  -->
- バリアの乱用:
    - コミット間のバッチ処理時でさえ、大量の個別のバリア呼び出しを行っていた。
    - (大量の不必要な中間の遷移を引き起こす)初期状態の強制化をあらゆるところにばら撒くことをせずに、マルチスレッド化されたコマンドリストレコーディングでバリアを管理するのは極めて難しい。
- メモリ関係:
    - (エイリアシングやタイルリソース/MIPのストリーミングが足りていないため、)大幅にオーバーコミットしていた。
    - コマンドリストの管理と再利用による問題もあった。
- PSOとデスクリプタの管理:
    - PSOのコンパイルにより、レンダリングスレッドでヒッチングを起こす。
    - すべてのユースケースを扱うために共通のroot signatureを使っていたため、デスクリプタの大量コピーが起こっていた。

<!-- p.7 -->

- 以下に基づいてレンダラの再設計を計画し始めた。
    - 初期ポートからの知見。
    - Ubisoftの他のチーム。
    - DX12に関する様々なトークからのアドバイス。

# API guidance recap:

- リソースバリアを最小化してバッチ処理する。[@Oldcorn2015]
- 並列コマンドリストレコーディングの完全な恩恵を得る。[@Thomas2016; @Oldcorn2015]
- いくつかのGPUキューを使うようにする。[@Hart2015]
<!--  -->
- リソースバリアの最小化とバッチ処理は非常に重要である。
    - さもないと、処理のシリアライズや不必要なキャッシュのフラッシュによってGPUパフォーマンスを損なうことになる。
    - DX11ドライバは何年もかけて水面下でこれを最適化してきた。DX12はここで未だに多少の救済を提供している: 単一の呼び出しでバリアをバッチする場合、その呼び出しにおけるすべての遷移に対する最小のバリアアクションの集合を生み出そうとする。
- DX12は、良好なCPUパフォーマンスを得るために不可欠である、完全に機能する低オーバーヘッドな並列コマンドリストレコーディングも提供する。
    - 小さなコマンドリストが大量にあったり、`ExecuteCommandLists`を呼び出しすぎたりすると、CPUパフォーマンスを損なう恐れがある、といった気に留めておくべき注意事項が存在する。
- コピーエンジンや非同期コンピュートキューを使わなければならないDX11ドライバとのすり合わせをしたいと望むなら、そのアクセス権も得られる。
    - また、コンソール開発者として機能セットに関して言えば、PCの機能はかなり近くなっている。これはエンジン設計の視点から見れば素晴らしいことである。

# API guidance recap(2):

- 実行時処理を最小化するために事前コンパイルしたレンダステートを使う。[@Hart2015]
- 効率的にメモリを管理する。[@Hodes2016]
<!--  -->
- 実行時処理を最小化するために効率的に事前コンパイルしたレンダステートを使うこともCPUパフォーマンスに対して極めて重要である。
    - APIは事前コンパイルされたステートブロブに重点を置いているため、高価な処理を一度だけ行い、それをキャッシュして、バインド時にオーバーヘッドを最小にすることが可能になる。
- メモリ管理は大きなトピックであり、私が導入するシステムに関係するいくつかの面のみを述べる。
    - APIはユーザがメモリの割り当てや管理を制御できるようになっている。(このため、例えば、メモリのエイリアシングが実装できる。)

# Systems

- Producer System
- Shader Input Group
- Pipeline State管理

# Producer System

# Producer System : Motivation

- レンダリングパイプラインはますます複雑化している。
- リソースのメモリとステートの管理は今やAPIユーザの責任である。
- ユーザに広範囲の低レベル知識を持たせずに新たに開示されたGPU機能を開拓する。
<!--  -->
- ACUの開発の終了時、成長し続けるレンダリングパイプラインの複雑さとしてレンダリングパスアーキテクチャの限界を強く感じ始めた。
- 同時に、近い将来やって来る新しいグラフィクスAPIは、最大限の利点を得るためにアーキテクチャやクロスプラットフォームのレベルで対処されるべきである、すべてのプラットフォームにおける異なる制御レベルを本当に可能にするだろうと感じた。
- この新しい制御レベルはリソースのメモリやステートの管理はいまやユーザの考慮事項であることを意味する。我々は、エンジンユーザに大きな負担を負わせることを避けると同時に、APIを効率的に操ることを望んでいる。

# Complex Rendering Pipelines

![](assets/p13.png)

- プロデューサーはGPUリソースのライター/リーダーである。
- リソースの依存性はGPUでの実行順を決定する。
<!--  -->
- レンダリングパイプラインのタイアグラムの例。
    - プロデューサー(ダイアグラム中の四角)が確認できる。これらは本質的にはGPUリソースのライターとリーダーである。
    - そして、GPUの実行順を定義するこれらの間の依存性を持つ。
    - いくつかのGPUキューも持つ。これは、リソースの寿命管理や同期などの観点から一層複雑にする。
- このグラフの静的な構成を見ただけでもすでにかなり複雑だが、さまざまな有効化した機能セットをサポートするために別の順列のレイヤーを追加しなければならない(例えば、ローエンドマシンでのパフォーマンススケーリング用)。
- パイプラインをいくつかのユースケースに対して再構成することは、手動/明示的なスケジューリングを幾分実用的でなくしてしまう多くの連鎖反応(knock-on effect)がある。
- パフォーマンスを犠牲にせずに、低レベルAPIを効率的に操るために十分な高レベル分法をキャプチャすることを可能にする、いくつかの自動化レベルを必要とした。

# Producer System : Design Goals

- 以下を操るためにリソースの依存性を使う。
    - リソースメモリ寿命。
    - キュー間同期。
    - リソースステート遷移。
    - コマンドリストの実行順やバッチ処理。
<!--  -->
- このシステムの鍵となる設計の側面のひとつはリソース依存性を明示的にすることであった。

# Resource Dependency Tracking

![](assets/p15.png)

- 明示的なリソース依存性が各プロデューサーごとに指定される。
<!--  -->
- この例では、一連のプロデューサーと、GPUで実行するときのリソースとそれらの関係を指定する方法を確認できる。

<!-- p.16 -->

![](assets/p16.png)

- 明示的な依存性はGPUリソースの寿命を自動的に設定することを可能にする。
<!--  -->
- これらの依存性に基づいて、各GPUリソースの寿命を自動的に導くことができる。

# Resource Memory Aliasing

- フレームの至るところでメモリを再利用するために導かれたリソース寿命を使う。
- Placed Resourcesはユーザによるメモリ割り当て制御を可能にする。
- フレームのGPUリソースのメモリフットプリントを削減する。
<!--  -->
- Placed Resourcesと導かれたリソース寿命を使うと、フレームの至るところでメモリを再利用することができ、GPUメモリのフットプリントを削減できる。

<!-- p.19 -->

![](assets/p19.png)

- メモリの再利用を導くためにリソース寿命を使う。
<!--  -->
- メモリエイリアシングはリソース寿命と次のキュー間同期ポイントに基づいて自動的に導かれる。ダイアグラムでは、使用期間がGPU実行の寿命においてオーバーラップしないために同じメモリを共有する2つのGPUリソースの例が確認できる。

# Resource Access Synchronization

TODO

# References
