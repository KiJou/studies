---
title: The Road Toward Unified Rendering with Unity's High Definition Render Pipeline [@Lagarde2018]
---
# The Road Toward Unified Rendering with Unity's High Definition Render Pipeline

# HDレンダリングパイプラインのデザイン目標

- クロスプラットフォーム
    - PC (DX11, DX12, Vulkan)、XBox One、PS4、Mac (Metal)
- 至るところに物理ベースレンダリング
- 統一されたライティング
    - 不透明、透明、ボリューメトリックで同じライティング機能
- 一貫性のあるライティング
    - すべてのライトタイプがすべてのマテリアルで、および、大域照明で機能する
    - 可能な限りdouble lighting / double occlusionを回避する

# レンダリングパイプラインアーキテクチャ

# レンダリングパイプラインアーキテクチャ

- 重要な要素:
    - ライティングおよびマテリアルのアーキテクチャ
    - Gバッファのデザイン
    - フォワード/ディファードパスの機能的同等性[features parity] (*機能的同等性[features parity]*として知られる)
    - デカールのアーキテクチャ
- 以下によってフォローアップする
    - マテリアルの概要
    - ボリューメトリックライティング

# ライティングアーキテクチャ

- ライティングアーキテクチャは*可視*のシーンのライトでのループによって定義される

光源ごとに
↑
物体を評価する

# ライティングアーキテクチャ

- ライティングアーキテクチャは*可視*のシーンのライトでのループによって定義される

光源ごとに　　　⇦ライトのループはCPUの"マルチパス"かGPUの"シングルパス"で行うことができる
↑
物体を評価する
⇧
GPUで評価する

# ライティングアーキテクチャ

- ライティングアーキテクチャは*可視*のシーンのライトでのループによって定義される

光源ごとに
↑
物体を評価する

GPUやCPUパスのどちらかに対するライト区画構造[partitioning structure] (タイル、クラスタ…)によって最適化できる

そのようなループはマテリアルに影響を与えないライトを取り除くCPUやGPUの助けによって最適化できる

# ライティングアーキテクチャ

- ライティングアーキテクチャは*可視*のシーンのライトでのループによって定義される

光源ごとに
↑
物体を評価する

ディファードやフォワードレンダラでは同じ
マテリアル特性の源のみが異なる

このライトループはディファードでもフォワードでも概念的に同一であることに注意する。マテリアルの特性の源のみが異なる。ディファードでは、Gバッファに由来し、フォワードでは、オブジェクトのユニフォーム/テクスチャに由来する。

# ライティングアーキテクチャ

- ライティングアーキテクチャは*可視*のシーンのライトでのループによって定義される

光源、太陽、IBLごとに
↑
物体を評価する

# ライティングアーキテクチャ

- ライティングアーキテクチャは*可視*のシーンのライトでのループによって定義される

光源ごとに
↑
物体を評価する

太陽ごとに
↑
物体を評価する

IBLごとに
↑
物体を評価する

パフォーマンス上の理由により、ゲームではしばしばライトタイプとマテリアル評価応答[evaluation response]との結合が存在する。例えば、我々はマテリアルのライトモデルによってIBLを事前計算する。
つまり、我々はライトタイプごとに1つのループを行う必要がある。

# ライティングアーキテクチャ

- ライティングアーキテクチャは*可視*のシーンのライトでのループによって定義される

光源ごとに
↑
物体を評価する

太陽ごとに
↑　　　　　　　　　　　　⇦別個のパスで計算したりしなかったり
物体を評価する

IBLごとに
↑
物体を評価する

この種のライトタイプループは時折異なる呼び出しに分割され、パフォーマンスが変化するかもしれない。

# ライティングアーキテクチャ

- HDRPにおけるあるGPUライトループ(太陽、パンクチュアル、エリア、IBL、空)

光源ごとに
↑
物体を評価する

太陽ごとに
↑
物体を評価する

IBLごとに
↑
物体を評価する

HDRPにおいて、我々はすべてのライトタイプで単一のライトループを用いる。太陽、大きさのないライト(スポット、ポイント)、エリアライト、空がある。

# ライティングアーキテクチャ

- ディファードパス

HDRPはディファードとフォワードの両方のレンダラをサポートする。ディファードレンダラの例を見ていこう。Gバッファを満たすディファードマテリアルが1つと使う透明マテリアルが1つある。
同じライトループ。統一されたライティング。

# ライティングアーキテクチャ

- フォワードパス

フォワードレンダリングの例。フォワードの不透明および透明マテリアルがある。

# ライティングアーキテクチャ

- ディファードおよびフォワードの混合パス

HDRPは同時にフォワードとディファード両方をサポートしてもいる。この場合、ディファードパスで見てきたものに加えて、フォワードの不透明マテリアルもある。

# ライティングアーキテクチャ

- 完全なフォワードに切り替え可能

# マテリアルアーキテクチャ

- アーティストフレンドリーなデータ VS エンジンデータ

このスキーマはディファードおよびフォワードアーキテクチャで機能するためにHDRPにおいてマテリアルを記述する方法を示している。これらはガイドラインである。そして、我々はアーティストフレンドリーなデータとエンジンフレンドリーなデータの概念を導入する。
Uiかシェーダグラフでアーティストが埋めた入力をアーティストフレンドリーなデータとしよう。smoothnessのようなやつ。我々はライティングエンジンが使えるエンジンデータへの変換関数を追加する(例えば、ラフネス)。
Gバッファは単なる中間ストレージである。これは圧縮可能である。
HDRPのマテリアルはライティングアーキテクチャに合わせるためにこのマテリアルガイドラインに従う必要がある。

# ライティングアーキテクチャ

- 復習

光源ごとに
↑
物体を評価する

太陽ごとに
↑
物体を評価する

IBLごとに
↑
物体を評価する

# ライティングアーキテクチャ

- ボリューメトリックマテリアルでは

光源ごとに
↑
ボリュームを評価する

太陽ごとに
↑
ボリュームを評価する

IBLごとに
↑
ボリュームを評価する

ボリューメトリックでは、その概念は、代わりにボリューメトリックマテリアル(吸収、散乱)を用いたことを除いて、きっかり同じである。

# ライティングアーキテクチャ

- ボリューメトリックマテリアルでは

Gバッファと同様に、我々は計算のためのボリューメトリックマテリアルの入力としてVバッファを用いる。

# ライティングアーキテクチャ

- 実践では: より低い分解能[resolution]でライティングパスを分割する

そして、実践において、我々はライティングパスを分割し、froxelのセルごとに計算し、その後、別個のパスで不透明および透明マテリアルに結果を適用する。

# ライティングアーキテクチャ

- タイルおよびクラスタの両方のアプローチで最適化する
- 目標
    - 偽陽性を取り除くことに焦点を当てる
        - 例: 狭いシャドウをキャストするスポットライト
    - 偽陽性はライティングパスにおいてより高価である
        - ライトカリングはシャドウレンダリング中に非同期に実行する
        - ディファードライティングパスは非同期に実行していない
        - 隠せる所にコストを移す
        - ライティングパスにおける高いregister pressure

1. 球冠[sphere cap]付きスポットライトにも対応するアグレッシブ(だが高速)な偽陽性の除去を重要視する
    - スポットライトはしばしばシャドウをキャストし、狭いので、重要である
    - 基本的な境界球テストを用いたリスト構築は極めて不十分[highly insufficient]である
2. すべてのリスト構築の処理は非同期コンピュートの活用によって吸収される
3. 偽陽性は早めにやるよりライティング中に扱ったほうがもっと高価である
    - 最終ライティングシェーダはより高いループの複雑さとより大きなregister pressureを持つ
    - 最終ライティングシェーダはシャドウマップのレンダリングの間に非同期コンピュートを活用できない
4. そのリストはディファードでもフォワードでもその両方でも使える
5. リストはライティング中のスレッドdivergenceを減らすのに役立つタイプによる順序を保持するための増加するインデックスのためにもたらされる。

# ライティングアーキテクチャ

- 階層的なアプローチ
    1. 可視ライトごとにスクリーン空間のAABBを求める
    2. Big tile 64x64 prepass
        - 粗い交差テスト
    3. タイルまたはクラスタのライトリストを構築する
        - 狭い交差テスト

1. 可視ライトごとにスクリーン空間AABBを求める
2. Big tile 64x64 tile pre-pass. 初期の早期脱出[early out]のためにAABBを使う(2Dで、深度なし)
    - タイルと凸包との厳密な交差テストで追跡調査する
    - 追加のテスト基準[criteria]として境界球を使う(ポイントライトと球冠付きスポットライトで役立つ)

基本的に、最初にAABBパスが来て、その後、AABBパスが生成したものを使うbig tileパスが来て、その後、big tileパスだけでなくAABBパスが生成したものを両方使うFPTLやClusteredのリスト構築パスが来る。FPTLとClusteredの両方はbig tileプリパスで生成されたオーバーラップし得るタイルのリストを用いる。
これら両方はbig tileプリパスからのリストに残っていることをテストするためにAABBを用いる。
凸包は、2つのスケール値を持つ以外は、いわゆるOBBである。なので、我々は、角錐[pyramid]や楔[wedge]のどちらかを作るために、別個の軸XとYに沿って4つの頂点をしぼる[squeeze]ことができる。スケールを1.0に設定すると、それは単なるOBBであり、1.0より小さくすると、内側にすスケールする。両方を限界まで小さくすると角錐になり、片方だけだと楔型になる。境界球はスポットライトの球冠部分をもたらすのに役立つ。OOBと2つのスケール値は凸包として使うものだが、我々はより多くのタイルを除外するための追加の制約として境界球も用いる。これは、ポイントライトだけでなく球冠に対しても重要である。FPTLおよびClusteredでは、64x64タイルごとにbig tileパスで生成されたものをリストとしてループする。これら両方はまずリストに対してAABBを確認し、LDSに粗いリストを作り上げる。これら両方は境界球の輪郭が粗いリストにおけるライトごとにタイルと重なるかどうかの確認によって追跡調査する。最後にFPTLは詳細な剪定を行い、Clusteredは残りのリストに対してクラスタを確認する。
big tileプリパスがAABBを確認するとき、それは2Dであり、64x64のタイルに対してである。FPTLがそれを行うとき、一例として、3DのAABBテストであり、16x16のタイルに対してである。

FPTLでは、それは、不透明ピクセルをカバーするために必要であるのみなので、とりわけタイトである。つまり、我々は交差テストに最大/最小深度を含めることによってその早期パスだけで大量に除外できる。big tileはAABBテストにおいてXYを行う。FPTLはXYZを行う。タイルに対する球のオーバーラップはすべての場合で2Dのオーバーラップテストである。しかし、もちろん、それがより小さなタイルであることから、こまごましたもの[little extra]を取り除くことができる。なので、私は、Clusteredではかなり安価であるので、再びそのテストを行うことに決めた。2回目のAABBテストは依然として2Dであるが、64x64ではなく32x32で実行するので、こまごましたものを剪定する。そして、それは非常に高速なテストである。

#

# Tiledライティング

- 3. タイル16x16
    - Fine Prune Tile Lighting (FPTL) [@Mikkelsen2016]に基づく
- タイル16x16に対してFTPLライトリストを作る
    - Fine pruning: いずれかの深度ピクセルがボリューム内にある場合にテストする
    - 偽陽性のアグレッシブな除去
    - タイルあたり1つのライトリスト。スカラレジスタからの属性の読み出しが可能

FPTLの実装
1. FPTLでは、クラスタリングしない16x16のタイルを使う
2. まず平凡な[trivial]AABBテスト(3D)を行う。その後、タイル対境界球テストを行う。big tileではそのAABBテストにおいてxyのみを行うが、FPTLはxyzを行う
3. fine pruningが少なくとも1つの不透明ピクセル/点を真のボリューム内に持たないライト取り除く
    - 偽陽性のアグレッシブな除去だが、不透明でのみ機能する
4. すべての偽陽性が取り除かれる、また、FPTLが不透明専用であることから、タイルあたり1つのリストを書き出す
    - ディファードでは、これはその代わりにライト属性をスカラレジスタから読み出すことができる
    - タイルを処理するすべてのスレッドが同じリストを読むので、ディファードではスレッドdivergenceが起こらない

参考にした論文と比較して何が新しいか:
1. Clustered
2. big tileプリパス
3. 球の輪郭対2Dタイルの高速な重なりテスト

# Clusteredライティング

- 3. 64つのクラスタで32x32のタイルを構築する
    - クラスタの位置とサイズに対して等比級数[geometric series]を用いる
    - 半分のクラスタ(32つ)はニアとタイルあたりの最大深度の間を消費する
        - 可視範囲において良い分解能である
        - タイルあたりの最大深度以降のクエリを許可する
            - パーティクル、ボリューム、エフェクト

Clusteredの実装
1. クラスタの解像度は64つのクラスタを持つ32x32タイルである
2. 正確だが高速なクラスタ対ライトの交差テストを行う --- 球冠付きスポットライトに対してさえも
3. クラスタの位置とサイズを確立するために等比級数を用いる
4. クラスタの半分(32つ)がニア面と不透明の最大深度の間に使われるような、共通比率をタイルあたりに確立する
    - これは、(パーティクル、ボリュームライト、透過エフェクトのようなものに対して)不透明の最大深度以降のクエリを許可しつつ、可視範囲における高度に最適化したクラスタ分解能をもたらす

(3+4) そのタイルにおいて不透明の最大深度に達する回数できっちり半分のクラスタを使い果たすように等比級数に対するパラメータを選択している。

# ライティングアーキテクチャ

- パフォーマンス
    - PS4 @ 1080p

|シーン(マイクロ秒で計測)|フォワードタイル|フォワードクラスタ|
|-|-|-|
|不透明(約30つのパンクチュアルライト、3つのエリアライト、5つの環境ライト)|5675.5|7135.9|

- 注意: MSAAは無視できない影響を持つ可能性がある(ここでは計測していない)

# ライティングアーキテクチャ

- HDRPにおいて
    - 透明マテリアルはクラスタを使う
    - ディファードマテリアルはFPTLを使う
    - フォワード不透明マテリアルはFPTLとクラスタで選べる

# ライティングアーキテクチャ

- タイル/クラスタのパフォーマンス(MSAAなし)
    - 1080p PS4: タイル＋クラスタのリスト生成

エントリコストが高価である: 1ms、1つから10つまでのライトではほぼ同コストだが、上手くスケールする。

# ライティングアーキテクチャ

- VGPR pressureを減らしたい
- ディファードレンダラ[@Coffin2011; @Garawany2016]
    - マテリアルの分類
    - ライトの分類
        - エリアライトを扱うときに大きな利益
    - すべてのバリアントをカバーできない --- ワーストケースが必要
- フォワードレンダラ
    - 暗黙的なマテリアルの分類
    - ライトの分類ができない

# ライティングアーキテクチャ

- 分類のパフォーマンス
    - 1080p PS4 --- ディファードライティングパス

# Gバッファのデザイン

- Gバッファのデザインの設計
    - ブレンディングをサポートしない
        - アグレッシブな圧縮スキームを可能にする
            - 例: 法線を圧縮する
        - ブレンド可能なパラメータの位置による制約を回避する
            - 例: Smoothnessはアルファチャネルに置くことができる
    - 静的なディフューズライティング(ライトマップ/ライトプロブ)
    - 静的なシャドウマスク

静的なディフューズライティングはGバッファパス中にサンプルされる。

# Gバッファのデザイン

|標準|R|G|B|A|
|-|-|-|-|-|
|RT0 RGBA8 sRGB|ベース色.rgb|←|←|スペキュラオクルージョン|
|RT1 RGBA8|法線.xy(八面体 12/12)|←|←|知覚的smoothness|
|RT2 RGBA8|マテリアルデータ|←|←|特徴マスク(3)/マテリアルデータ|
|RT3 RGB111110f|静的ディフューズライティング|←|←|←|
|(任意)RT4 RGBA8|追加のスペキュラオクルージョンデータ|←|アンビエントオクルージョン|ライトレイヤリングマスク|
|(任意)RT5 RGBA8|4つのシャドウマスク|←|←|←|

- RT5がない場合、アンビエントオクルージョンはGバッファパス中に静的ライティングに関して適用される
    - これはSSAOと組み合わせたときのdouble occlusionを暗に示す
- ディファードマテリアル分類はRT2のみを用いる

Xbox Oneでは既定で4RT
ライトレイヤリングはライトの結合であり、一連のオブジェクトとライトの結合を意味する。つまり、これらのオブジェクトにのみ影響を与える。
RT4は動的に割り当てることができる。例えば、インゲームシネマティクスを行うときのみ有効化し、通常のゲームプレイでは無効化することができる。

# 機能的同等性

- エンジンの機能は選択したレンダリングパスによってしばしば変化する
    - SSAOが欲しい？SSRは？ --- ディファードパスを使おう
- HDRPはディファードおよびフォワードマテリアルの混ぜ合わせをサポートする
    - 同じ機能がサポートされる必要がある
- HDRPは最初から機能的同等性を持つよう設計されている

# 機能的同等性

- ディファードおよびフォワードで必要とされる機能
    - ライトリンキングとして知られるライトレイヤリング
        - ライトデータから利用可能なライトマスク
        - ディファード: オブジェクトマスクはRT4に格納する(必要に応じて)
        - フォワード: オブジェクトマスクは定数バッファを使う

ライトレイヤリングはカメラごとに有効化できる。これは、我々が必要な時にのみ追加のRTを割り当てたことを意味する。一般的にはインゲームシネマティクスに対して。
青色のドラゴンは青色のライトによってのみ影響を受け、白色の奴らの中間にある灰色のヤツは反射プロブによって影響を受けない。

# 機能的同等性

- ディファードおよびフォワードで必要とされる機能
    - SSAO、SSR、ディファード法線バイアスシャドウ
        - すなわち、ライティングの機能
        - ライティングパスの前に処理されなければならない

# 機能的同等性

- ディファード: Gバッファからのデータを使う

# 機能的同等性

- ディファード: Gバッファからのデータを使う
- フォワード: 深度プリパスからのデータを出力する

フォワード・パスでは、我々は深度プリパス間のデータを出力する必要がある。注意: 不透明フォワードマテリアルでは、我々はHDRPにおいて常に深度プリパスを処理する。

# 機能的同等性

- ディファード: Gバッファからのデータを使う
- フォワード: 深度プリパスからのデータを出力する
- 同じデータエンコーディングを用いなければならない

|標準|R|G|B|A|
|-|-|-|-|-|
|RT1 RGBA8|法線.xy(八面体 12/12)|←|←|知覚的smoothness|

# 機能的同等性

- ディファードおよびフォワードで必要とされる機能
    - スクリーン空間の表面下散乱(SSSSS)
        - ライティングパスの後に処理されなければならない

# 機能的同等性

- ディファードおよびフォワードで必要とされる機能
    - スクリーン空間の表面下散乱(SSSSS)
        - ライティングパスの後に処理されなければならない
        - 別個のディフューズ(RGB111110f)およびスペキュラライティング(RGBA16f)

# 機能的同等性

- ディファード: Gバッファからのデータを用いる

# 機能的同等性

- ディファード: Gバッファからのデータを用いる
- フォワード: プリパスからのデータを出力する？ --- 高コスト？

プリパス中にSSSデータを出力するとプリパスを高価にするだろう。我々はこれを回避することを優先する。

# 機能的同等性

- ディファード: Gバッファからのデータを用いる
- フォワード: フォワード不透明からのデータを出力する(SSSマテリアル用)

注意: XBox Oneでは、4つの32ビットのRTを維持することを目的とする。これは我々が得るものである。ディフューズ用RTを1つ、スペキュラ用RTを2つ、SSSデータ用RTを1つ。

# 機能的同等性

- ディファード: Gバッファからのデータを用いる
- フォワード: フォワード不透明からのデータを出力する(SSSマテリアル用)
- 同じデータエンコーディングを用いなければならない

|標準|R|G|B|A|
|-|-|-|-|-|
|RT0 RGBA8 sRGB|ベース色.rgb|←|←|スペキュラオクルージョン|

# 機能的同等性

- ディファード: Gバッファからのデータを用いる
- フォワード: フォワード不透明からのデータを出力する(SSSマテリアル用)
- 同じデータエンコーディングを用いなければならない

|標準|R|G|B|A|
|-|-|-|-|-|
|RT0 RGBA8 sRGB|ベース色.rgb|←|←|拡散プロファイル/SSSマスク|

注意: これは後に述べられるが、SSSマテリアルの場合、我々はRT0にスペキュラオクルージョンではなく拡散プロファイルとSSSマスクを格納し、スペキュラオクルージョンはSSSマテリアルではRT2に格納される。

# 不透明マテリアルレンダパス

- ステンシルの使い方
    - ステンシルはフレームの始めで0にクリアされる
    - ディファードマテリアルのtag stencil

# 不透明マテリアルレンダパス

- ステンシルの使い方
    - ディファードライティングパス
    - フォワードマテリアルと空に関してライティングを行わない
    - SplitLightingがタイルごとに行われる

# 不透明マテリアルレンダパス

- ステンシルの使い方
    - SplitLightingに対するフォワード不透明のtag stencil
    - SplitLightingのタグに対してSSSSSを処理する

# 不透明マテリアルレンダパス

- 深度プリパス
    - _
        - ディファードマテリアル: 任意
        - フォワードマテリアル: 法線バッファを出力する
    - Gバッファ
        - 通常ライティングまたは分割[split]ライティングに対するtag stencil
    - シャドウレンダリング
        - ライトリスト生成＋ライト/マテリアル分類と非同期に行う
        - SSAOと非同期に行う(法線バッファを使う)
        - SSRと非同期に行う(法線バッファを使う)
    - ディファード方向性カスケードシャドウ
        - (法線シャドウバイアスのために法線バッファを使う)
- タイルディファードライティング
    - シェーダバリアントごとに間接ディスパッチ
        - ステンシルを読む
            - ライティングなし: フォワードマテリアルと空をスキップする
            - 通常ライティング: ライティングを出力する
            - 分割ライティング: ディフューズとスペキュラを分ける
- フォワード不透明
    - (任意) ベース色＋拡散プロファイルを出力する
    - (任意) 分割ライティングに対して出力＋tag stencilする
- SS表面下散乱
    - 分離ライティングでのステンシルをテストする
    - ライティングを組み合わせる

ここに話してきたパスのすべてがある。これらの詳細には触れないだろうが、興味があれば、スライドはカンファレンスの後に入手できるようになるだろう。

# デカールアーキテクチャ

- 望ましいデカールの機能
    - ディファードとフォワードの両方
    - Gバッファレイアウトに制約されない
    - マテリアル(PBR)と適切にブレンドする
    - 静的ライティングに作用する
    - 透過のサポート
    - Normal orientation fadingのサポート

Normal orientation fadingは引き伸ばされてしまうエッジに沿ったデカールを投影するときにアーティファクトを回避するためにアーティストによって望まれる。Goald^[訳注:Goalsのtypo?]はこの場合にデカールをなめらかにoutすることであるが、これは下地の法線を必要とする。

# デカールアーキテクチャ

- 3つの取り得るアプローチ
    - '古典的'なディファードデカール
        - 直接的にGバッファ内で属性をブレンドする
    - Dバッファ(デカールバッファ)
        - 別のDバッファに属性をブレンドする
        - 通常パスでライティングの前にDバッファを適用する
    - Cluster decals [@Sousa2016]
        - デカールがclusteredライトのようになる
        - 通常パスでライティングの前に適用する

DバッファはUnreal Engine 4で用いられるデカールバッファのアプローチである(私が知る限りこれに関するプレゼンテーションはない)。これはGバッファに似ているがデカール用である。

#

|機能:|ディファードデカール|Dバッファ|クラスタデカール|
|-|-|-|-|
|任意のGバッファレイアウト|<font color="red">No</font>|<font color="green">YES</font>|<font color="green">YES</font>|
|ブレンディングモード|多数(ただし、バリアント地獄)|Lerp|Lerp|
|静的ライティングへの影響|<font color="red">No</font>|<font color="green">YES</font>|<font color="green">YES</font>|
|ディファードおよびフォワードのサポート|<font color="red">No</font>|<font color="green">YES</font>|<font color="green">YES</font>|
|透明物のサポート|<font color="red">No</font>|<font color="red">No</font>|<font color="green">YES</font>|
|デカールメッシュのサポート|<font color="green">YES</font>|<font color="green">YES</font>|<font color="red">No</font>|
|法線フェーディングのサポート|<font color="green">YES</font>|<font color="red">No</font>|<font color="green">YES</font>|

銀の弾丸はない！
注意: 我々はプリパス中にフォワードマテリアルに対して法線バッファを出力する。つまり、我々はフォワードパスに対してDバッファと共に法線フェーディングを行うことができない。

# デカールアーキテクチャ

- HDRPは不透明マテリアルに対してDバッファを使う
    - 完全な深度プリパスを必要とする
    - Gバッファの前にプロジェクタとメッシュデカールをレンダリングする

# Dバッファのデザイン

- Dバッファアプローチはデカールのアルファ合成を用いる
    - 半解像度のパーティクル合成と同じ[@Cantlay2007]
- 別個の属性ブレンディングをサポートする
    - 属性あたりの不透明度
    - AOとMetalに対してパッキングされることに注意する --- 選択式のサポート

||R|G|B|A|
|-|-|-|-|
|RT0 RGBA8 sRGB|ディフューズ色.rgb|←|←|ディフューズの不透明度|
|RT1 RGBA8|法線.rgb|←|←|法線の不透明度|
|RT2 RGBA8|Metallic|AO|Smoothness|Smoothnessの不透明度|
|RT3 RG8(任意)|Metallicの不透明度|←|←|AOの不透明度|

別個の属性ブレンディングをサポートするため、各属性は不透明度を持つ必要がある。ここにDバッファのレイアウトがどのように属性と不透明度をパックしたかを示す。
注意: 乗算ブレンドモードはサポートしていない。我々はlerpのみを用いる。

# デカールアーキテクチャ

- ディファード: Dバッファを使う

# デカールアーキテクチャ

- ディファード: Dバッファを使う
- フォワード: Dバッファを使う

# デカールアーキテクチャ

- ディファード: Dバッファを使う
- フォワード: Dバッファを使う --- DepthPrepassで法線バッファを出力する？
- ライティング機能？

ライティング機能に対して、我々はプリパス中に法線バッファを用いることを思い出して欲しい。しかし、この場合、Dバッファはライティング機能の効果に対して法線に影響を与えない。

# デカールアーキテクチャ

- ディファード: Dバッファを使う
- フォワード: Dバッファを使う --- DepthPrepassで法線バッファを出力する
- Dバッファの後に法線バッファをパッチする

# デカールアーキテクチャ

- ディファード: Dバッファを使う
- フォワード: Dバッファを使う --- DepthPrepassで法線バッファを出力する
- Dバッファの後に法線バッファをパッチする
- 法線バッファのパッチ当てを最適化するのにステンシルを使う

# 不透明マテリアル＋デカールレンダパス

- 深度プリパス
    - _
        - フォワードマテリアル: 法線バッファを出力する
            - DecalNormalに対してtag stencilする
    - Dバッファ
        - Decalに対してtag stencilする
    - 法線バッファをパッチする
        - DecalとDecalNormalに対してステンシルをテストする
    - Gバッファ
        - 通常ライティングまたは分割ライティングのためにtag stencilする
    - シャドウのレンダリング
        - 非同期処理
    - ディファード方向性カスケードシャドウ
        - 法線シャドウバイアスのために法線バッファを使う
- タイルディファードライティング
    - シェーダバリアントごとに間接ディスパッチする
        - ステンシルを読む
            - ライティングなし: フォワードマテリアルと空をスキップする
            - 通常ライティング: ライティングを出力する
            - 分割ライティング: ディフューズとスペキュラを分割する
- フォワード不透明
    - (任意)ベース色＋拡散プロファイルを出力する
    - (任意)分割ライティングを出力する
- SS表面下散乱
    - 分割ライティングに対してステンシルをテストする
    - ライティングを組み合わせる

注意: 今や深度プリパスは必須である。
すべての非同期処理(SSR、SSAO)は削って、非同期処理の題でまとめてある。

これはディファードおよびフォワードの間で機能的同等性が可能となる我々のレンダリングフレームである。

# デカールアーキテクチャ

- HDRPは透明物に対してクラスタデカールを用いる
    - プロジェクタのみ
    - 選択式
    - 別個の属性ブレンディングをサポートする
    - クラスタライトリストのように準備されるクラスタデカールリスト
    - ひとつのアトラスにテクスチャを集める

# デカールアーキテクチャ

- HDRPは透明物に対してクラスタデカールを用いる

GPUライトカリング

クラスタライトリスト
クラスタデカールリスト

フォワード透明パス

デカールごとに
↑
累積する

マテリアル属性に結果を適用する

ライトごとに
↑
物体を計算する

# デカールアーキテクチャ

- HDRPは透明物に対してクラスタデカールを用いる
    - ループ中にデカール修正[modification]を累積する
        - ミップに対して通常のUVを使えない
        - 代わりにワールド空間の位置の微分を用いる

```hlsl
// mipmapのlod計算に後で使うために隣接ピクセルに対してワールド空間のddx/ddyを得る
float positionRWSDdx = ddx(positionRWS);
float positionRWSDdy = ddy(positionRWS);

for (uint i = 0; i < decalCount; i++) {
    DecalData decalData = FetchDecal(decalStart, i);

    // ループ内でサンプリングしているので、mipmapのLODを手動で計算する必要がある
    float3 positionDSDdx = mul(worldToDecal, float4(positionRWSDdx, 0.0)).xyz;
    float3 positionDSDdy = mul(worldToDecal, float4(positionRWSDdy, 0.0)).xyz;

    float2 sampleDiffuseDdx = positionDSDdx.xz * decalData.diffuseScaleBias.xy;  // アトラスのスケールにおけるファクタ
    float2 sampleDiffuseDdy = positionDSDdy.xz * decalData.diffuseScaleBias.xy;
    float lodDiffuse = ComputeTextureLOD(sampleDiffuseDdx, sampleDiffuseDdy, _DecalAtlasResolution);
}
```

それが自明でないクラスタデカールを持つ正しいmipをサンプルするため、我々はデカール空間に変換した位置の微分を用いることができることに注意する。アトラスの座標を担当する[take care of]。

# デカールアーキテクチャ

- GPUデカールのパフォーマンスの数値(エントリコストを強調するための単純なシーン)


Decal offはデカールのコードを取り除いた状態を意味する。この目標は0つのデカールがあるときとデカールのコードがないときとでDバッファおよびクラスタアプローチによって誘発するオーバーヘッドを計測することである。
現在我々のアプローチで見られるように、誘発する追加コストは無視できるようなものではない。しかし、これは上手くスケールする。透明マテリアルはデカールを受けるかどうかを選択できる。
Dバッファアプローチでは、我々は多少のパフォーマンスを節約する'デカール分類'の追加ステップを処理する。

これらの計測結果は複数の単純なオブジェクトからなるシーンで行われた。これは複数のテクスチャをフェッチする必要があるデカールは多くを傷つけることを意味する。マテリアルが大量のALUを持ち、すでにいくつものテクスチャをフェッチする複雑なレイヤリングを伴う現実世界のシーンでは、デカールオフとデカールゼロの差異は些細なものである。
また、ここで示される追加コストはシーン全体に対してのものである。

# 不透明マテリアルレンダパス

- 追加の最適化
    - ディファード方向性カスケードシャドウ
        - スクリーン空間でカスケードシャドウマップを投影する
        - ライティングパスの外側でより良いwavefront占有率
    - 不透明なアルファテストされるマテリアルを最適化する
        - プリパス中に不透明アルファテストをレンダリングする
        - アルファテストを無効化して、Gバッファまたはフォワード中にZ-equalを使う

パフォーマンス数値でのテストシーンは様々な草木＋いくつかのテッセレーションを伴う複雑にレイヤー化された地面を持つFountainebleauデモの一般的なエリアである。

# マテリアル

# HDRPのBRDF

- Litシェーダ
    - HDRPのデフォルトシェーダ
    - ディファードマテリアル(フォワードマテリアルに切り替え可能)
    - マテリアル機能のまとめ

# HDRPのBRDF

- Litシェーダ
    - ディフューズ項: Disneyディフューズとして知られるBurleyのディフューズ[@Burley2012]
    - ベース色/メタリックによるパラメータ化

# HDRPのBRDF

- Litシェーダ
    - ディフューズ項: Disneyのディフューズとして知られるBurleyのディフューズ[@Burley2012]
    - ディフューズ色/スペキュラ色によるパラメータ化

# HDRPのBRDF

- Litシェーダ
    - SSS項: DisneyのSSS

# HDRPのBRDF

- Litシェーダ
    - 半透明項: Disneyのディフューズに基づく

# HDRPのBRDF

- Litシェーダ
    - スペキュラ項: 多重散乱[multiscattering]の等方的GGX[@Heitz2016]

# HDRPのBRDF

- Litシェーダ
    - スペキュラ項: 多重散乱の異方的GGX[@Heitz2014]
        - ハック

# HDRPのBRDF

- Litシェーダ
    - 玉虫色[iridescence]項: フレネル項を置き換える[@Belcour2017]

# HDRPのBRDF

- Litシェーダ
    - クリアコートのスペキュラ項: 多重散乱の等方的GGX
        - ハック

# HDRPのBRDF

- Litシェーダ
    - HDRPにおけるマテリアルID: マテリアル機能のビットマスク
    - 例: 標準＋半透明
    - 例: 標準＋クリアコート＋異方性
    - 例: 標準＋玉虫色＋表面下散乱
- Gバッファ制約
    - ストレージ容量のための排他的なマテリアル機能
    - 玉虫色、異方性、表面下散乱/半透明

# Gバッファのデザイン

- 標準

|標準|R|G|B|A|
|-|-|-|-|-|
|RT0 RGBA8 sRGB|ベース色.rgb|←|←|スペキュラオクルージョン|
|RT1 RGBA8|法線.xy(八面体 12/12)|←|←|知覚的smoothness|
|RT2 RGBA8|フレネル0.rgb|←|←|機能マスク(3)/塗装マスク(3)|

- クリアコートはすべてのバリアントで利用可能
- メタリックなし --- フレネル0に展開する[decompress]
    - 最適化＋両方のパラメータ化(メタリック/スペキュラ色)を扱う

# 異方性

- 異方的GGX[@Heitz2014]
    - 高さ相関の可視性項付き
    - 単純化[@McAuley2015]＋最適化

```hlsl
// roughnessT -> tangent方向におけるラフネス
// roughnessB -> bitangent方向におけるラフネス
float D_GGXAnisoNoPI(float TdotH, float BdotH, float NdotH, float roughnessT, float roughnessB) {
    float a2 = roughnessT * roughnessB;
    float3 v = float3(roughnessB * TdotH, roughnessT * BdotH, a2 * NdotH);
    float s = dot(v, v);

    return INV_PI * a2 * (a2 / s) * (a2 / s);
}

float V_smithJointGGXAniso(float TdotV, float BdotV, float NdotV, float TdotL, float BdotL, float NdotL, float roughnessT, float roughnessB) {
    real lambdaV = NdotL * length(float3(roughnessT * TdotV, roughnessB * BdotV, NdotV));
    real lambdaL = NdotV * length(float3(roughnessT * TdotL, roughnessB * BdotL, NdotL));

    return 0.5 / (lambdaV + lambdaL);
}
```

# 異方性

- [@Kulla2017]の異方性パラメータ化を用いる

```hlsl
roughnessT = roughness * (1 + anisotropy);
roughnessB = roughness * (1 - anisotropy);
```

- [@Revie2011; @McAuley2015]由来の法線ベクトルのハックを再検討する
    - tangentおよびbitangentの伸縮[stretching]をサポートする
    - IBLテクスチャMIPをフェッチするためにラフネスの使い方を修正する
    - マジックナンバーを目測する[eye-ball]

```hlsl
// 異方比[anisotropic ratio](0 -> 等方性なし、1 -> tangent方向における完全な異方性) --- 正だとbitangentWSを使う --- 負だとtangentWSを使う
void GetGGXAnisotropicModifiedNormalAndRoughness(float3 bitangentWS, float3 tangentWS, float3 N, float3 V, float anisotropy, float perceptualRoughness) {
    // 正の異方性の値では: tangent = highlight stretch(異方性)の方向、bitangent = grain (brush)の方向
    float3 grainDirWS = (anisotropy >= 0.0) ? bitangentWS : tangentWS;
    // (perceptualRoughness < 0.2)で伸縮を減らす
    float stretch = abs(anisotropy) * saturate(1.5 * sqrt(perceptualRoughness));
    // grain方向(例、髪やbrushの方向)は法線と直交すると仮定する
    float3 B = cross(grainDirWS, V);
    float3 grainNormal = cross(B, grainDirWS);
    iblN = normalize(lerp(N, grainNormal, stretch));
    iblPerceptualRoughness = perceptualRoughness * saturate(1.2 - abs(anisotropy));
}
```

ハックは純粋に経験則的である☺

# 法線ベクトルのハック

伸縮を確認するためにこの較正キューブマップを用いる。
異方性は左から右へ: -1から1
知覚的smoothnessは下から上へ: 1から0

# リファレンス(エンジン内)

かなり不正確に見えるが、高周波なキューブマップでは…

# 法線ベクトルのハック

大丈夫そうであり、(遠くから)リファレンスのように見ることができるであろうものがほとんどである。

# リファレンス(エンジン内)

将来的に、我々はこのハックの代わりに異方的フィルタリングで行いたいと考えている。

# Gバッファのデザイン

- 異方性

|異方性|R|G|B|A|
|-|-|-|-|-|
|RT0 RGBA8 sRGB|ベース色.rgb|←|←|スペキュラオクルージョン|
|RT1 RGBA8|法線.xy(八面体 12/12)|←|←|知覚的smoothness|
|RT2 RGBA8|異方性|tangent frame angle(11)/メタリック(5)|←|機能マスク(3)/塗装マスク(3)|

- 実際のtangent frameとデフォルトのそれとの間の角度を用いる

```hlsl
// tangent frameをエンコードする
// デフォルトのtangent frameを再構築する
float3x3 frame = GetLocalFrame(normalWS);
// デフォルトのそれに関して実際のtangent frameの回転角を計算する
float sinFrame = dot(tangentWS, frame[1]);
float cosFrame = dot(tangetnWS, frame[0]);
uint storeSin = abs(sinFrame) < abs(cosFrame) ? 4 : 0;
uint quadrant ((sinFrame < 0) ? 1 : 0) | ((cosFrame < 0) ? 2 : 0);
// sin[とcos]は最大で[後の]45度で近似的に線形である
float sinOrCos = min(abs(sinFrame), abs(cosFrame)) * sqrt(2);
outGBuffer2.rgb = float3(surfaceData.anisotropy * 0.5 + 0.5, sinOrCos, PackFloatInt8bit(metallic, storeSin | quadrant, 8));
```

```hlsl
// tangent frameをデコードする
float unused;
uint tangentFlags;
UnpackFloatInt8bit(inGBuffer2.b, 8, unused, tangentFlags);
// デフォルトのそれに関して実際のtangent frameの回転角を得る
uint quadrant = tangentFlags;
uint storeSin = tangentFlags & 4;
float sinOrCos = inGBuffer2.g * rsqrt(2);
float cosOrSin = sqrt(1 - sinOrCos * sinOrCos);
float sinFrame = storeSin ? sinOrCos : cosOrSin;
float cosFrame = storeSin ? cosOrSin : sinOrCos;
sinFrame = (quadrant & 1) ? -sinFrame : sinFrame;
cosFrame = (quadrant & 2) ? -cosFrame : cosFrame;
// 法線のまわりで再構築されたtangentを回転する
tangentWS = sinFrame * frame[1] + cosFrame * frame[0];
bitangentWS = cross(frame[2], frame[0]);
```

# クリアコート

- 物理的でない --- 単純化されたアプローチ
    - ベースの上にある等方的GGX
    - 1.5の固定された屈折率(0.04のF0)と0.03のラフネス
    - 塗装の界面を計算に入れたF0でベースのスペキュラを計算する
        - ゲームでは入力のF0(つまり、スペキュラ色)によるSchlick Fresnelを使った
            - ゲームにおけるF0は空気の界面(屈折率1)で計算される

# クリアコート

- 誘電体では、以下で塗装の界面(屈折率1.5)に対してベースのF0を適合させられる

```hlsl
float IorToFresnel0(float transmittedIor, float incidentIor) {
    return Sq((transmittedIor - incidentIor) / (transmittedIor + incidentIor));
}

float Fresnel0ToIor(float f0) {
    return ((1.0 + sqrt(f0)) / (1.0 - sqrt(f0)));
}

float ConvertF0ForAirInterfaceToF0ForClearCoat15(float f0) {
    return IorToFresnel0(Fresnel0ToIor(f0), 1.5);
}

// 最適化: 範囲[0.04(0を返すべき), 1(1を返すべき)]に対する関数(3 mad)のフィッティング
float ConvertF0ForAirInterfaceToF0ForClearCoat15Fast(float f0) {
    return saturate(-0.0256868 + f0 * (0.326846 + (0.978946 - 0.283835 * f0) * f0));
}
```

- 導体では、スペクトル的複素屈折率[spectral complex IOR]の畳み込みを必要とする
- アイデア
    - 屈折率1.5の界面に対するリファレンスを計算する[@Lagarde2011]
    - 導体に対して上記の式と比較してみる

# クリアコート

- そのコストが実行時パフォーマンスに対してそれほど悪くないと仮定すれば
    - より低い値で誤差が増加する
    - クリアコートが有効化されるときにベースのF0を更新するためにこのアプローチを使う

# クリアコート

- すべてのライトタイプに対して
    - 塗装の界面を計算に入れたF0を持つベースのスペキュラを計算する
    - クリアコートに対してフレネル項を計算する
    - ベースに関する近似的なエネルギー保存則を適用する
    - ベースのスペキュラに塗装のスペキュラ寄与を追加する

```hlsl
baseF0 = ConvertF0ForAirInterfaceToF0ForClearCoat15Fast(fresnel0);
(...)  // BaseSpecularの計算

float coatF = F_Schlick(CLEAR_COAT_F0, LdotH);
baseSpecular *= Sq(1.0 - coartF);  // 交差する界面の出入りに対してベースのスペキュラをスケールする
float DV = DV_SmithJointGGX(NdotH, NdotL, NdotV, CLEAR_COAT_ROUGHNESS);
baseSpecular += coatF * DV;
```

- IBL: NdotVによるSchlick Fresnelを使う＋追加のIBLフェッチ

エリアライトは追加のLTC計算を使う。
将来的に、我々は、我々のstacklitシェーダアプローチに基づいた、より物理的な方法を用いるだろう。

#

# 多重散乱GGX

- エネルギー保存を改善する
    - GGX式における多重散乱の欠落
        - furnace test(一様なHDRI)における最大60%の光の喪失(rough case)
- 現在のトレンドは追加の埋め合わせ[compensation]項で近似することである
    - [@Kulla2017; @Hill2018]

# 多重散乱GGX

- [@Heitz2016]はground truthな挙動をもたらす
    - より荒くなると、ディフューズとスペキュラの両方がより飽和する
    - シミュレーションはバウンスローブが似ていることを示している
        - 単一散乱GGXでのスケールファクタで十分であることを暗示している

# 多重散乱GGX

- Emmanuel Turquinの功績
- スケールファクタはFresnelに依存しなければならない
- $\rho(\omega_o, \omega_i) = \rho_{ss}(\omega_o, \omega_i) + F_{ms} k_{ms}(\omega_o) \rho_{ss}(\omega_o, \omega_i)$
- ここで、$k_{ms}(\omega_o) = \frac{1 - E_{ss}(\omega_o)}{E_{ss(\omega_o)}}$であり、$E_{ss}(\omega_o) = \int_{\Omega_i} \rho(\omega_o, \omega_i) |\omega_i \cdot n| d\omega_i$である
- フレネル項はHDRPにおいてコサイン加重平均Schlick Fresnelである
    - $F_{ms} \approx F_{ss} = 2 \int_0^1 F(\mu) \mu d\mu = \frac{(1+20F_0)}{21} \approx F_0$

$$
F_{ms} \approx F_{ss} = 2 \int_{0}^{1} F(\mu)\mu \mathrm{d}{\mu} = \frac{(1 + 20 F_0)}{21} \approx F_0 \\
E_{ss}({\omega_o}) = \int_{\Omega_i} \rho({\omega_o}, {\omega_i}) |{\omega_i \cdot n}| \mathrm{d}{\omega_i} \\
k_{ms}({\omega_o}) = {\frac{1 - E_{ss}({\omega_o})}{E_{ss}({\omega_o})}} \\
\rho(\omega_o, \omega_i) = \rho_{ss}(\omega_o, \omega_i) + F_{ms} k_{ms}(\omega_o) \rho_{ss}(\omega_o, \omega_i)
$$

# 多重散乱GGX

- 直接および間接の両方のスペキュラにライトループの最後でファクタを適用する
    - オリジナルのGGXローブのスケールとして機能する
    - $E_{ss}(\omega_o)$をテクスチャに格納する。キューブマップの事前統合で共有する

```hlsl
specularLighting = lighting.direct.specular + lighting.indirect.specularReflected;
// y = Integral{(BSDF / F) * <N, L> dw}
float3 preFGD = SAMPLE_TEXTURE2D_LOD(_PreIntegratedFGD_GGXDisneyDiffuse, s_linear_clamp_sampler, float2(NdotV, perceptualRoughness), 0).xyz;
// 多重散乱を計算に入れるためにGGXを再スケールする
specularLighting *= 1.0 + fresnel0 * ((1.0 / reflectivity) - 1.0);
```

- ディフューズ項に対しては多重散乱はない
    - Disneyのディフューズは経験則的であり、エネルギー保存的ではない
        - ラフネスを増やしても暗くならない

#

多重散乱なし
１行目は純白の誘電体 --- ここでディフューズ項はDisneyのディフューズである
２行目はF0 = 1 --- 導体
３行目はF0 = 金 --- 導体
４行目はF0 = 銅 --- 導体

#

多重散乱あり
１行目は純白の誘電体 --- ここでディフューズ項はDisneyのディフューズである
２行目はF0 = 1 --- 導体
３行目はF0 = 金 --- 導体
４行目はF0 = 銅 --- 導体

#

多重散乱なし
１行目は純白の誘電体 --- ここでディフューズ項はDisneyのディフューズである
２行目はF0 = 1 --- 導体
３行目はF0 = 金 --- 導体
４行目はF0 = 銅 --- 導体

#

多重散乱あり
１行目は純白の誘電体 --- ここでディフューズ項はDisneyのディフューズである
２行目はF0 = 1 --- 導体
３行目はF0 = 金 --- 導体
４行目はF0 = 銅 --- 導体

#

多重散乱なしでの異方性

#

多重散乱ありでの異方性

#

多重散乱なしでの異方性 => 伸縮ハック付きの偽の異方性を用いているので、上記の見た目は異方性なしの場合ときっかり同じである。

#

多重散乱ありでの異方性は完璧にエネルギー保存している！全体としては偽物であるが、見た目は悪くない。

# 多重散乱GGX

- 検証のためにMitsubaと比較させた
- 注意: Mitsubaは金のスペクトル的複素屈折率を使う＋相互反射がある

上がHDRP、下がMitsuba
Mitsubaとの比較はそれほど悪くない。しかし、Mitsubaはより正確で光輸送(球の中での球の反射)を含む方法であるので、公平な比較を行うことはそう単純ではない。

# マテリアル最適化

TODO
