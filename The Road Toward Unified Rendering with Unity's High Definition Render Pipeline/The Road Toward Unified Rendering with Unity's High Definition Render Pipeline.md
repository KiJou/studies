---
title: The Road Toward Unified Rendering with Unity's High Definition Render Pipeline [@Lagarde2018]
---
# The Road Toward Unified Rendering with Unity's High Definition Render Pipeline

# HDレンダリングパイプラインのデザイン目標

- クロスプラットフォーム
    - PC (DX11, DX12, Vulkan)、XBox One、PS4、Mac (Metal)
- 至るところに物理ベースレンダリング
- 統一されたライティング
    - 不透明、透明、ボリューメトリックで同じライティング機能
- 一貫性のあるライティング
    - すべてのライトタイプがすべてのマテリアルで、および、大域照明で機能する
    - 可能な限りdouble lighting / double occlusionを回避する

# レンダリングパイプラインアーキテクチャ

# レンダリングパイプラインアーキテクチャ

- 重要な要素:
    - ライティングおよびマテリアルのアーキテクチャ
    - Gバッファのデザイン
    - フォワード/ディファードパスの機能的同等性[features parity] (*機能的同等性[features parity]*として知られる)
    - デカールのアーキテクチャ
- 以下によってフォローアップする
    - マテリアルの概要
    - ボリューメトリックライティング

# ライティングアーキテクチャ

- ライティングアーキテクチャは*可視*のシーンのライトでのループによって定義される

光源ごとに
↑
物体を評価する

# ライティングアーキテクチャ

- ライティングアーキテクチャは*可視*のシーンのライトでのループによって定義される

光源ごとに　　　⇦ライトのループはCPUの"マルチパス"かGPUの"シングルパス"で行うことができる
↑
物体を評価する
⇧
GPUで評価する

# ライティングアーキテクチャ

- ライティングアーキテクチャは*可視*のシーンのライトでのループによって定義される

光源ごとに
↑
物体を評価する

GPUやCPUパスのどちらかに対するライト区画構造[partitioning structure] (タイル、クラスタ…)によって最適化できる

そのようなループはマテリアルに影響を与えないライトを取り除くCPUやGPUの助けによって最適化できる

# ライティングアーキテクチャ

- ライティングアーキテクチャは*可視*のシーンのライトでのループによって定義される

光源ごとに
↑
物体を評価する

ディファードやフォワードレンダラでは同じ
マテリアル特性の源のみが異なる

このライトループはディファードでもフォワードでも概念的に同一であることに注意する。マテリアルの特性の源のみが異なる。ディファードでは、Gバッファに由来し、フォワードでは、オブジェクトのユニフォーム/テクスチャに由来する。

# ライティングアーキテクチャ

- ライティングアーキテクチャは*可視*のシーンのライトでのループによって定義される

光源、太陽、IBLごとに
↑
物体を評価する

# ライティングアーキテクチャ

- ライティングアーキテクチャは*可視*のシーンのライトでのループによって定義される

光源ごとに
↑
物体を評価する

太陽ごとに
↑
物体を評価する

IBLごとに
↑
物体を評価する

パフォーマンス上の理由により、ゲームではしばしばライトタイプとマテリアル評価応答[evaluation response]との結合が存在する。例えば、我々はマテリアルのライトモデルによってIBLを事前計算する。
つまり、我々はライトタイプごとに1つのループを行う必要がある。

# ライティングアーキテクチャ

- ライティングアーキテクチャは*可視*のシーンのライトでのループによって定義される

光源ごとに
↑
物体を評価する

太陽ごとに
↑　　　　　　　　　　　　⇦別個のパスで計算したりしなかったり
物体を評価する

IBLごとに
↑
物体を評価する

この種のライトタイプループは時折異なる呼び出しに分割され、パフォーマンスが変化するかもしれない。

# ライティングアーキテクチャ

- HDRPにおけるあるGPUライトループ(太陽、パンクチュアル、エリア、IBL、空)

光源ごとに
↑
物体を評価する

太陽ごとに
↑
物体を評価する

IBLごとに
↑
物体を評価する

HDRPにおいて、我々はすべてのライトタイプで単一のライトループを用いる。太陽、大きさのないライト(スポット、ポイント)、エリアライト、空がある。

# ライティングアーキテクチャ

- ディファードパス

HDRPはディファードとフォワードの両方のレンダラをサポートする。ディファードレンダラの例を見ていこう。Gバッファを満たすディファードマテリアルが1つと使う透明マテリアルが1つある。
同じライトループ。統一されたライティング。

# ライティングアーキテクチャ

- フォワードパス

フォワードレンダリングの例。フォワードの不透明および透明マテリアルがある。

# ライティングアーキテクチャ

- ディファードおよびフォワードの混合パス

HDRPは同時にフォワードとディファード両方をサポートしてもいる。この場合、ディファードパスで見てきたものに加えて、フォワードの不透明マテリアルもある。

# ライティングアーキテクチャ

- 完全なフォワードに切り替え可能

# マテリアルアーキテクチャ

- アーティストフレンドリーなデータ VS エンジンデータ

このスキーマはディファードおよびフォワードアーキテクチャで機能するためにHDRPにおいてマテリアルを記述する方法を示している。これらはガイドラインである。そして、我々はアーティストフレンドリーなデータとエンジンフレンドリーなデータの概念を導入する。
Uiかシェーダグラフでアーティストが埋めた入力をアーティストフレンドリーなデータとしよう。smoothnessのようなやつ。我々はライティングエンジンが使えるエンジンデータへの変換関数を追加する(例えば、ラフネス)。
Gバッファは単なる中間ストレージである。これは圧縮可能である。
HDRPのマテリアルはライティングアーキテクチャに合わせるためにこのマテリアルガイドラインに従う必要がある。

# ライティングアーキテクチャ

- 復習

光源ごとに
↑
物体を評価する

太陽ごとに
↑
物体を評価する

IBLごとに
↑
物体を評価する

# ライティングアーキテクチャ

- ボリューメトリックマテリアルでは

光源ごとに
↑
ボリュームを評価する

太陽ごとに
↑
ボリュームを評価する

IBLごとに
↑
ボリュームを評価する

ボリューメトリックでは、その概念は、代わりにボリューメトリックマテリアル(吸収、散乱)を用いたことを除いて、きっかり同じである。

# ライティングアーキテクチャ

- ボリューメトリックマテリアルでは

Gバッファと同様に、我々は計算のためのボリューメトリックマテリアルの入力としてVバッファを用いる。

# ライティングアーキテクチャ

- 実践では: より低い分解能[resolution]でライティングパスを分割する

そして、実践において、我々はライティングパスを分割し、froxelのセルごとに計算し、その後、別個のパスで不透明および透明マテリアルに結果を適用する。

# ライティングアーキテクチャ

- タイルおよびクラスタの両方のアプローチで最適化する
- 目標
    - 偽陽性を取り除くことに焦点を当てる
        - 例: 狭いシャドウをキャストするスポットライト
    - 偽陽性はライティングパスにおいてより高価である
        - ライトカリングはシャドウレンダリング中に非同期に実行する
        - ディファードライティングパスは非同期に実行していない
        - 隠せる所にコストを移す
        - ライティングパスにおける高いregister pressure

1. 球冠[sphere cap]付きスポットライトにも対応するアグレッシブ(だが高速)な偽陽性の除去を重要視する
    - スポットライトはしばしばシャドウをキャストし、狭いので、重要である
    - 基本的な境界球テストを用いたリスト構築は極めて不十分[highly insufficient]である
2. すべてのリスト構築の処理は非同期コンピュートの活用によって吸収される
3. 偽陽性は早めにやるよりライティング中に扱ったほうがもっと高価である
    - 最終ライティングシェーダはより高いループの複雑さとより大きなregister pressureを持つ
    - 最終ライティングシェーダはシャドウマップのレンダリングの間に非同期コンピュートを活用できない
4. そのリストはディファードでもフォワードでもその両方でも使える
5. リストはライティング中のスレッドdivergenceを減らすのに役立つタイプによる順序を保持するための増加するインデックスのためにもたらされる。

# ライティングアーキテクチャ

- 階層的なアプローチ
    1. 可視ライトごとにスクリーン空間のAABBを求める
    2. Big tile 64x64 prepass
        - 粗い交差テスト
    3. タイルまたはクラスタのライトリストを構築する
        - 狭い交差テスト

1. 可視ライトごとにスクリーン空間AABBを求める
2. Big tile 64x64 tile pre-pass. 初期の早期脱出[early out]のためにAABBを使う(2Dで、深度なし)
    - タイルと凸包との厳密な交差テストで追跡調査する
    - 追加のテスト基準[criteria]として境界球を使う(ポイントライトと球冠付きスポットライトで役立つ)

基本的に、最初にAABBパスが来て、その後、AABBパスが生成したものを使うbig tileパスが来て、その後、big tileパスだけでなくAABBパスが生成したものを両方使うFPTLやClusteredのリスト構築パスが来る。FPTLとClusteredの両方はbig tileプリパスで生成されたオーバーラップし得るタイルのリストを用いる。
これら両方はbig tileプリパスからのリストに残っていることをテストするためにAABBを用いる。
凸包は、2つのスケール値を持つ以外は、いわゆるOBBである。なので、我々は、角錐[pyramid]や楔[wedge]のどちらかを作るために、別個の軸XとYに沿って4つの頂点をしぼる[squeeze]ことができる。スケールを1.0に設定すると、それは単なるOBBであり、1.0より小さくすると、内側にすスケールする。両方を限界まで小さくすると角錐になり、片方だけだと楔型になる。境界球はスポットライトの球冠部分をもたらすのに役立つ。OOBと2つのスケール値は凸包として使うものだが、我々はより多くのタイルを除外するための追加の制約として境界球も用いる。これは、ポイントライトだけでなく球冠に対しても重要である。FPTLおよびClusteredでは、64x64タイルごとにbig tileパスで生成されたものをリストとしてループする。これら両方はまずリストに対してAABBを確認し、LDSに粗いリストを作り上げる。これら両方は境界球の輪郭が粗いリストにおけるライトごとにタイルと重なるかどうかの確認によって追跡調査する。最後にFPTLは詳細な剪定を行い、Clusteredは残りのリストに対してクラスタを確認する。
big tileプリパスがAABBを確認するとき、それは2Dであり、64x64のタイルに対してである。FPTLがそれを行うとき、一例として、3DのAABBテストであり、16x16のタイルに対してである。

FPTLでは、それは、不透明ピクセルをカバーするために必要であるのみなので、とりわけタイトである。つまり、我々は交差テストに最大/最小深度を含めることによってその早期パスだけで大量に除外できる。big tileはAABBテストにおいてXYを行う。FPTLはXYZを行う。タイルに対する球のオーバーラップはすべての場合で2Dのオーバーラップテストである。しかし、もちろん、それがより小さなタイルであることから、こまごましたもの[little extra]を取り除くことができる。なので、私は、Clusteredではかなり安価であるので、再びそのテストを行うことに決めた。2回目のAABBテストは依然として2Dであるが、64x64ではなく32x32で実行するので、こまごましたものを剪定する。そして、それは非常に高速なテストである。

#

# Tiledライティング

- 3. タイル16x16
    - Fine Prune Tile Lighting (FPTL) [@Mikkelsen2016]に基づく
- タイル16x16に対してFTPLライトリストを作る
    - Fine pruning: いずれかの深度ピクセルがボリューム内にある場合にテストする
    - 偽陽性のアグレッシブな除去
    - タイルあたり1つのライトリスト。スカラレジスタからの属性の読み出しが可能

FPTLの実装
1. FPTLでは、クラスタリングしない16x16のタイルを使う
2. まず平凡な[trivial]AABBテスト(3D)を行う。その後、タイル対境界球テストを行う。big tileではそのAABBテストにおいてxyのみを行うが、FPTLはxyzを行う
3. fine pruningが少なくとも1つの不透明ピクセル/点を真のボリューム内に持たないライト取り除く
    - 偽陽性のアグレッシブな除去だが、不透明でのみ機能する
4. すべての偽陽性が取り除かれる、また、FPTLが不透明専用であることから、タイルあたり1つのリストを書き出す
    - ディファードでは、これはその代わりにライト属性をスカラレジスタから読み出すことができる
    - タイルを処理するすべてのスレッドが同じリストを読むので、ディファードではスレッドdivergenceが起こらない

参考にした論文と比較して何が新しいか:
1. Clustered
2. big tileプリパス
3. 球の輪郭対2Dタイルの高速な重なりテスト

# Clusteredライティング

- 3. 64つのクラスタで32x32のタイルを構築する
    - クラスタの位置とサイズに対して等比級数[geometric series]を用いる
    - 半分のクラスタ(32つ)はニアとタイルあたりの最大深度の間を消費する
        - 可視範囲において良い分解能である
        - タイルあたりの最大深度以降のクエリを許可する
            - パーティクル、ボリューム、エフェクト

Clusteredの実装
1. クラスタの解像度は64つのクラスタを持つ32x32タイルである
2. 正確だが高速なクラスタ対ライトの交差テストを行う --- 球冠付きスポットライトに対してさえも
3. クラスタの位置とサイズを確立するために等比級数を用いる
4. クラスタの半分(32つ)がニア面と不透明の最大深度の間に使われるような、共通比率をタイルあたりに確立する
    - これは、(パーティクル、ボリュームライト、透過エフェクトのようなものに対して)不透明の最大深度以降のクエリを許可しつつ、可視範囲における高度に最適化したクラスタ分解能をもたらす

(3+4) そのタイルにおいて不透明の最大深度に達する回数できっちり半分のクラスタを使い果たすように等比級数に対するパラメータを選択している。

# ライティングアーキテクチャ

- パフォーマンス
    - PS4 @ 1080p

|シーン(マイクロ秒で計測)|フォワードタイル|フォワードクラスタ|
|-|-|-|
|不透明(約30つのパンクチュアルライト、3つのエリアライト、5つの環境ライト)|5675.5|7135.9|

- 注意: MSAAは無視できない影響を持つ可能性がある(ここでは計測していない)

# ライティングアーキテクチャ

- HDRPにおいて
    - 透明マテリアルはクラスタを使う
    - ディファードマテリアルはFPTLを使う
    - フォワード不透明マテリアルはFPTLとクラスタで選べる

# ライティングアーキテクチャ

- タイル/クラスタのパフォーマンス(MSAAなし)
    - 1080p PS4: タイル＋クラスタのリスト生成

エントリコストが高価である: 1ms、1つから10つまでのライトではほぼ同コストだが、上手くスケールする。

# ライティングアーキテクチャ

- VGPR pressureを減らしたい
- ディファードレンダラ[@Coffin2011; @Garawany2016]
    - マテリアルの分類
    - ライトの分類
        - エリアライトを扱うときに大きな利益
    - すべてのバリアントをカバーできない --- ワーストケースが必要
- フォワードレンダラ
    - 暗黙的なマテリアルの分類
    - ライトの分類ができない

# ライティングアーキテクチャ

- 分類のパフォーマンス
    - 1080p PS4 --- ディファードライティングパス

# Gバッファのデザイン

- Gバッファのデザインの設計
    - ブレンディングをサポートしない
        - アグレッシブな圧縮スキームを可能にする
            - 例: 法線を圧縮する
        - ブレンド可能なパラメータの位置による制約を回避する
            - 例: Smoothnessはアルファチャネルに置くことができる
    - 静的なディフューズライティング(ライトマップ/ライトプロブ)
    - 静的なシャドウマスク

静的なディフューズライティングはGバッファパス中にサンプルされる。

# Gバッファのデザイン

|標準|R|G|B|A|
|-|-|-|-|-|
|RT0 RGBA8 sRGB|ベース色.rgb|←|←|スペキュラオクルージョン|
|RT1 RGBA8|法線.xy(八面体 12/12)|←|←|知覚的smoothness|
|RT2 RGBA8|マテリアルデータ|←|←|特徴マスク(3)/マテリアルデータ|
|RT3 RGB111110f|静的ディフューズライティング|←|←|←|
|(任意)RT4 RGBA8|追加のスペキュラオクルージョンデータ|←|アンビエントオクルージョン|ライトレイヤリングマスク|
|(任意)RT5 RGBA8|4つのシャドウマスク|←|←|←|

- RT5がない場合、アンビエントオクルージョンはGバッファパス中に静的ライティングに関して適用される
    - これはSSAOと組み合わせたときのdouble occlusionを暗に示す
- ディファードマテリアル分類はRT2のみを用いる

Xbox Oneでは既定で4RT
ライトレイヤリングはライトの結合であり、一連のオブジェクトとライトの結合を意味する。つまり、これらのオブジェクトにのみ影響を与える。
RT4は動的に割り当てることができる。例えば、インゲームシネマティクスを行うときのみ有効化し、通常のゲームプレイでは無効化することができる。

# 機能的同等性

- エンジンの機能は選択したレンダリングパスによってしばしば変化する
    - SSAOが欲しい？SSRは？ --- ディファードパスを使おう
- HDRPはディファードおよびフォワードマテリアルの混ぜ合わせをサポートする
    - 同じ機能がサポートされる必要がある
- HDRPは最初から機能的同等性を持つよう設計されている

# 機能的同等性

- ディファードおよびフォワードで必要とされる機能
    - ライトリンキングとして知られるライトレイヤリング
        - ライトデータから利用可能なライトマスク
        - ディファード: オブジェクトマスクはRT4に格納する(必要に応じて)
        - フォワード: オブジェクトマスクは定数バッファを使う

ライトレイヤリングはカメラごとに有効化できる。これは、我々が必要な時にのみ追加のRTを割り当てたことを意味する。一般的にはインゲームシネマティクスに対して。
青色のドラゴンは青色のライトによってのみ影響を受け、白色の奴らの中間にある灰色のヤツは反射プロブによって影響を受けない。

# 機能的同等性

- ディファードおよびフォワードで必要とされる機能
    - SSAO、SSR、ディファード法線バイアスシャドウ
        - すなわち、ライティングの機能
        - ライティングパスの前に処理されなければならない

# 機能的同等性

- ディファード: Gバッファからのデータを使う

# 機能的同等性

- ディファード: Gバッファからのデータを使う
- フォワード: 深度プリパスからのデータを出力する

フォワード・パスでは、我々は深度プリパス間のデータを出力する必要がある。注意: 不透明フォワードマテリアルでは、我々はHDRPにおいて常に深度プリパスを処理する。

# 機能的同等性

- ディファード: Gバッファからのデータを使う
- フォワード: 深度プリパスからのデータを出力する
- 同じデータエンコーディングを用いなければならない

|標準|R|G|B|A|
|-|-|-|-|-|
|RT1 RGBA8|法線.xy(八面体 12/12)|←|←|知覚的smoothness|

# 機能的同等性

- ディファードおよびフォワードで必要とされる機能
    - スクリーン空間の表面下散乱(SSSSS)
        - ライティングパスの後に処理されなければならない

# 機能的同等性

- ディファードおよびフォワードで必要とされる機能
    - スクリーン空間の表面下散乱(SSSSS)
        - ライティングパスの後に処理されなければならない
        - 別個のディフューズ(RGB111110f)およびスペキュラライティング(RGBA16f)

# 機能的同等性

- ディファード: Gバッファからのデータを用いる

# 機能的同等性

- ディファード: Gバッファからのデータを用いる
- フォワード: プリパスからのデータを出力する？ --- 高コスト？

プリパス中にSSSデータを出力するとプリパスを高価にするだろう。我々はこれを回避することを優先する。

# 機能的同等性

- ディファード: Gバッファからのデータを用いる
- フォワード: フォワード不透明からのデータを出力する(SSSマテリアル用)

注意: XBox Oneでは、4つの32ビットのRTを維持することを目的とする。これは我々が得るものである。ディフューズ用RTを1つ、スペキュラ用RTを2つ、SSSデータ用RTを1つ。

# 機能的同等性

- ディファード: Gバッファからのデータを用いる
- フォワード: フォワード不透明からのデータを出力する(SSSマテリアル用)
- 同じデータエンコーディングを用いなければならない

|標準|R|G|B|A|
|-|-|-|-|-|
|RT0 RGBA8 sRGB|ベース色.rgb|←|←|スペキュラオクルージョン|

# 機能的同等性

- ディファード: Gバッファからのデータを用いる
- フォワード: フォワード不透明からのデータを出力する(SSSマテリアル用)
- 同じデータエンコーディングを用いなければならない

|標準|R|G|B|A|
|-|-|-|-|-|
|RT0 RGBA8 sRGB|ベース色.rgb|←|←|拡散プロファイル/SSSマスク|

注意: これは後に述べられるが、SSSマテリアルの場合、我々はRT0にスペキュラオクルージョンではなく拡散プロファイルとSSSマスクを格納し、スペキュラオクルージョンはSSSマテリアルではRT2に格納される。

# 不透明マテリアルレンダパス

- ステンシルの使い方
    - ステンシルはフレームの始めで0にクリアされる
    - ディファードマテリアルのtag stencil

# 不透明マテリアルレンダパス

- ステンシルの使い方
    - ディファードライティングパス
    - フォワードマテリアルと空に関してライティングを行わない
    - SplitLightingがタイルごとに行われる

# 不透明マテリアルレンダパス

- ステンシルの使い方
    - SplitLightingに対するフォワード不透明のtag stencil
    - SplitLightingのタグに対してSSSSSを処理する

# 不透明マテリアルレンダパス

- 深度プリパス
    - _
        - ディファードマテリアル: 任意
        - フォワードマテリアル: 法線バッファを出力する
    - Gバッファ
        - 通常ライティングまたは分割[split]ライティングに対するtag stencil
    - シャドウレンダリング
        - ライトリスト生成＋ライト/マテリアル分類と非同期に行う
        - SSAOと非同期に行う(法線バッファを使う)
        - SSRと非同期に行う(法線バッファを使う)
    - ディファード方向性カスケードシャドウ
        - (法線シャドウバイアスのために法線バッファを使う)
- タイルディファードライティング
    - シェーダバリアントごとに間接ディスパッチ
        - ステンシルを読む
            - ライティングなし: フォワードマテリアルと空をスキップする
            - 通常ライティング: ライティングを出力する
            - 分割ライティング: ディフューズとスペキュラを分ける
- フォワード不透明
    - (任意) ベース色＋拡散プロファイルを出力する
    - (任意) 分割ライティングに対して出力＋tag stencilする
- SS表面下散乱
    - 分離ライティングでのステンシルをテストする
    - ライティングを組み合わせる

ここに話してきたパスのすべてがある。これらの詳細には触れないだろうが、興味があれば、スライドはカンファレンスの後に入手できるようになるだろう。

# デカールアーキテクチャ

TODO
