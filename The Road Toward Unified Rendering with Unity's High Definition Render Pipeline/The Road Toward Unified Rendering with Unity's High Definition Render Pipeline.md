---
title: The Road Toward Unified Rendering with Unity's High Definition Render Pipeline [@Lagarde2018]
---
# The Road Toward Unified Rendering with Unity's High Definition Render Pipeline

# HDレンダリングパイプラインのデザイン目標

- クロスプラットフォーム
    - PC (DX11, DX12, Vulkan)、XBox One、PS4、Mac (Metal)
- 至るところに物理ベースレンダリング
- 統一されたライティング
    - 不透明、透明、ボリューメトリックで同じライティング機能
- 一貫性のあるライティング
    - すべてのライトタイプがすべてのマテリアルで、および、大域照明で機能する
    - 可能な限りdouble lighting / double occlusionを回避する

# レンダリングパイプラインアーキテクチャ

# レンダリングパイプラインアーキテクチャ

- 重要な要素:
    - ライティングおよびマテリアルのアーキテクチャ
    - Gバッファのデザイン
    - フォワード/ディファードパスの機能的同等性[features parity] (*機能的同等性[features parity]*として知られる)
    - デカールのアーキテクチャ
- 以下によってフォローアップする
    - マテリアルの概要
    - ボリューメトリックライティング

# ライティングアーキテクチャ

- ライティングアーキテクチャは*可視*のシーンのライトでのループによって定義される

光源ごとに
↑
物体を評価する

# ライティングアーキテクチャ

- ライティングアーキテクチャは*可視*のシーンのライトでのループによって定義される

光源ごとに　　　⇦ライトのループはCPUの"マルチパス"かGPUの"シングルパス"で行うことができる
↑
物体を評価する
⇧
GPUで評価する

# ライティングアーキテクチャ

- ライティングアーキテクチャは*可視*のシーンのライトでのループによって定義される

光源ごとに
↑
物体を評価する

GPUやCPUパスのどちらかに対するライト区画構造[partitioning structure] (タイル、クラスタ…)によって最適化できる

そのようなループはマテリアルに影響を与えないライトを取り除くCPUやGPUの助けによって最適化できる

# ライティングアーキテクチャ

- ライティングアーキテクチャは*可視*のシーンのライトでのループによって定義される

光源ごとに
↑
物体を評価する

ディファードやフォワードレンダラでは同じ
マテリアル特性の源のみが異なる

このライトループはディファードでもフォワードでも概念的に同一であることに注意する。マテリアルの特性の源のみが異なる。ディファードでは、Gバッファに由来し、フォワードでは、オブジェクトのユニフォーム/テクスチャに由来する。

# ライティングアーキテクチャ

- ライティングアーキテクチャは*可視*のシーンのライトでのループによって定義される

光源、太陽、IBLごとに
↑
物体を評価する

# ライティングアーキテクチャ

- ライティングアーキテクチャは*可視*のシーンのライトでのループによって定義される

光源ごとに
↑
物体を評価する

太陽ごとに
↑
物体を評価する

IBLごとに
↑
物体を評価する

パフォーマンス上の理由により、ゲームではしばしばライトタイプとマテリアル評価応答[evaluation response]との結合が存在する。例えば、我々はマテリアルのライトモデルによってIBLを事前計算する。
つまり、我々はライトタイプごとに1つのループを行う必要がある。

# ライティングアーキテクチャ

- ライティングアーキテクチャは*可視*のシーンのライトでのループによって定義される

光源ごとに
↑
物体を評価する

太陽ごとに
↑　　　　　　　　　　　　⇦別個のパスで計算したりしなかったり
物体を評価する

IBLごとに
↑
物体を評価する

この種のライトタイプループは時折異なる呼び出しに分割され、パフォーマンスが変化するかもしれない。

# ライティングアーキテクチャ

- HDRPにおけるあるGPUライトループ(太陽、パンクチュアル、エリア、IBL、空)

光源ごとに
↑
物体を評価する

太陽ごとに
↑
物体を評価する

IBLごとに
↑
物体を評価する

HDRPにおいて、我々はすべてのライトタイプで単一のライトループを用いる。太陽、大きさのないライト(スポット、ポイント)、エリアライト、空がある。

# ライティングアーキテクチャ

- ディファードパス

HDRPはディファードとフォワードの両方のレンダラをサポートする。ディファードレンダラの例を見ていこう。Gバッファを満たすディファードマテリアルが1つと使う透明マテリアルが1つある。
同じライトループ。統一されたライティング。

# ライティングアーキテクチャ

- フォワードパス

フォワードレンダリングの例。フォワードの不透明および透明マテリアルがある。

# ライティングアーキテクチャ

- ディファードおよびフォワードの混合パス

HDRPは同時にフォワードとディファード両方をサポートしてもいる。この場合、ディファードパスで見てきたものに加えて、フォワードの不透明マテリアルもある。

# ライティングアーキテクチャ

- 完全なフォワードに切り替え可能

# マテリアルアーキテクチャ

- アーティストフレンドリーなデータ VS エンジンデータ

このスキーマはディファードおよびフォワードアーキテクチャで機能するためにHDRPにおいてマテリアルを記述する方法を示している。これらはガイドラインである。そして、我々はアーティストフレンドリーなデータとエンジンフレンドリーなデータの概念を導入する。
Uiかシェーダグラフでアーティストが埋めた入力をアーティストフレンドリーなデータとしよう。smoothnessのようなやつ。我々はライティングエンジンが使えるエンジンデータへの変換関数を追加する(例えば、ラフネス)。
Gバッファは単なる中間ストレージである。これは圧縮可能である。
HDRPのマテリアルはライティングアーキテクチャに合わせるためにこのマテリアルガイドラインに従う必要がある。

# ライティングアーキテクチャ

- 復習

光源ごとに
↑
物体を評価する

太陽ごとに
↑
物体を評価する

IBLごとに
↑
物体を評価する

# ライティングアーキテクチャ

- ボリューメトリックマテリアルでは

光源ごとに
↑
ボリュームを評価する

太陽ごとに
↑
ボリュームを評価する

IBLごとに
↑
ボリュームを評価する

ボリューメトリックでは、その概念は、代わりにボリューメトリックマテリアル(吸収、散乱)を用いたことを除いて、きっかり同じである。

# ライティングアーキテクチャ

- ボリューメトリックマテリアルでは

Gバッファと同様に、我々は計算のためのボリューメトリックマテリアルの入力としてVバッファを用いる。

# ライティングアーキテクチャ

- 実践では: より低い分解能[resolution]でライティングパスを分割する

そして、実践において、我々はライティングパスを分割し、froxelのセルごとに計算し、その後、別個のパスで不透明および透明マテリアルに結果を適用する。

# ライティングアーキテクチャ

- タイルおよびクラスタの両方のアプローチで最適化する
- 目標
    - 偽陽性を取り除くことに焦点を当てる
        - 例: 狭いシャドウをキャストするスポットライト
    - 偽陽性はライティングパスにおいてより高価である
        - ライトカリングはシャドウレンダリング中に非同期に実行する
        - ディファードライティングパスは非同期に実行していない
        - 隠せる所にコストを移す
        - ライティングパスにおける高いregister pressure

1. 球冠[sphere cap]付きスポットライトにも対応するアグレッシブ(だが高速)な偽陽性の除去を重要視する
    - スポットライトはしばしばシャドウをキャストし、狭いので、重要である
    - 基本的な境界球テストを用いたリスト構築は極めて不十分[highly insufficient]である
2. すべてのリスト構築の処理は非同期コンピュートの活用によって吸収される
3. 偽陽性は早めにやるよりライティング中に扱ったほうがもっと高価である
    - 最終ライティングシェーダはより高いループの複雑さとより大きなregister pressureを持つ
    - 最終ライティングシェーダはシャドウマップのレンダリングの間に非同期コンピュートを活用できない
4. そのリストはディファードでもフォワードでもその両方でも使える
5. リストはライティング中のスレッドdivergenceを減らすのに役立つタイプによる順序を保持するための増加するインデックスのためにもたらされる。

# ライティングアーキテクチャ

- 階層的なアプローチ
    1. 可視ライトごとにスクリーン空間のAABBを求める
    2. Big tile 64x64 prepass
        - 粗い交差テスト
    3. タイルまたはクラスタのライトリストを構築する
        - 狭い交差テスト

1. 可視ライトごとにスクリーン空間AABBを求める
2. Big tile 64x64 tile pre-pass. 初期の早期脱出[early out]のためにAABBを使う(2Dで、深度なし)
    - タイルと凸包との厳密な交差テストで追跡調査する
    - 追加のテスト基準[criteria]として境界球を使う(ポイントライトと球冠付きスポットライトで役立つ)

基本的に、最初にAABBパスが来て、その後、AABBパスが生成したものを使うbig tileパスが来て、その後、big tileパスだけでなくAABBパスが生成したものを両方使うFPTLやClusteredのリスト構築パスが来る。FPTLとClusteredの両方はbig tileプリパスで生成されたオーバーラップし得るタイルのリストを用いる。
これら両方はbig tileプリパスからのリストに残っていることをテストするためにAABBを用いる。
凸包は、2つのスケール値を持つ以外は、いわゆるOBBである。なので、我々は、角錐[pyramid]や楔[wedge]のどちらかを作るために、別個の軸XとYに沿って4つの頂点をしぼる[squeeze]ことができる。スケールを1.0に設定すると、それは単なるOBBであり、1.0より小さくすると、内側にすスケールする。両方を限界まで小さくすると角錐になり、片方だけだと楔型になる。境界球はスポットライトの球冠部分をもたらすのに役立つ。OOBと2つのスケール値は凸包として使うものだが、我々はより多くのタイルを除外するための追加の制約として境界球も用いる。これは、ポイントライトだけでなく球冠に対しても重要である。FPTLおよびClusteredでは、64x64タイルごとにbig tileパスで生成されたものをリストとしてループする。これら両方はまずリストに対してAABBを確認し、LDSに粗いリストを作り上げる。これら両方は境界球の輪郭が粗いリストにおけるライトごとにタイルと重なるかどうかの確認によって追跡調査する。最後にFPTLは詳細な剪定を行い、Clusteredは残りのリストに対してクラスタを確認する。
big tileプリパスがAABBを確認するとき、それは2Dであり、64x64のタイルに対してである。FPTLがそれを行うとき、一例として、3DのAABBテストであり、16x16のタイルに対してである。

FPTLでは、それは、不透明ピクセルをカバーするために必要であるのみなので、とりわけタイトである。つまり、我々は交差テストに最大/最小深度を含めることによってその早期パスだけで大量に除外できる。big tileはAABBテストにおいてXYを行う。FPTLはXYZを行う。タイルに対する球のオーバーラップはすべての場合で2Dのオーバーラップテストである。しかし、もちろん、それがより小さなタイルであることから、こまごましたもの[little extra]を取り除くことができる。なので、私は、Clusteredではかなり安価であるので、再びそのテストを行うことに決めた。2回目のAABBテストは依然として2Dであるが、64x64ではなく32x32で実行するので、こまごましたものを剪定する。そして、それは非常に高速なテストである。

#

# Tiledライティング

- 3. タイル16x16
    - Fine Prune Tile Lighting (FPTL) [@Mikkelsen2016]に基づく
- タイル16x16に対してFTPLライトリストを作る
    - Fine pruning: いずれかの深度ピクセルがボリューム内にある場合にテストする
    - 偽陽性のアグレッシブな除去
    - タイルあたり1つのライトリスト。スカラレジスタからの属性の読み出しが可能

FPTLの実装
1. FPTLでは、クラスタリングしない16x16のタイルを使う
2. まず平凡な[trivial]AABBテスト(3D)を行う。その後、タイル対境界球テストを行う。big tileではそのAABBテストにおいてxyのみを行うが、FPTLはxyzを行う
3. fine pruningが少なくとも1つの不透明ピクセル/点を真のボリューム内に持たないライト取り除く
    - 偽陽性のアグレッシブな除去だが、不透明でのみ機能する
4. すべての偽陽性が取り除かれる、また、FPTLが不透明専用であることから、タイルあたり1つのリストを書き出す
    - ディファードでは、これはその代わりにライト属性をスカラレジスタから読み出すことができる
    - タイルを処理するすべてのスレッドが同じリストを読むので、ディファードではスレッドdivergenceが起こらない

参考にした論文と比較して何が新しいか:
1. Clustered
2. big tileプリパス
3. 球の輪郭対2Dタイルの高速な重なりテスト

# Clusteredライティング

- 3. 64つのクラスタで32x32のタイルを構築する
    - クラスタの位置とサイズに対して等比級数[geometric series]を用いる
    - 半分のクラスタ(32つ)はニアとタイルあたりの最大深度の間を消費する
        - 可視範囲において良い分解能である
        - タイルあたりの最大深度以降のクエリを許可する
            - パーティクル、ボリューム、エフェクト

Clusteredの実装
1. クラスタの解像度は64つのクラスタを持つ32x32タイルである
2. 正確だが高速なクラスタ対ライトの交差テストを行う --- 球冠付きスポットライトに対してさえも
3. クラスタの位置とサイズを確立するために等比級数を用いる
4. クラスタの半分(32つ)がニア面と不透明の最大深度の間に使われるような、共通比率をタイルあたりに確立する
    - これは、(パーティクル、ボリュームライト、透過エフェクトのようなものに対して)不透明の最大深度以降のクエリを許可しつつ、可視範囲における高度に最適化したクラスタ分解能をもたらす

(3+4) そのタイルにおいて不透明の最大深度に達する回数できっちり半分のクラスタを使い果たすように等比級数に対するパラメータを選択している。

# ライティングアーキテクチャ

- パフォーマンス
    - PS4 @ 1080p

|シーン(マイクロ秒で計測)|フォワードタイル|フォワードクラスタ|
|-|-|-|
|不透明(約30つのパンクチュアルライト、3つのエリアライト、5つの環境ライト)|5675.5|7135.9|

- 注意: MSAAは無視できない影響を持つ可能性がある(ここでは計測していない)

# ライティングアーキテクチャ

- HDRPにおいて
    - 透明マテリアルはクラスタを使う
    - ディファードマテリアルはFPTLを使う
    - フォワード不透明マテリアルはFPTLとクラスタで選べる

# ライティングアーキテクチャ

- タイル/クラスタのパフォーマンス(MSAAなし)
    - 1080p PS4: タイル＋クラスタのリスト生成

エントリコストが高価である: 1ms、1つから10つまでのライトではほぼ同コストだが、上手くスケールする。

# ライティングアーキテクチャ

- VGPR pressureを減らしたい
- ディファードレンダラ[@Coffin2011; @Garawany2016]
    - マテリアルの分類
    - ライトの分類
        - エリアライトを扱うときに大きな利益
    - すべてのバリアントをカバーできない --- ワーストケースが必要
- フォワードレンダラ
    - 暗黙的なマテリアルの分類
    - ライトの分類ができない

# ライティングアーキテクチャ

- 分類のパフォーマンス
    - 1080p PS4 --- ディファードライティングパス

# Gバッファのデザイン

- Gバッファのデザインの設計
    - ブレンディングをサポートしない
        - アグレッシブな圧縮スキームを可能にする
            - 例: 法線を圧縮する
        - ブレンド可能なパラメータの位置による制約を回避する
            - 例: Smoothnessはアルファチャネルに置くことができる
    - 静的なディフューズライティング(ライトマップ/ライトプロブ)
    - 静的なシャドウマスク

静的なディフューズライティングはGバッファパス中にサンプルされる。

# Gバッファのデザイン

|標準|R|G|B|A|
|-|-|-|-|-|
|RT0 RGBA8 sRGB|ベース色.rgb|←|←|スペキュラオクルージョン|
|RT1 RGBA8|法線.xy(八面体 12/12)|←|←|知覚的smoothness|
|RT2 RGBA8|マテリアルデータ|←|←|特徴マスク(3)/マテリアルデータ|
|RT3 RGB111110f|静的ディフューズライティング|←|←|←|
|(任意)RT4 RGBA8|追加のスペキュラオクルージョンデータ|←|アンビエントオクルージョン|ライトレイヤリングマスク|
|(任意)RT5 RGBA8|4つのシャドウマスク|←|←|←|

- RT5がない場合、アンビエントオクルージョンはGバッファパス中に静的ライティングに関して適用される
    - これはSSAOと組み合わせたときのdouble occlusionを暗に示す
- ディファードマテリアル分類はRT2のみを用いる

Xbox Oneでは既定で4RT
ライトレイヤリングはライトの結合であり、一連のオブジェクトとライトの結合を意味する。つまり、これらのオブジェクトにのみ影響を与える。
RT4は動的に割り当てることができる。例えば、インゲームシネマティクスを行うときのみ有効化し、通常のゲームプレイでは無効化することができる。

# 機能的同等性

- エンジンの機能は選択したレンダリングパスによってしばしば変化する
    - SSAOが欲しい？SSRは？ --- ディファードパスを使おう
- HDRPはディファードおよびフォワードマテリアルの混ぜ合わせをサポートする
    - 同じ機能がサポートされる必要がある
- HDRPは最初から機能的同等性を持つよう設計されている

# 機能的同等性

- ディファードおよびフォワードで必要とされる機能
    - ライトリンキングとして知られるライトレイヤリング
        - ライトデータから利用可能なライトマスク
        - ディファード: オブジェクトマスクはRT4に格納する(必要に応じて)
        - フォワード: オブジェクトマスクは定数バッファを使う

ライトレイヤリングはカメラごとに有効化できる。これは、我々が必要な時にのみ追加のRTを割り当てたことを意味する。一般的にはインゲームシネマティクスに対して。
青色のドラゴンは青色のライトによってのみ影響を受け、白色の奴らの中間にある灰色のヤツは反射プロブによって影響を受けない。

# 機能的同等性

- ディファードおよびフォワードで必要とされる機能
    - SSAO、SSR、ディファード法線バイアスシャドウ
        - すなわち、ライティングの機能
        - ライティングパスの前に処理されなければならない

# 機能的同等性

- ディファード: Gバッファからのデータを使う

# 機能的同等性

- ディファード: Gバッファからのデータを使う
- フォワード: 深度プリパスからのデータを出力する

フォワード・パスでは、我々は深度プリパス間のデータを出力する必要がある。注意: 不透明フォワードマテリアルでは、我々はHDRPにおいて常に深度プリパスを処理する。

# 機能的同等性

- ディファード: Gバッファからのデータを使う
- フォワード: 深度プリパスからのデータを出力する
- 同じデータエンコーディングを用いなければならない

|標準|R|G|B|A|
|-|-|-|-|-|
|RT1 RGBA8|法線.xy(八面体 12/12)|←|←|知覚的smoothness|

# 機能的同等性

- ディファードおよびフォワードで必要とされる機能
    - スクリーン空間の表面下散乱(SSSSS)
        - ライティングパスの後に処理されなければならない

# 機能的同等性

- ディファードおよびフォワードで必要とされる機能
    - スクリーン空間の表面下散乱(SSSSS)
        - ライティングパスの後に処理されなければならない
        - 別個のディフューズ(RGB111110f)およびスペキュラライティング(RGBA16f)

# 機能的同等性

- ディファード: Gバッファからのデータを用いる

# 機能的同等性

- ディファード: Gバッファからのデータを用いる
- フォワード: プリパスからのデータを出力する？ --- 高コスト？

プリパス中にSSSデータを出力するとプリパスを高価にするだろう。我々はこれを回避することを優先する。

# 機能的同等性

- ディファード: Gバッファからのデータを用いる
- フォワード: フォワード不透明からのデータを出力する(SSSマテリアル用)

注意: XBox Oneでは、4つの32ビットのRTを維持することを目的とする。これは我々が得るものである。ディフューズ用RTを1つ、スペキュラ用RTを2つ、SSSデータ用RTを1つ。

# 機能的同等性

- ディファード: Gバッファからのデータを用いる
- フォワード: フォワード不透明からのデータを出力する(SSSマテリアル用)
- 同じデータエンコーディングを用いなければならない

|標準|R|G|B|A|
|-|-|-|-|-|
|RT0 RGBA8 sRGB|ベース色.rgb|←|←|スペキュラオクルージョン|

# 機能的同等性

- ディファード: Gバッファからのデータを用いる
- フォワード: フォワード不透明からのデータを出力する(SSSマテリアル用)
- 同じデータエンコーディングを用いなければならない

|標準|R|G|B|A|
|-|-|-|-|-|
|RT0 RGBA8 sRGB|ベース色.rgb|←|←|拡散プロファイル/SSSマスク|

注意: これは後に述べられるが、SSSマテリアルの場合、我々はRT0にスペキュラオクルージョンではなく拡散プロファイルとSSSマスクを格納し、スペキュラオクルージョンはSSSマテリアルではRT2に格納される。

# 不透明マテリアルレンダパス

- ステンシルの使い方
    - ステンシルはフレームの始めで0にクリアされる
    - ディファードマテリアルのtag stencil

# 不透明マテリアルレンダパス

- ステンシルの使い方
    - ディファードライティングパス
    - フォワードマテリアルと空に関してライティングを行わない
    - SplitLightingがタイルごとに行われる

# 不透明マテリアルレンダパス

- ステンシルの使い方
    - SplitLightingに対するフォワード不透明のtag stencil
    - SplitLightingのタグに対してSSSSSを処理する

# 不透明マテリアルレンダパス

- 深度プリパス
    - _
        - ディファードマテリアル: 任意
        - フォワードマテリアル: 法線バッファを出力する
    - Gバッファ
        - 通常ライティングまたは分割[split]ライティングに対するtag stencil
    - シャドウレンダリング
        - ライトリスト生成＋ライト/マテリアル分類と非同期に行う
        - SSAOと非同期に行う(法線バッファを使う)
        - SSRと非同期に行う(法線バッファを使う)
    - ディファード方向性カスケードシャドウ
        - (法線シャドウバイアスのために法線バッファを使う)
- タイルディファードライティング
    - シェーダバリアントごとに間接ディスパッチ
        - ステンシルを読む
            - ライティングなし: フォワードマテリアルと空をスキップする
            - 通常ライティング: ライティングを出力する
            - 分割ライティング: ディフューズとスペキュラを分ける
- フォワード不透明
    - (任意) ベース色＋拡散プロファイルを出力する
    - (任意) 分割ライティングに対して出力＋tag stencilする
- SS表面下散乱
    - 分離ライティングでのステンシルをテストする
    - ライティングを組み合わせる

ここに話してきたパスのすべてがある。これらの詳細には触れないだろうが、興味があれば、スライドはカンファレンスの後に入手できるようになるだろう。

# デカールアーキテクチャ

- 望ましいデカールの機能
    - ディファードとフォワードの両方
    - Gバッファレイアウトに制約されない
    - マテリアル(PBR)と適切にブレンドする
    - 静的ライティングに作用する
    - 透過のサポート
    - Normal orientation fadingのサポート

Normal orientation fadingは引き伸ばされてしまうエッジに沿ったデカールを投影するときにアーティファクトを回避するためにアーティストによって望まれる。Goald^[訳注:Goalsのtypo?]はこの場合にデカールをなめらかにoutすることであるが、これは下地の法線を必要とする。

# デカールアーキテクチャ

- 3つの取り得るアプローチ
    - '古典的'なディファードデカール
        - 直接的にGバッファ内で属性をブレンドする
    - Dバッファ(デカールバッファ)
        - 別のDバッファに属性をブレンドする
        - 通常パスでライティングの前にDバッファを適用する
    - Cluster decals [@Sousa2016]
        - デカールがclusteredライトのようになる
        - 通常パスでライティングの前に適用する

DバッファはUnreal Engine 4で用いられるデカールバッファのアプローチである(私が知る限りこれに関するプレゼンテーションはない)。これはGバッファに似ているがデカール用である。

|機能:|ディファードデカール|Dバッファ|クラスタデカール|
|-|-|-|-|
|任意のGバッファレイアウト|<font color="red">No</font>|<font color="green">YES</font>|<font color="green">YES</font>|
|ブレンディングモード|多数(ただし、バリアント地獄)|Lerp|Lerp|
|静的ライティングへの影響|<font color="red">No</font>|<font color="green">YES</font>|<font color="green">YES</font>|
|ディファードおよびフォワードのサポート|<font color="red">No</font>|<font color="green">YES</font>|<font color="green">YES</font>|
|透明物のサポート|<font color="red">No</font>|<font color="red">No</font>|<font color="green">YES</font>|
|デカールメッシュのサポート|<font color="green">YES</font>|<font color="green">YES</font>|<font color="red">No</font>|
|法線フェーディングのサポート|<font color="green">YES</font>|<font color="red">No</font>|<font color="green">YES</font>|

銀の弾丸はない！
注意: 我々はプリパス中にフォワードマテリアルに対して法線バッファを出力する。つまり、我々はフォワードパスに対してDバッファと共に法線フェーディングを行うことができない。

# デカールアーキテクチャ

- HDRPは不透明マテリアルに対してDバッファを使う
    - 完全な深度プリパスを必要とする
    - Gバッファの前にプロジェクタとメッシュデカールをレンダリングする

# Dバッファのデザイン

- Dバッファアプローチはデカールのアルファ合成を用いる
    - 半解像度のパーティクル合成と同じ[@Cantlay2007]
- 別個の属性ブレンディングをサポートする
    - 属性あたりの不透明度
    - AOとMetalに対してパッキングされることに注意する --- 選択式のサポート

||R|G|B|A|
|-|-|-|-|
|RT0 RGBA8 sRGB|ディフューズ色.rgb|←|←|ディフューズの不透明度|
|RT1 RGBA8|法線.rgb|←|←|法線の不透明度|
|RT2 RGBA8|Metallic|AO|Smoothness|Smoothnessの不透明度|
|RT3 RG8(任意)|Metallicの不透明度|←|←|AOの不透明度|

別個の属性ブレンディングをサポートするため、各属性は不透明度を持つ必要がある。ここにDバッファのレイアウトがどのように属性と不透明度をパックしたかを示す。
注意: 乗算ブレンドモードはサポートしていない。我々はlerpのみを用いる。

# デカールアーキテクチャ

- ディファード: Dバッファを使う

# デカールアーキテクチャ

- ディファード: Dバッファを使う
- フォワード: Dバッファを使う

# デカールアーキテクチャ

- ディファード: Dバッファを使う
- フォワード: Dバッファを使う --- DepthPrepassで法線バッファを出力する？
- ライティング機能？

ライティング機能に対して、我々はプリパス中に法線バッファを用いることを思い出して欲しい。しかし、この場合、Dバッファはライティング機能の効果に対して法線に影響を与えない。

# デカールアーキテクチャ

- ディファード: Dバッファを使う
- フォワード: Dバッファを使う --- DepthPrepassで法線バッファを出力する
- Dバッファの後に法線バッファをパッチする

# デカールアーキテクチャ

- ディファード: Dバッファを使う
- フォワード: Dバッファを使う --- DepthPrepassで法線バッファを出力する
- Dバッファの後に法線バッファをパッチする
- 法線バッファのパッチ当てを最適化するのにステンシルを使う

# 不透明マテリアル＋デカールレンダパス

- 深度プリパス
    - _
        - フォワードマテリアル: 法線バッファを出力する
            - DecalNormalに対してtag stencilする
    - Dバッファ
        - Decalに対してtag stencilする
    - 法線バッファをパッチする
        - DecalとDecalNormalに対してステンシルをテストする
    - Gバッファ
        - 通常ライティングまたは分割ライティングのためにtag stencilする
    - シャドウのレンダリング
        - 非同期処理
    - ディファード方向性カスケードシャドウ
        - 法線シャドウバイアスのために法線バッファを使う
- タイルディファードライティング
    - シェーダバリアントごとに間接ディスパッチする
        - ステンシルを読む
            - ライティングなし: フォワードマテリアルと空をスキップする
            - 通常ライティング: ライティングを出力する
            - 分割ライティング: ディフューズとスペキュラを分割する
- フォワード不透明
    - (任意)ベース色＋拡散プロファイルを出力する
    - (任意)分割ライティングを出力する
- SS表面下散乱
    - 分割ライティングに対してステンシルをテストする
    - ライティングを組み合わせる

注意: 今や深度プリパスは必須である。
すべての非同期処理(SSR、SSAO)は削って、非同期処理の題でまとめてある。

これはディファードおよびフォワードの間で機能的同等性が可能となる我々のレンダリングフレームである。

# デカールアーキテクチャ

- HDRPは透明物に対してクラスタデカールを用いる
    - プロジェクタのみ
    - 選択式
    - 別個の属性ブレンディングをサポートする
    - クラスタライトリストのように準備されるクラスタデカールリスト
    - ひとつのアトラスにテクスチャを集める

# デカールアーキテクチャ

- HDRPは透明物に対してクラスタデカールを用いる

GPUライトカリング

クラスタライトリスト
クラスタデカールリスト

フォワード透明パス

デカールごとに
↑
累積する

マテリアル属性に結果を適用する

ライトごとに
↑
物体を計算する

# デカールアーキテクチャ

- HDRPは透明物に対してクラスタデカールを用いる
    - ループ中にデカール修正[modification]を累積する
        - ミップに対して通常のUVを使えない
        - 代わりにワールド空間の位置の微分を用いる

```hlsl
// mipmapのlod計算に後で使うために隣接ピクセルに対してワールド空間のddx/ddyを得る
float positionRWSDdx = ddx(positionRWS);
float positionRWSDdy = ddy(positionRWS);

for (uint i = 0; i < decalCount; i++) {
    DecalData decalData = FetchDecal(decalStart, i);

    // ループ内でサンプリングしているので、mipmapのLODを手動で計算する必要がある
    float3 positionDSDdx = mul(worldToDecal, float4(positionRWSDdx, 0.0)).xyz;
    float3 positionDSDdy = mul(worldToDecal, float4(positionRWSDdy, 0.0)).xyz;

    float2 sampleDiffuseDdx = positionDSDdx.xz * decalData.diffuseScaleBias.xy;  // アトラスのスケールにおけるファクタ
    float2 sampleDiffuseDdy = positionDSDdy.xz * decalData.diffuseScaleBias.xy;
    float lodDiffuse = ComputeTextureLOD(sampleDiffuseDdx, sampleDiffuseDdy, _DecalAtlasResolution);
}
```

それが自明でないクラスタデカールを持つ正しいmipをサンプルするため、我々はデカール空間に変換した位置の微分を用いることができることに注意する。アトラスの座標を担当する[take care of]。

# デカールアーキテクチャ

- GPUデカールのパフォーマンスの数値(エントリコストを強調するための単純なシーン)


Decal offはデカールのコードを取り除いた状態を意味する。この目標は0つのデカールがあるときとデカールのコードがないときとでDバッファおよびクラスタアプローチによって誘発するオーバーヘッドを計測することである。
現在我々のアプローチで見られるように、誘発する追加コストは無視できるようなものではない。しかし、これは上手くスケールする。透明マテリアルはデカールを受けるかどうかを選択できる。
Dバッファアプローチでは、我々は多少のパフォーマンスを節約する'デカール分類'の追加ステップを処理する。

これらの計測結果は複数の単純なオブジェクトからなるシーンで行われた。これは複数のテクスチャをフェッチする必要があるデカールは多くを傷つけることを意味する。マテリアルが大量のALUを持ち、すでにいくつものテクスチャをフェッチする複雑なレイヤリングを伴う現実世界のシーンでは、デカールオフとデカールゼロの差異は些細なものである。
また、ここで示される追加コストはシーン全体に対してのものである。

# 不透明マテリアルレンダパス

- 追加の最適化
    - ディファード方向性カスケードシャドウ
        - スクリーン空間でカスケードシャドウマップを投影する
        - ライティングパスの外側でより良いwavefront占有率
    - 不透明なアルファテストされるマテリアルを最適化する
        - プリパス中に不透明アルファテストをレンダリングする
        - アルファテストを無効化して、Gバッファまたはフォワード中にZ-equalを使う

パフォーマンス数値でのテストシーンは様々な草木＋いくつかのテッセレーションを伴う複雑にレイヤー化された地面を持つFountainebleauデモの一般的なエリアである。

# マテリアル

# HDRPのBRDF

TODO
