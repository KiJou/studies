---
title: The Road Toward Unified Rendering with Unity's High Definition Render Pipeline [@Lagarde2018]
---
# The Road Toward Unified Rendering with Unity's High Definition Render Pipeline

# HDレンダリングパイプラインのデザイン目標

- クロスプラットフォーム
    - PC (DX11, DX12, Vulkan)、XBox One、PS4、Mac (Metal)
- 至るところに物理ベースレンダリング
- 統一されたライティング
    - 不透明、透明、ボリューメトリックで同じライティング機能
- 一貫性のあるライティング
    - すべてのライトタイプがすべてのマテリアルで、および、大域照明で機能する
    - 可能な限りdouble lighting / double occlusionを回避する

# レンダリングパイプラインアーキテクチャ

# レンダリングパイプラインアーキテクチャ

- 重要な要素:
    - ライティングおよびマテリアルのアーキテクチャ
    - Gバッファのデザイン
    - フォワード/ディファードパスの機能的同等性[features parity] (*機能的同等性[features parity]*として知られる)
    - デカールのアーキテクチャ
- 以下によってフォローアップする
    - マテリアルの概要
    - ボリューメトリックライティング

# ライティングアーキテクチャ

- ライティングアーキテクチャは*可視*のシーンのライトでのループによって定義される

光源ごとに
↑
物体を評価する

# ライティングアーキテクチャ

- ライティングアーキテクチャは*可視*のシーンのライトでのループによって定義される

光源ごとに　　　⇦ライトのループはCPUの"マルチパス"かGPUの"シングルパス"で行うことができる
↑
物体を評価する
⇧
GPUで評価する

# ライティングアーキテクチャ

- ライティングアーキテクチャは*可視*のシーンのライトでのループによって定義される

光源ごとに
↑
物体を評価する

GPUやCPUパスのどちらかに対するライト区画構造[partitioning structure] (タイル、クラスタ…)によって最適化できる

そのようなループはマテリアルに影響を与えないライトを取り除くCPUやGPUの助けによって最適化できる

# ライティングアーキテクチャ

- ライティングアーキテクチャは*可視*のシーンのライトでのループによって定義される

光源ごとに
↑
物体を評価する

ディファードやフォワードレンダラでは同じ
マテリアル特性の源のみが異なる

このライトループはディファードでもフォワードでも概念的に同一であることに注意する。マテリアルの特性の源のみが異なる。ディファードでは、Gバッファに由来し、フォワードでは、オブジェクトのユニフォーム/テクスチャに由来する。

# ライティングアーキテクチャ

- ライティングアーキテクチャは*可視*のシーンのライトでのループによって定義される

光源、太陽、IBLごとに
↑
物体を評価する

# ライティングアーキテクチャ

- ライティングアーキテクチャは*可視*のシーンのライトでのループによって定義される

光源ごとに
↑
物体を評価する

太陽ごとに
↑
物体を評価する

IBLごとに
↑
物体を評価する

パフォーマンス上の理由により、ゲームではしばしばライトタイプとマテリアル評価応答[evaluation response]との結合が存在する。例えば、我々はマテリアルのライトモデルによってIBLを事前計算する。
つまり、我々はライトタイプごとに1つのループを行う必要がある。

# ライティングアーキテクチャ

- ライティングアーキテクチャは*可視*のシーンのライトでのループによって定義される

光源ごとに
↑
物体を評価する

太陽ごとに
↑　　　　　　　　　　　　⇦別個のパスで計算したりしなかったり
物体を評価する

IBLごとに
↑
物体を評価する

この種のライトタイプループは時折異なる呼び出しに分割され、パフォーマンスが変化するかもしれない。

# ライティングアーキテクチャ

- HDRPにおけるあるGPUライトループ(太陽、パンクチュアル、エリア、IBL、空)

光源ごとに
↑
物体を評価する

太陽ごとに
↑
物体を評価する

IBLごとに
↑
物体を評価する

HDRPにおいて、我々はすべてのライトタイプで単一のライトループを用いる。太陽、大きさのないライト(スポット、ポイント)、エリアライト、空がある。

# ライティングアーキテクチャ

- ディファードパス

HDRPはディファードとフォワードの両方のレンダラをサポートする。ディファードレンダラの例を見ていこう。Gバッファを満たすディファードマテリアルが1つと使う透明マテリアルが1つある。
同じライトループ。統一されたライティング。

# ライティングアーキテクチャ

- フォワードパス

フォワードレンダリングの例。フォワードの不透明および透明マテリアルがある。

# ライティングアーキテクチャ

- ディファードおよびフォワードの混合パス

HDRPは同時にフォワードとディファード両方をサポートしてもいる。この場合、ディファードパスで見てきたものに加えて、フォワードの不透明マテリアルもある。

# ライティングアーキテクチャ

- 完全なフォワードに切り替え可能

# マテリアルアーキテクチャ

- アーティストフレンドリーなデータ VS エンジンデータ

このスキーマはディファードおよびフォワードアーキテクチャで機能するためにHDRPにおいてマテリアルを記述する方法を示している。これらはガイドラインである。そして、我々はアーティストフレンドリーなデータとエンジンフレンドリーなデータの概念を導入する。
Uiかシェーダグラフでアーティストが埋めた入力をアーティストフレンドリーなデータとしよう。smoothnessのようなやつ。我々はライティングエンジンが使えるエンジンデータへの変換関数を追加する(例えば、ラフネス)。
Gバッファは単なる中間ストレージである。これは圧縮可能である。
HDRPのマテリアルはライティングアーキテクチャに合わせるためにこのマテリアルガイドラインに従う必要がある。

# ライティングアーキテクチャ

- 復習

光源ごとに
↑
物体を評価する

太陽ごとに
↑
物体を評価する

IBLごとに
↑
物体を評価する

# ライティングアーキテクチャ

- ボリューメトリックマテリアルでは

光源ごとに
↑
ボリュームを評価する

太陽ごとに
↑
ボリュームを評価する

IBLごとに
↑
ボリュームを評価する

ボリューメトリックでは、その概念は、代わりにボリューメトリックマテリアル(吸収、散乱)を用いたことを除いて、きっかり同じである。

# ライティングアーキテクチャ

- ボリューメトリックマテリアルでは

Gバッファと同様に、我々は計算のためのボリューメトリックマテリアルの入力としてVバッファを用いる。

# ライティングアーキテクチャ

- 実践では: より低い分解能[resolution]でライティングパスを分割する

そして、実践において、我々はライティングパスを分割し、froxelのセルごとに計算し、その後、別個のパスで不透明および透明マテリアルに結果を適用する。

# ライティングアーキテクチャ

- タイルおよびクラスタの両方のアプローチで最適化する
- 目標
    - 偽陽性を取り除くことに焦点を当てる
        - 例: 狭いシャドウをキャストするスポットライト
    - 偽陽性はライティングパスにおいてより高価である
        - ライトカリングはシャドウレンダリング中に非同期に実行する
        - ディファードライティングパスは非同期に実行していない
        - 隠せる所にコストを移す
        - ライティングパスにおける高いregister pressure

1. 球冠[sphere cap]付きスポットライトにも対応するアグレッシブ(だが高速)な偽陽性の除去を重要視する
    - スポットライトはしばしばシャドウをキャストし、狭いので、重要である
    - 基本的な境界球テストを用いたリスト構築は極めて不十分[highly insufficient]である
2. すべてのリスト構築の処理は非同期コンピュートの活用によって吸収される
3. 偽陽性は早めにやるよりライティング中に扱ったほうがもっと高価である
    - 最終ライティングシェーダはより高いループの複雑さとより大きなregister pressureを持つ
    - 最終ライティングシェーダはシャドウマップのレンダリングの間に非同期コンピュートを活用できない
4. そのリストはディファードでもフォワードでもその両方でも使える
5. リストはライティング中のスレッドdivergenceを減らすのに役立つタイプによる順序を保持するための増加するインデックスのためにもたらされる。

# ライティングアーキテクチャ

- 階層的なアプローチ
    1. 可視ライトごとにスクリーン空間のAABBを求める
    2. Big tile 64x64 prepass
        - 粗い交差テスト
    3. タイルまたはクラスタのライトリストを構築する
        - 狭い交差テスト

1. 可視ライトごとにスクリーン空間AABBを求める
2. Big tile 64x64 tile pre-pass. 初期の早期脱出[early out]のためにAABBを使う(2Dで、深度なし)
    - タイルと凸包との厳密な交差テストで追跡調査する
    - 追加のテスト基準[criteria]として境界球を使う(ポイントライトと球冠付きスポットライトで役立つ)

基本的に、最初にAABBパスが来て、その後、AABBパスが生成したものを使うbig tileパスが来て、その後、big tileパスだけでなくAABBパスが生成したものを両方使うFPTLやClusteredのリスト構築パスが来る。FPTLとClusteredの両方はbig tileプリパスで生成されたオーバーラップし得るタイルのリストを用いる。
これら両方はbig tileプリパスからのリストに残っていることをテストするためにAABBを用いる。
凸包は、2つのスケール値を持つ以外は、いわゆるOBBである。なので、我々は、角錐[pyramid]や楔[wedge]のどちらかを作るために、別個の軸XとYに沿って4つの頂点をしぼる[squeeze]ことができる。スケールを1.0に設定すると、それは単なるOBBであり、1.0より小さくすると、内側にすスケールする。両方を限界まで小さくすると角錐になり、片方だけだと楔型になる。境界球はスポットライトの球冠部分をもたらすのに役立つ。OOBと2つのスケール値は凸包として使うものだが、我々はより多くのタイルを除外するための追加の制約として境界球も用いる。これは、ポイントライトだけでなく球冠に対しても重要である。FPTLおよびClusteredでは、64x64タイルごとにbig tileパスで生成されたものをリストとしてループする。これら両方はまずリストに対してAABBを確認し、LDSに粗いリストを作り上げる。これら両方は境界球の輪郭が粗いリストにおけるライトごとにタイルと重なるかどうかの確認によって追跡調査する。最後にFPTLは詳細な剪定を行い、Clusteredは残りのリストに対してクラスタを確認する。
big tileプリパスがAABBを確認するとき、それは2Dであり、64x64のタイルに対してである。FPTLがそれを行うとき、一例として、3DのAABBテストであり、16x16のタイルに対してである。

FPTLでは、それは、不透明ピクセルをカバーするために必要であるのみなので、とりわけタイトである。つまり、我々は交差テストに最大/最小深度を含めることによってその早期パスだけで大量に除外できる。big tileはAABBテストにおいてXYを行う。FPTLはXYZを行う。タイルに対する球のオーバーラップはすべての場合で2Dのオーバーラップテストである。しかし、もちろん、それがより小さなタイルであることから、こまごましたもの[little extra]を取り除くことができる。なので、私は、Clusteredではかなり安価であるので、再びそのテストを行うことに決めた。2回目のAABBテストは依然として2Dであるが、64x64ではなく32x32で実行するので、こまごましたものを剪定する。そして、それは非常に高速なテストである。

# Tiledライティング

- 3. タイル16x16
    - Fine Prune Tile Lighting (FPTL) [@Mikkelsen2016]に基づく
- タイル16x16に対してFTPLライトリストを作る
    - Fine pruning: いずれかの深度ピクセルがボリューム内にある場合にテストする
    - 偽陽性のアグレッシブな除去
    - タイルあたり1つのライトリスト。スカラレジスタからの属性の読み出しが可能

TODO
