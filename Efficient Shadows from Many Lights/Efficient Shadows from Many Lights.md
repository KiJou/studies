---
title: Efficient Shadows from Many Lights [@Olsson2015b]
---
# SIGGRAPH 2015

# Efficient Shadows from Many Lights

# 概要

- 問題定義
- 動的シーン
    - シャドウマップ
- 静的シーンの要素
    - 他の手法(も)

# 何が問題？

- "多数のライトに対するシャドウ"
    - 多種多様なことを意味し得る！
    - それぞれに多数の解法がある

# 何が問題？

- 我々の問題ではない:
    - 非常に小さい多数のライト
        - シャドウを必要としない
<!--  -->
- 例:
    - Photon Splatting [@Sturzlinger97; @Dachsbacher06]
        - オクルージョンがすでに計算されている

# 何が問題？

- 我々の問題ではない:
    - 非常に小さい多数のライト
        - シャドウを必要としない
    - 多くの重なりを持つ大きなライト
        - 可視性を近似できる
<!--  -->
- 例:
    - Imperfect Shadow Maps [@Ritschel08]
    - ManyLoDs [@Hollander11]

# 何が問題？

- 我々の問題: その中間
    - 現在/未来のゲーム
    - 動的なライトおよびシーン
    - 数百個の全方向性[omnidirectional]ライト
        - ビューあたりわずか数十個のライトがサンプルされる
    - 高品質なシャドウ
        - 誤差の"平均化[average out]"を行わない
    - リアルタイム
        - 少なくとも"研究的実時間[research real time]"である

# UKD Necropolis

- 約300〜400個のライト
    - 大きさが変化する
- 2.6Mのトライアングル
- 最小でだいたい30FPS
- Geforce Titan

# シャドウ品質

# 完全に動的なシーン

# いったいどうしてシャドウマップなのか？

- デファクトスタンダード
    - 猫も杓子も[despite everything]…
- シャドウが高い一貫性を持つ
- ハードウェア/APIにおける柔軟性が増す
- スケーリングが他のテクニックほど酷くない
- キューブシャドウマップが利用可能
- レイトレーシング/シャドウボリューム/など？
    - 動的でない
    - 遅すぎる
    - フィルタ不可能

# 解法の内訳[breakdown]

1. どのライトがシャドウをキャストするか？
2. シャドウマップごとに必要な解像度は？
3. シャドウマップのメモリを管理する
4. シャドウをキャストするジオメトリをカリングする
5. シャドウマップを描画する
6. シーンをシェーディングする

# 多数のライトに対するシャドウ

- I3D 2014とTVCG 2015による論文
    - "(More) Efficient Virtual Shadow Maps for Many Lights"
- Clustered Shadingの上に構築する
- シャドウのサポートを追加する
    - 何百個、リアルタイム
        - もちろん、少なくとも研究的実時間
    - 高く一貫性のある品質
    - 効率的なカリング
    - Virtual/Sparseテクスチャのユースケース

# 解法の内訳

1. **どのライトがシャドウをキャストするか？**
2. シャドウマップごとに必要な解像度は？
3. シャドウマップのメモリを管理する
4. シャドウをキャストするジオメトリをカリングする
5. シャドウマップを描画する
6. シーンをシェーディングする

# Clustered Shadingの重要な特徴

- クラスタ
    - 可視ジオメトリに対するプロキシ
        - ビューサンプルの境界となる
            - 3Dボックス
        - 数回り小さい[orders of magnitudes fewer]
    - クラスタ/ライトのペア
        - クラスタとライトを接続する

# Clustered Shadingの重要な特徴

- クラスタ
    - 可視ジオメトリに対するプロキシ
        - ビューサンプルの境界となる
            - 3Dボックス
        - 数回り小さい
    - クラスタ/ライトのペア
        - クラスタとライトを接続する

# 解法の内訳

1. **どのライトがシャドウをキャストするか？**
2. シャドウマップごとに必要な解像度は？
3. シャドウマップのメモリを管理する
4. シャドウをキャストするジオメトリをカリングする
5. シャドウマップを描画する
6. シーンをシェーディングする

# 解法の内訳

1. どのライトがシャドウをキャストするか？
2. **シャドウマップごとに必要な解像度は？**
3. シャドウマップのメモリを管理する
4. シャドウをキャストするジオメトリをカリングする
5. シャドウマップを描画する
6. シーンをシェーディングする

# シャドウマップの解像度

- 一定の解像度を選び出す
    - アンダーおよびオーバーサンプリング
    - 不十分な品質

# シャドウマップの解像度

- 一定の解像度を選び出す
    - アンダーおよびオーバーサンプリング
    - 不十分な品質
- サンプル密度に対応させる
    - スクリーン空間
    - シャドウマップ空間

# 2. シャドウマップの解像度

# シャドウマップの解像度

<!--  -->
- ある一般的なアプローチ(例、[@King04])はライトの境界球の投影から必要なシャドウマップの解像度を推定する。

# シャドウマップの解像度

- より良い推定を行うためにシャドウレシーバーの位置を用いる[@Forsyth04; @Lefohn07]

# シャドウマップの解像度

例えば、ライトへシャドウレシーバーの境界ボックスを投影する[@Forsyth04]

# シャドウマップの解像度

または、個々のサンプルを投影する[@Lefohn07]

# シャドウマップの解像度

# シャドウマップの解像度

各クラスタは固定のスクリーン空間フットプリントを持つ

# シャドウマップの解像度

# シャドウマップの解像度

# シャドウマップの解像度

クラスタはシャドウマップ上にフットプリントを持つ

# シャドウマップの解像度

これは、立体角に比例して必要な解像度を計算できる

# シャドウマップの解像度

# シャドウマップの解像度

より遠方のシャドウマップについて考える。

クラスタはより大きな立体角をなし、それ故に、シャドウマップの解像度は小さくなる。

# 解像度の計算

- ライトの球上の立体角
- すべてのクラスタ/ライトのペアで並列に
    - ライトごとに一番高い値を保持する
        - atomicMax
- $Res = \sqrt{\frac{S/(\alpha/4\pi)}{6}}$
    - $\alpha$ = 立体角
    - $S$ = スクリーン空間フットプリント(例、32x32)

# 解法の内訳

1. どのライトがシャドウをキャストするか？
2. **シャドウマップごとに必要な解像度は？**
3. シャドウマップのメモリを管理する
4. シャドウをキャストするジオメトリをカリングする
5. シャドウマップを描画する
6. シーンをシェーディングする

# 解法の内訳

1. どのライトがシャドウをキャストするか？
2. シャドウマップごとに必要な解像度は？
3. **シャドウマップのメモリを管理する**
4. シャドウをキャストするジオメトリをカリングする
5. シャドウマップを描画する
6. シーンをシェーディングする

# シャドウマップのストレージ

- シャドウマップは前もって必要とされる
    - 効率的なストレージが最重要[paramount]である
    - 理想的には: 不必要なサンプルを*一切*格納しない
        - 実践では幾らかやりにくい[tricky]
        - (シャドウボリューム、レイトレーシング、エイリアスフリーなシャドウマップ)

# シャドウマップのストレージ

# シャドウマップのストレージ

シャドウマップへの投影を示している。

# シャドウマップのストレージ

どれだけ大きく不規則な範囲が未使用であるかに注意して欲しい。

シャドウマップのこの部分に描かれるいずれも可視シャドウを生成しないだろう。

明らかにこの領域に対するメモリの割り当てを回避すべきであるが、どうやって？

# ハードウェア仮想テクスチャ*

- 仮想テクスチャストレージを割り当てる
    - 仮想メモリのようなもの
    - 低オーバーヘッド
- タイル(ページ)状の物理的配置[physical backing]
    - 例、256x256テクセル
- 最新API
    - OpenGL 4.4の拡張[@OpenGL14]
        - ARB_sparse_texture
    - DirectX 11.2
        - Tiled Resources [@Coombes14]
    - Vulkanは？DX12は？コンソールは？(GCN)

* または、Sparse Textures、Partially Resident Textures

# 使用されるページの決定

- シャドウマップにクラスタを投影する
    - クラスタのワールド空間のAABB
    - ワールド空間におけるシャドウマップ
    - 単純な計算

# キューブ面 +X

```hlsl
float rdMin = 1.0f / max(Epsilon, aabb.min.x);
float rdMax = 1.0f / max(Epsilon, aabb.max.x);

float sMin = min(-aabb.max.z * rdMin, -aabb.max.z * rdMax);
float sMax = max(-aabb.min.z * rdMin, -aabb.min.z * rdMax);

float tMin = min(-aabb.max.y * rdMin, -aabb.max.y * rdMax);
float tMax = max(-aabb.min.y * rdMin, -aabb.min.y * rdMax);
```

- キューブ面上の境界矩形
- 若干異なるものを、6回繰り返す

# 処理

- 並列に、クラスタ/ライトのペアごとに
    - クラスタのAABBをライトのシャドウマップに投影する
    - ライトごとにビットマスクを更新する
        - 物理ページあたりに1つのビット
        - 32x32x6ビット = ライトあたり768バイト
    - atomicOrのアトミックreduction
    - 180Kのクラスタ/ライトのペアで0.25ms以下

# 処理

- ホストにマスクをコピーし戻す
- 物理ページをコミットする(ホスト)
    - glTexPageCommitmentARB

# 仮想シャドウマップ --- 結果

|標準|仮想|差|
|-|-|-|
|4.2Gテクセル|161Mテクセル|26倍|
: Necropolisのピーク時シャドウマップ使用率

# 仮想シャドウマップ --- 結果

|標準|仮想|差|
|-|-|-|
|4.2Gテクセル|161Mテクセル|26倍|
|8.4Gバイト|322Mバイト|実行可能！|
: Necropolisのピーク時シャドウマップ使用率

# 品質 対 メモリ使用量

- 極めて一様な品質
- 減らすのが簡単
    - アンダーサンプリングパラメータ
- メモリ使用量を制御する
- 動的に行うことができる
    - ピーク時メモリ使用量を保証する？

# 品質 対 メモリ使用量

ここにそれを示すショットがあり、シャドウマップにおける2倍または4倍のグローバルな削減を伴う。

シャドウマップのメモリ使用量における対応するピークが示されている。

品質削減を行わないとピークは322MBである。

# 品質 対 メモリ使用量

拡大してみると、シャドウエイリアシングが画像中においてエッジエイリアシングと比較しておおよそ期待されるレベルであることを確認できる。

これは必要解像度の計算のための我々の単純なスキームが理にかなう結果を生み出していることを示している。

フィルタリングがあれば、特に不均等に割り当てられるシャドウマップではなく*一様*な品質を可能にするので、これは許容できる。

メモリ使用量は大幅に削減される。

# 解法の内訳

1. どのライトがシャドウをキャストするか？
2. シャドウマップごとに必要な解像度は？
3. **シャドウマップのメモリを管理する**
4. シャドウをキャストするジオメトリをカリングする
5. シャドウマップを描画する
6. シーンをシェーディングする

# 解法の内訳

1. どのライトがシャドウをキャストするか？
2. シャドウマップごとに必要な解像度は？
3. シャドウマップのメモリを管理する
4. **シャドウをキャストするジオメトリをカリングする**
5. シャドウマップを描画する
6. シーンをシェーディングする

# 基本的なカリング

- 視錐台カリングと同じこと
    - ジオメトリのチャンクをカリングする
    - 境界ボックスを用いて

# 基本的なカリング

- VFCと*違う*こと
    - 数百のライト
    - ほとんどのビューボリュームが短い
        - ライト範囲が制限される
    - 全方向性ライト
        - 6つの***隣接する***錐台
        - 平面を共有している

# 基本的なカリング

```cpp
int getCubeFaceMask(float3 cubeMapPos, Aabb aabb) {
    float3 planeNormals[] = {{-1, 1, 0}, {1, 1, 0}, {1, 0, 1}, {1, 0, -1}, {0, 1, 1}, {0, -1, 1}};
    float3 absPlaneNormals[] = {{1, 1, 0}, {1, 1, 0}, {1, 0, 1}, {1, 0, 1}, {0, 1, 1}, {0, 1, 1}};

    float3 center = aabb.getCentre() - cubeMapPos;
    float3 extents = aabb.getHalfSize();

    bool rp[6];
    bool rn[6];

    for (int i = 0; i < 6; ++i) {
        float dist = dot3(center, planeNormals[i]);
        float radius = dot3(extents, absPlaneNormals[i]);
        rp[i] = dist > -radius;
        rn[i] = dist < radius;
    }

    int fpx = rn[0] && rn[1] && rn[2] && rn[3] && aabb.max.x > cubeMapPos.x;
    // …他の面で同様に…
    return fpx | (fnx << 1) | (fpy << 2) | (fny << 3) | (fpz << 4) | (fnz << 5);
}
```

これは、6つの錐台に対して6つの平面のみをテストするので、非常に効率的である。

特に、平面の方程式はすべて1か0であるので、

このループがアンロールされれば、このコードのほとんどはなくなることを意味している。

# 基本的なカリング

- 細かな粒度(バッチ)
    - 小さくしなければならない
    - ライトのサイズに合わせる

# 基本的なカリング

バッチが大きすぎると、ほとんどのキューブ面にトライアングルが複製されてしまう。

# 基本的なカリング

# 基本的なカリング

カリングがより精密であれば、描画されるトライアングルが少なくなる。

なので、描画されるトライアングルの減少とカリング処理の増加をトレードする。

トライアングルの描画は最も大きなボトルネックであり、それ故に、これが調節可能であることは重要である。

# バッチ

- 約100つのトライアングルをバッチする
    - AABB
    - 変換へのインデックス、トライアングル
- オフラインで構築される
    - 一貫性のあるトライアングルをグループ化する
        - 同じ変換
    - 平坦な配列

# バッチのBVH

- オンラインで構築される
    - 各フレーム
    - 頂点によって更新されるAABBをバッチする
    - 単純な32ウェイの完全なBVH
- ライトごとに並列に横断する

# より良いカリング

この領域を格納するだけでなく、それになんでも描画するのはちょっと馬鹿げてもいる。

# より良いカリング

# より良いカリング

# より良いカリング

# より良いカリング

# より良いカリング

クラスタの投影

重ならない。バッチを破棄する

バッチの投影

# より良いカリング


# バッチの剪定

- ライトに対する投影マップを計算する
- 基本のカリングの結果の上でループする
    - バッチマスクを計算する
    - 投影マップと比較する
        - ビットAND
    - 重ならないなら破棄する

# 解法の内訳

1. どのライトがシャドウをキャストするか？
2. シャドウマップごとに必要な解像度は？
3. シャドウマップのメモリを管理する
4. **シャドウをキャストするジオメトリをカリングする**
5. シャドウマップを描画する
6. シーンをシェーディングする

# 解法の内訳

1. どのライトがシャドウをキャストするか？
2. シャドウマップごとに必要な解像度は？
3. シャドウマップのメモリを管理する
4. シャドウをキャストするジオメトリをカリングする
5. **シャドウマップを描画する**
6. シーンをシェーディングする

# 描画

- GPUでカリングする
- 描画コマンドを作る
    - GPUバッファ
- ライトあたり1つのドローコール
    - `glMultiDrawElementsIndirect(...);`

# 結果

- ピーク時に約250Kのバッチ

|ナイーブ(x6)|CFM|投影マップ|差|
|-|-|-|-|
|126M|20M|13M|約10倍|
: Necropolis、ピーク時のフレームあたりのトライアングル数

# 結果

- ピーク時に約250Kのバッチ

|ナイーブ(x6)|CFM|投影マップ|差|
|-|-|-|-|
|126M|20M|13M|約10倍|
|約150ms?|25ms|16ms|実行可能！|
: Necropolis、ピーク時のフレームあたりのトライアングル数

# 結果

最適化メモ:
達成されたトライアングルレート: 約800M Tris/s
GeForce Titanのピーク: 約4.2G Tris/s
差: 約5倍

# 解法の内訳

1. どのライトがシャドウをキャストするか？
2. シャドウマップごとに必要な解像度は？
3. シャドウマップのメモリを管理する
4. シャドウをキャストするジオメトリをカリングする
5. **シャドウマップを描画する**
6. シーンをシェーディングする

# 解法の内訳

1. どのライトがシャドウをキャストするか？
2. シャドウマップごとに必要な解像度は？
3. シャドウマップのメモリを管理する
4. シャドウをキャストするジオメトリをカリングする
5. シャドウマップを描画する
6. **シーンをシェーディングする**

# シェーディング(2015年版)


- ライトでループする
    - ライトインデックス ⇔ シャドウマップインデックス
- 方向からキューブ面のインデックスを計算する
    - GCN: cubeFaceIndexAMD [@OpenGL14]
- 方向からキューブ面の座標を計算する
- シャドウマップにおける2Dレイヤをサンプルする
- 注意:
    - バインドレステクスチャを使っていない(I3Dの論文に反して)
    - 理由:
        - ARB仕様への適合
        - シェーディングにおける2倍のパフォーマンス増加(NVIDIAのハードウェア)

# 解法の内訳

1. どのライトがシャドウをキャストするか？
2. シャドウマップごとに必要な解像度は？
3. シャドウマップのメモリを管理する
4. シャドウをキャストするジオメトリをカリングする
5. シャドウマップを描画する
6. **シーンをシェーディングする**

# 解法の内訳

1. どのライトがシャドウをキャストするか？
2. シャドウマップごとに必要な解像度は？
3. シャドウマップのメモリを管理する
4. シャドウをキャストするジオメトリをカリングする
5. シャドウマップを描画する
6. シーンをシェーディングする
7. **完了！**

# 静的シーン要素の活用

# 静的なシーン要素

- 静的なライトとシャドウキャスタ
    - シャドウを事前計算する[@Kampe15]
        - ボクセル化されたシャドウ
        - 高品質なフィルタリング
    - シャドウプロキシ[@Valient14]
        - 静的ライト用の静的ジオメトリを事前計算する
        - 実行時にプロキシ＋動的物体をレンダリングする
- 静的シャドウキャスタ
    - レイトレーシング[@Olsson15; @Harada13]
    - Signed distance fields?
- 問題: 時々シャドウキャスタが動くとしたら？

# アルゴリズムの拡張

- シャドウマップを維持する
    - 簡単！
    - すべてのSMが前もって割り当てられる
- 変化しない部分を再描画しない
    - それほど簡単ではない…
    - だけど、試してみよう！

# もっと効率的なカリング

- 以下ならばバッチを破棄する:
    - そのライトが静的である
    - そのバッチが静的である
    - そのバッチが最後のフレームで描画された
    - そのバッチが前のフレームで描画された動的バッチのいずれとも重ならない
    - そのバッチの投影がこのフレームでコミットされる仮想ページのいずれとも重ならない
    - そのシャドウマップの解像度が変化しない

# 新しい問題

- ライト/バッチが静的？
    - アニメーションなどに基づいてこれらをフラグ立てするだけ
- 最後のフレームで描画されたバッチ？
    - フラグ？ --- は多すぎる…
    - 前のフレームの投影マップをテストする！
- 動的と重なる？
    - 新しい投影マップに動的バッチを記録する
- 新たにコミットされる？
    - 仮想ページマスクに対してテストする
- 動的バッチ後に'trace'をクリアする
    - クリアするためにポイントスプライトを描画する

# カリング

改善されたカリングのロジックを再掲、今回は1D。

我々はライトの投影マップを持つ。

バッチ用のマップを作り、それとテストする。

#

いずれかの交差があるとき、そのバッチを描画する。

#

次のフレームでは、変化がないとしよう。

*前*のフレームからのライトの投影マップを使う。

これは、前と同様に、バッチ投影に対してテストされる。だがしかし！

#

重なりがある場合、最後のフレームで描画されているはずなので、そのバッチを破棄する。

ライトとバッチの両方は静的であり、両方とも動くことができなかったことを思い出して欲しい。

#

２つ目のバッチは動的であり、左に動くとしよう。

我々はカリングしつつ動的バッチの投影マップを作る。これは描画されるいずれの動的バッチも記録する。

#

次のフレームで、このマップをバッチの投影マップと交差させる。

重なりがない、つまり、静的バッチは依然として破棄される可能性がある。

ただし、どのように動的バッチが静的バッチと実際に重なるかに注意する…

すなわち、これは次のフレームで再描画しなければならないことを意味する。

#

これは、前のフレームの動的投影マップを比較することで発見される。

#

#

動的投影マップはクリアし再描画すべき部分を教えてくれる。

ページのコミットは同様の効果を持ち、本質的に、同様に扱われる。

これは我々が非常に小さな追加の処理およびオーバーヘッドでシャドウマップへの最小の変更を作ることができることを意味する。

つまり、極端な話、何も動かなければ、何も描画されない。

#

# パフォーマンス(Necropolisアニメーション)

# 今後の仕事

- 我々の設計では忘れやすすぎる！
    - できるだけすぐにページをドロップする
    - 解像度の変更が再描画を引き起こす
- 代わりに
    - できるだけ長くページを維持する
    - 固定サイズのメモリプール
        - 再利用のためのLRUポリシー？
    - (静的ならば)より長く解像度を維持する？
    - より高解像度をリサンプリングする？

# 問題その1 --- 遅いコミット

- ページのコミット
    - フレームあたり最大で約2500コミット
    - 平均: コミットあたり約7us
        - → フレームあたり17ms
    - ピーク: コミットあたり約40us
        - → フレームあたり約100ms
    - ばらつきが大きい[high variability]
- より良くする
- バッチAPIを必要とする
    - DX11のような

# 問題その2 --- 大きな配列のテクスチャのクリア

- 仮想ストレージ
    - 2048 * 8K2 = 128Gテクセル
- クリアはすべてのレイヤに影響を与える
- ワークアラウンド #1
    - テクスチャビューで6レイヤをクリアする
    - 依然として非常に低速(NVIDIAのハードウェア)
        - フレームあたり約90ms
    - ピーク時の物理ストレージ: 161Mテクセル
- ワークアラウンド:
    - コミットされるページごとにポイントスプライトを描画する
    - フレームあたり約1ms

# 終わり！

# 参考文献

# 参考文献
