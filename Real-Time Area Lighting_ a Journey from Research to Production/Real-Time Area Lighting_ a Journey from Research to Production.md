---
title: >
    Real-Time Area Lighting: a Journey from Research to Production [@Hill2016]
---
# Real-Time Area Lighting: a Journey from Research to Production

#

Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
Eric Heitz & Jonathan Dupuy (Unity Technologies), Stephen Hill (Ubisoft), David Neubelt (Ready At Dawn Studios)

#

R & D

#

研究者
と
開発者

#

理論
と
実装

#

<font color="red">理論</font>
と
実装

#

Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
Eric Heitz & Jonathan Dupuy (Unity Technologies), Stephen Hill (Ubisoft), David Neubelt (Ready At Dawn Studios)

# ティザービデオ

# 多角形ライトシェーディング

# 問題

我々がここで実際に解こうとしているものとは？

# 問題

まず、BRDFがある。これは、マテリアルが特定のシェーディングポイントで光をどれだけ散乱させるかを説明する球面関数である。

# 問題

このプロットは与えられるビュー方向に対するものである…
(また、相互的に、与えられるライト方向に対するものでもある)

# 問題

そして、光が散乱して目に戻ってくる方向を表現する。

# 問題

注意: トーク全体を通してBRDFについて述べていることだろうが、これは実際には任意の球面関数とすることができると思われる(計算はそのまま)。

# 問題

次に、我々はシェーディングポイントに到達している多角形からライティング(入射する放射輝度)を持っている。

# 問題

シェーディング結果(出射する放射輝度)はこの球面多角形上のBRDFの積分である。

# これは扱いにくい☹

これは、単一のライト方向に対してBRDFを計算する必要のみがある、ポイントライティングよりさらに難しい。我々は今や**多数**の方向を考慮する必要がある。

オフラインレンダリングでは、我々はこれをモンテカルロサンプリングで解くかもしれないが、リアルタイムにとって、これは実行可能な選択肢[viable option]ではない --- 遅すぎるかノイジーすぎるかのいずれかとなるだろう。

我々は代わりに閉形式の解、すなわち、サンプルする必要がなく即座に正しい答えをもたらすであろう簡単に計算できる等式を求めたい。

# 単純なケースが存在する

単純な分布は閉形式で多角形上に積分できる。一様な球面分布はその一例である。

# 単純なケースが存在する

その球面多角形上の積分は多角形の立体角の計算と等価である。

これに対する閉形式表現がある: Girardの定理

# 単純なケースが存在する

もうひとつの単純な例は一様な半球分布である。

# 単純なケースが存在する

これは単なる半球に切り取られた多角形の立体角である。

# 単純なケースが存在する

より興味深い例はコサイン分布である。

*ディフューズ*または*ランバート[Lambertian]*とも呼ぶことができる。

# 単純なケースが存在する

多角形上でその積分を計算することは放射照度(または、form factor)をもたらす。

また、それに対する閉形式表現がある。これは、18世紀にLambertによって導出された！詳細は後ほど。

# 限定的すぎる☹

こんなところでしょうか！残念ながら、これらの解は我々が必要とするものに対して限定的すぎる[too limiting]。

# 我々は*すべての周波数*を欲する

我々は、鏡のようなものから半光沢[semi-glossy]のもの、粗いものまでの、広範囲のマテリアルを表現することを可能にしたい。

これは表現力[expressiveness]の観点においてリアルタイムシェーディングモデルから期待されるであろうことの必要最小限のこと[bare minimum]である。エリアライトに用立てするためにこれを諦めることは意味を成さない。

# 我々は*すべての周波数*を欲する

# 我々は*すべての周波数*を欲する

# 我々は*すべての周波数*を欲する

# 我々は*異方性*を欲する

現実世界のマテリアルもまたgrazing角で強い異方性(または、'引き伸ばされたハイライト')を示す。

業界標準のマイクロファセットモデルは納得のいくように[convincingly]これを再現することが可能である。これは大きさを持たない[punctual]光源を用いたリアルタイム実装から見ることに慣れている効果であり、であるならば、多角形エリアライトで同じ挙動を達成することを可能としたいだろう。

# 我々は*異方性*を欲する

# 我々は*異方性*を欲する

# 我々は*異方性*を欲する

# 入場: Linearly Transformed Cosines

つまり、要約すると、我々は高速でノイズのない方法において一般的なBRDFと多角形光源の積を計算したいが、これを行う方法は現時点で存在しない。

これは長きに渡る悩みの種[longstanding roadblock]であり、ここでプレゼンテーションを止めなければならないならば失望させてしまうだろう。:)

幸いにも、我々はこの問題への解をなんとか求めた[managed to find]: *Linearly Transformed Cosines* (LTCs)。
これは我々の論文の核となる貢献である。

私はLTCsの高レベルの概要を説明するが、(重ねて言うが)さらなる詳細はEricのスライドを参照して欲しい。

#

本質的に、その主なアイデアは単純な分布を取り、線形変換を適用することである。そう行うことで、我々は広範囲のより洗練された'形状'(球面関数)を生成できる。

#

先程述べたクランプ済みのコサイン分布から始めよう。

#

XとYへ一様なスケーリングを適するならば、分布のラフネスを変化させることができる。

#

XとYに異なるファクタを用いると、異方性を生成できる。

#

そして、変換の左下の成分を通して、'スキュー[skewness]'を引き起こすことができる。

#

ランダム行列によってあらゆる種類の奇抜な[wacky]挙動さえも生成できる。そのいくつかは二峰性[bimodal]分布を引き起こしさえもする。

そして、ご覧の通り、このアプローチは非常に高価である。

# 線形変換

一般に、我々はコサイン分布を取り、任意の3x3行列$M$を適用して、新しい分布を生み出すことができる。

その論文では、この方法で生成される分布の**たぐい[family]**を*Linearly Transformed Cosines*と呼ぶ。

# 線形変換

# 線形変換

# 線形変換

# 一覧表化[tabulated]

では、どうのように実践でこれを用いるか？

多角形光源でGGXベースのBRDFの積分を計算したいということにしよう。まず、与えられるラフネスとビュー角度に対して、このBRDFLTCで最も良く近似する線形変換$M$を求める。我々はすべてのラフネスとビュー角度に対して前もってこれを行い、テーブル(=テクスチャ)に結果の行列を格納する。

実践では、これほど多くのデータを必要としない(詳細は論文を参照)。

#

そして、'魔法のトリック'。実行時に、我々のBRDF-多角形の構成を取り…

# 逆変換

そして、(現在のシェーディングポイントでビュー角度とラフネスに対する)そのBRDFのLTCフィッティングに基づく逆変換を多角形の頂点に適用する。

# 逆変換

# 逆変換

# コサイン積分

これはその構成を等価だがより単純な積分の問題に変化する。

これを'コサイン空間'へ変換し直すことと考えることができる。

# ランバート、1760年！

そして、我々はずっと昔の18世紀からJohann Heinrich Jambert(通称'Mr NdotL')の研究のおかげでこれを解く方法を知っている。

# 面積分[area integral] → 辺積分[edge integrals]

実践では、直接的に面積分を計算するのではなく、球面多角形の境界上の一連の線/辺積分を計算する(辺ごとに1つ)。

# 面積分 → 辺積分

与えられる辺に対して、2つの頂点$v_1$と$v_2$から…

#

$$
\text{acos}(v_1, v_2) \frac{v_1 \times v_2}{\|v_1 \times v_2\|} \cdot n
$$

1Dの球面線積分を計算する(緑)。

#

これにはラジアン単位の弧の長さを含み…

#

直角ベクトル$u$もあり(紫)…

#

…そして、これは局所的な表面の法線$n$で内積を取っている。

#

$$
\frac{1}{2\pi} \sum_{i=1}^n \text{acos}(v_i, v_j) \frac{v_i \times v_j}{\|v_i \times v_j\|} \cdot n
$$

そして、すべての辺でこの処理を繰り返し、結果を合計する。

これは面積分と同じ結果をもたらす。

このプレゼンテーションではこれがなぜ機能するかを説明する時間がない。これを考える方法のひとつは、流体シミュレーションのような他分野で遭遇していたかもしれない、Stokesの定理の応用である。しかし、これはほんの少し抽象的であり、そのため、この特定のケースのより直観的な取扱いについては、ここのEricの記事を参照のこと:　https://hal.archives-ouvertes.fr/hal-01458129

#

```hlsl
float EdgeIntegral(float3 v1, float3 v2, float3 n) {
    float theta = acos(dot(v1, v2));
    float3 u = normalize(cross(v1, v2));
    return theta * dot(u, n);
}

float PolyIntegral(float3 v[4], float3 n) {
    float sum;
    sum = EdgeIntegral(v[0], v[1]);
    sum += EdgeIntegral(v[1], v[2]);
    sum += EdgeIntegral(v[2], v[3]);
    sum += EdgeIntegral(v[3], v[0]);
    return sum / (2.0 * pi);
}
```

とにかく、ここに見えるように、これは結果として本当にコンパクトでエレガントな実装となる。

よりシンプルにはできないだろうか？

# おしまい？[peace out?]

我々の仕事はこれでおしまいか？もちろんそうではない…

# 研究山[research mountain]

いいや、まだまだだ。例えるなら…

我々は研究山を降りたかもしれない…

# 実装の**暗黒の塔**

…だが、我々は依然として実装の'暗黒の塔'を登る必要がある。

#

理論
<font color="red">と</font>
<font color="red">実装</font>

#

1. ラフネスとビュー角度に基づいて$M^{-1}$を探索する
2. $M^{-1}$で多角形を変換する
3. 多角形を半球上部にクリップする
4. 辺積分を計算する

#

1. ラフネスとビュー角度に基づいて$M^{-1}$を探索する
2. $M^{-1}$で多角形を変換する
3. 多角形を半球上部にクリップする
4. **辺積分を計算する**

ちょっと順不同に、まずはこれらの辺積を見ていこう

上手く行かないであろうこととは？

# 大丈夫に見える？

すべてはここで大丈夫に見える、よね？

# 明るくすると: 大規模なアーティファクト

残念ながら、光の強度を上げると、問題が現れ始める。

# 明るくすると: 大規模なアーティファクト

ここに再びそのコードがある。

おかしいな。上手く機能するはずではないのか？

# 良好だが…

より数値計算的に安定であることを証明した数学的に等価な形式を用いることでその問題を迂回したと語ったことを恥じている。

これはその問題を部分的に修正し、デモでは良くなったが、確実にここではもっとひどくなっている。

# acos: この四文字だ！

犯人はacosだ！

# acos: 悪が潜んでいる！

皆さんのほとんどが恐らく知っている通り、これはintrinsicではない。

# acos: 悪が潜んでいる！

```hlsl
float acos(float inX) {
    float x1 = abs(inX);
    float x2 = x1 * x1;
    float x3 = x2 * x1;
    float s;

    s = -0.2121144 * x1 + 1.5707288;
    s = 0.0742610 * x2 + s;
    s = -0.0187293 * x3 * s;
    s = sqrt(1.0 - x1) * s;

    return inX >= 0.0 ? s : pi - s;
}
```

ここに標準の実装がある。HLSL、CUDA、OpenGL、そして、コンソールで等価なコードを確認した。基本形をもたらす`sqrt(1 - x)`があり、さんじた公式が足される。

これはほとんどのアプリケーションに対して正確である一方、辺積分は多くの精度を必要とすることが判明している。標準の`acos`では、いくつかの場合(高い強度のライティングやなめらかなレシーバー)でリンギングアーティファクトが起こり得る。

#

要するに、大量のトライアンドエラーの末、その解法が明らかとなった:
`sin(theta)`全体で`theta`に対するフィッティングを求める

(このフィッティングは、対象の関数における`acos`の完全に正確なCPU実装を用いて、オフラインで計算される。)

# 有理式フィッティング[rational fit]

十分な正確性を得るために、これは三次の有理式フィッティングを必要とした。

これは実際にはそれほど高価ではない: 有理式に由来する追加の除算があるが、`sin()`の呼び出しを節約した。

注意: 残りの角度範囲はそこから計算できるので、0からpi/2までを必要とするのみである。

# 有理式フィッティング

このcompound fitを行うことで、相対誤差(注)はかなり小さくなる。

旧: シータを計算するのに`acos`の標準シェーダ言語実装を使用
新: `theta / sin(theta)`のフィッティング

(注:これは実際には、相対誤差ではなく、元の関数と各近似との比である。これは、アンダーシュートやオーバーシュートを明確にする。)

# 有理式フィッティング   acos:悪は潜んでいる！

では、問題に戻って…

# 有理式フィッティング   すべてより良い！

ここに、かなりより良く見える、その結果がある。

# おまけ: より安価なディフューズ

おまけとして、我々は、同様の正確性を必要としないので、ディフューズに対してより安価なバージョンを使う。

この場合、二次式に逃がす[get away]ことができ、それによって、いくつかのMADと除算を節約する。

#

1. **ラフネスとビュー角度に基づいて$M^{-1}$を探索する**
2. $M^{-1}$で多角形を変換する
3. 多角形を半球上部にクリップする
4. 辺積分を計算する

それでは、次に行こう。

# 大丈夫に見える？

また、すべて良好に見える。

# blobby mess

だが、より高い強度では、ハイライト形状が正しくない。

ここでの映像はないが、ビュー角度を変更するとき、特にgrazing角で、いくつかの目立つバンディングと補間の問題が起こる。

# 行列の正規化: 項4つ！

これは我々が行ったトリックに実際に行き着いた。そこでは、我々は右下の値によって各行列の成分のすべてを分割した。つまり、そこは常に1であり、それ故に、格納する必要はないだろう。我々は4要素のテクスチャにその行列を対応させることを可能とすることでこれを行った。しかし、依然としてBRDFの大きさに対して5番目の成分を必要とした。そのため、シェーダにおける2回目のテクスチャフェッチが不可避であった。

結局、これはあまり節約にならず、この分割を導入することで重大な副次的効果を引き起こした。

#

…それは、行列成分のいくつかが最終的に(ラフネス, ビュー角度)領域上でより荒々しく変化するようになったことである。そのため、これらを上手く補間できない。

#

この再スケーリングを行わない場合、元の5つの成分はよりなめらかに変化し、より小さいダイナミックレンジを持つ(まだ試していないけど、成分あたり16ビット以下に逃がす[get away]ことさえもできるかもしれない)。

# blobby mess

ここに前に得た、行列の再スケーリングを用いる結果があり…

# 安定で、正確な形状

こちらがその後、用いない結果である。

これは、異なる方法でデータを可視化することが役立つという良い助言[good reminder]である。我々は開発中にフィッティングされたLTC分布と元のBRDFを注意深く比較してきた一方で、後になるまで一覧表化した値では詳しく調べなかった。

# おまけ: より安価なルックアップ

```glsl
vec2 uv = vec2(roughness, acos(dot(n, v)));
```
↓
```glsl
vec2 uv = vec2(roughness, dot(n, v));
```

その時点では、我々はアーティファクトを減らすためにもうひとつのワークアラウンドを用いた。すなわち、`cos(theta)`ではなく`theta`によってテーブルのルックアップをパラメータ化した。現在では、正しい修正により、もはやこれを行う必要がない。これは`acos`のコストを回避することができることを意味する。

#

1. ラフネスとビュー角度に基づいて$M^{-1}$を探索する
2. $M^{-1}$で多角形を変換する
3. **多角形を半球上部にクリップする**
4. 辺積分を計算する

では、3つ目の問題、クリッピングについて。

今まで誤魔化してきたことは多角形の正しい結果(form factor)を得るために、半球上部に多角形をクリップする必要があることである。

多角形のクリッピングは楽しくない…

#

我々はこれの様々なフレーバーを試した。

- 辺積分中の'オンザフライ'なクリッピング
- Morgan McGuireのクアッドクリッピング: https://casual-effects.com/research/McGuire2011Clipping/index.html。これは分岐数を最小化するが、かなり多くのデータシャッフルを伴う。
- 巨大なスイッチ/点が水平線より上か下かに基づくif-else

最後のひとつはPS4で最速になる(とはいえ、Morganのに近い)よう調整されたが、これらすべては多数の命令や分岐を生成した。

# 分岐地獄

その上、クリッピング処理は様々な辺の数、3から5まで、で結果を求める。なので、もっと多くの分岐がある！

注意深く試験し、ゲームコンソールのために生成されたアセンブリを調整することで得られるゲインはいくつかあるかもしれないが、まったくもってこの複雑さを回避するのが良いだろう。

#

辺積分に戻ろう。

#

平面に投影し(法線との内積を取ら)なければ、最終的にベクトル形式で行われる。

# vector form factor

これを*vector form factor*、または、*ベクトル放射照度*と考えることができる。このベクトルを$F$としよう。

# Fの長さ＝Fの方向におけるform factor

これは非常に良い特性を持つ。すなわち、Fの長さ(ノルム)はFの方向における多角形のform factorである。

我々は水平線にクリップされたかのように多角形のform factorを近似するためにこれを使うことができる。

# 多角形→*プロキシ*球

TODO
