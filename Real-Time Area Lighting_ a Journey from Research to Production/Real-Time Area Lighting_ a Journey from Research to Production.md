---
title: >
    Real-Time Area Lighting: a Journey from Research to Production [@Hill2016]
---
# Real-Time Area Lighting: a Journey from Research to Production

#

Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
Eric Heitz & Jonathan Dupuy (Unity Technologies), Stephen Hill (Ubisoft), David Neubelt (Ready At Dawn Studios)

#

R & D

#

研究者
と
開発者

#

理論
と
実装

#

<font color="red">理論</font>
と
実装

#

Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
Eric Heitz & Jonathan Dupuy (Unity Technologies), Stephen Hill (Ubisoft), David Neubelt (Ready At Dawn Studios)

# ティザービデオ

# 多角形ライトシェーディング

# 問題

我々がここで実際に解こうとしているものとは？

# 問題

まず、BRDFがある。これは、マテリアルが特定のシェーディングポイントで光をどれだけ散乱させるかを説明する球面関数である。

# 問題

このプロットは与えられるビュー方向に対するものである…
(また、相互的に、与えられるライト方向に対するものでもある)

# 問題

そして、光が散乱して目に戻ってくる方向を表現する。

# 問題

注意: トーク全体を通してBRDFについて述べていることだろうが、これは実際には任意の球面関数とすることができると思われる(計算はそのまま)。

# 問題

次に、我々はシェーディングポイントに到達している多角形からライティング(入射する放射輝度)を持っている。

# 問題

シェーディング結果(出射する放射輝度)はこの球面多角形上のBRDFの積分である。

# これは扱いにくい☹

これは、単一のライト方向に対してBRDFを計算する必要のみがある、ポイントライティングよりさらに難しい。我々は今や**多数**の方向を考慮する必要がある。

オフラインレンダリングでは、我々はこれをモンテカルロサンプリングで解くかもしれないが、リアルタイムにとって、これは実行可能な選択肢[viable option]ではない --- 遅すぎるかノイジーすぎるかのいずれかとなるだろう。

我々は代わりに閉形式の解、すなわち、サンプルする必要がなく即座に正しい答えをもたらすであろう簡単に計算できる等式を求めたい。

# 単純なケースが存在する

単純な分布は閉形式で多角形上に積分できる。一様な球面分布はその一例である。

# 単純なケースが存在する

その球面多角形上の積分は多角形の立体角の計算と等価である。

これに対する閉形式表現がある: Girardの定理

# 単純なケースが存在する

もうひとつの単純な例は一様な半球分布である。

# 単純なケースが存在する

これは単なる半球に切り取られた多角形の立体角である。

# 単純なケースが存在する

より興味深い例はコサイン分布である。

*ディフューズ*または*ランバート[Lambertian]*とも呼ぶことができる。

# 単純なケースが存在する

多角形上でその積分を計算することは放射照度(または、form factor)をもたらす。

また、それに対する閉形式表現がある。これは、18世紀にLambertによって導出された！詳細は後ほど。

# 限定的すぎる☹

こんなところでしょうか！残念ながら、これらの解は我々が必要とするものに対して限定的すぎる[too limiting]。

# 我々は*すべての周波数*を欲する

我々は、鏡のようなものから半光沢[semi-glossy]のもの、粗いものまでの、広範囲のマテリアルを表現することを可能にしたい。

これは表現力[expressiveness]の観点においてリアルタイムシェーディングモデルから期待されるであろうことの必要最小限のこと[bare minimum]である。エリアライトに用立てするためにこれを諦めることは意味を成さない。

# 我々は*すべての周波数*を欲する

# 我々は*すべての周波数*を欲する

# 我々は*すべての周波数*を欲する

# 我々は*異方性*を欲する

現実世界のマテリアルもまたgrazing角で強い異方性(または、'引き伸ばされたハイライト')を示す。

業界標準のマイクロファセットモデルは納得のいくように[convincingly]これを再現することが可能である。これは大きさを持たない[punctual]光源を用いたリアルタイム実装から見ることに慣れている効果であり、であるならば、多角形エリアライトで同じ挙動を達成することを可能としたいだろう。

# 我々は*異方性*を欲する

# 我々は*異方性*を欲する

# 我々は*異方性*を欲する

# 入場: Linearly Transformed Cosines

つまり、要約すると、我々は高速でノイズのない方法において一般的なBRDFと多角形光源の積を計算したいが、これを行う方法は現時点で存在しない。

これは長きに渡る悩みの種[longstanding roadblock]であり、ここでプレゼンテーションを止めなければならないならば失望させてしまうだろう。:)

幸いにも、我々はこの問題への解をなんとか求めた[managed to find]: *Linearly Transformed Cosines* (LTCs)。
これは我々の論文の核となる貢献である。

私はLTCsの高レベルの概要を説明するが、(重ねて言うが)さらなる詳細はEricのスライドを参照して欲しい。

#

本質的に、その主なアイデアは単純な分布を取り、線形変換を適用することである。そう行うことで、我々は広範囲のより洗練された'形状'(球面関数)を生成できる。

#

先程述べたクランプ済みのコサイン分布から始めよう。

#

XとYへ一様なスケーリングを適するならば、分布のラフネスを変化させることができる。

#

XとYに異なるファクタを用いると、異方性を生成できる。

#

そして、変換の左下の成分を通して、'スキュー[skewness]'を引き起こすことができる。

#

ランダム行列によってあらゆる種類の奇抜な[wacky]挙動さえも生成できる。そのいくつかは二峰性[bimodal]分布を引き起こしさえもする。

そして、ご覧の通り、このアプローチは非常に高価である。

# 線形変換

一般に、我々はコサイン分布を取り、任意の3x3行列$M$を適用して、新しい分布を生み出すことができる。

その論文では、この方法で生成される分布の**たぐい[family]**を*Linearly Transformed Cosines*と呼ぶ。

# 線形変換

# 線形変換

# 線形変換

# 一覧表化[tabulated]

では、どうのように実践でこれを用いるか？

多角形光源でGGXベースのBRDFの積分を計算したいということにしよう。まず、与えられるラフネスとビュー角度に対して、このBRDFLTCで最も良く近似する線形変換$M$を求める。我々はすべてのラフネスとビュー角度に対して前もってこれを行い、テーブル(=テクスチャ)に結果の行列を格納する。

実践では、これほど多くのデータを必要としない(詳細は論文を参照)。

#

そして、'魔法のトリック'。実行時に、我々のBRDF-多角形の構成を取り…

# 逆変換

そして、(現在のシェーディングポイントでビュー角度とラフネスに対する)そのBRDFのLTCフィッティングに基づく逆変換を多角形の頂点に適用する。

# 逆変換

# 逆変換

# コサイン積分

これはその構成を等価だがより単純な積分の問題に変化する。

これを'コサイン空間'へ変換し直すことと考えることができる。

# ランバート、1760年！

そして、我々はずっと昔の18世紀からJohann Heinrich Jambert(通称'Mr NdotL')の研究のおかげでこれを解く方法を知っている。

# 面積分[area integral] → 辺積分[edge integrals]

実践では、直接的に面積分を計算するのではなく、球面多角形の境界上の一連の線/辺積分を計算する(辺ごとに1つ)。

# 面積分 → 辺積分

与えられる辺に対して、2つの頂点$v_1$と$v_2$から…

#

$$
\text{acos}(v_1, v_2) \frac{v_1 \times v_2}{\|v_1 \times v_2\|} \cdot n
$$

1Dの球面線積分を計算する(緑)。

#

これにはラジアン単位の弧の長さを含み…

#

直角ベクトル$u$もあり(紫)…

#

…そして、これは局所的な表面の法線$n$で内積を取っている。

#

$$
\frac{1}{2\pi} \sum_{i=1}^n \text{acos}(v_i, v_j) \frac{v_i \times v_j}{\|v_i \times v_j\|} \cdot n
$$

そして、すべての辺でこの処理を繰り返し、結果を合計する。

これは面積分と同じ結果をもたらす。

このプレゼンテーションではこれがなぜ機能するかを説明する時間がない。これを考える方法のひとつは、流体シミュレーションのような他分野で遭遇していたかもしれない、Stokesの定理の応用である。しかし、これはほんの少し抽象的であり、そのため、この特定のケースのより直観的な取扱いについては、ここのEricの記事を参照のこと:　https://hal.archives-ouvertes.fr/hal-01458129

#

```hlsl
float EdgeIntegral(float3 v1, float3 v2, float3 n) {
    float theta = acos(dot(v1, v2));
    float3 u = normalize(cross(v1, v2));
    return theta * dot(u, n);
}

float PolyIntegral(float3 v[4], float3 n) {
    float sum;
    sum = EdgeIntegral(v[0], v[1]);
    sum += EdgeIntegral(v[1], v[2]);
    sum += EdgeIntegral(v[2], v[3]);
    sum += EdgeIntegral(v[3], v[0]);
    return sum / (2.0 * pi);
}
```

とにかく、ここに見えるように、これは結果として本当にコンパクトでエレガントな実装となる。

よりシンプルにはできないだろうか？

# おしまい？[peace out?]

我々の仕事はこれでおしまいか？もちろんそうではない…

# 研究坂[research mountain]

TODO
