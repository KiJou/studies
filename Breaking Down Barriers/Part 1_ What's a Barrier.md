---
title: >
    BREAKING DOWN BARRIERS --- PART 1: WHAT'S A BARRIER?
---
# BREAKING DOWN BARRIERS --- PART 1: WHAT'S A BARRIER?

D3D12かVulkanのプログラミングを少しでもかじったことがある人ならば誰しも、バリアの対処に長々と時間を費やしたことだろう。これらは正しく行おうとするとかなり扱いづらくなることがある。つまり、レンダリングコードを変更するたびに、または、Windowsアップデートを介して新しいバージョンの検証レイヤが導入されるときに、検証レイヤが常に新しい問題を指摘しているように見えてしまう。そして、それに加えて、IHVは、D3D11に匹敵するかそれを超えるGPUパフォーマンスを望む場合には、本当に気を付ける必要があるということ、そして、どのようにバリアを使うかということを伝え続けている。これはただアーティファクトフリーな結果を達成する上での追加の課題である。

では、何がどうなっているのだろうか？そもそも一体全体なぜバリアとやらが必要なのか、そして、これらを誤って使ってしまうとなぜそこまで上手くいかないのだろうか？貴方がかなりのコンソールプログラミングを行ったことのある人やモダンなGPUの低レベルの詳細にすでに親しみのある人であるならば、これらの疑問の答えを恐らく知っているだろう。その場合、この記事はまったくもって貴方用ではない。しかし、貴方がそんな経験の恩恵を持たない人であるならば、私は、貴方がバリアを発行するときのシーンの背後で起こっていることをより良く理解できるよう最善を尽くします。

## A HIGH BARRIER TO ENTRY

プログラミングやコンピュータにおける他の例に漏れず、"バリア"という用語はすでにいくらか多重定義されている。ある文脈では、"バリア"は大量のスレッドすべてが動作中のコードの特定のポイントに達するたびに停止しなければならない同期ポイントである。この場合、バリアを動かない壁として考えることができる。つまり、スレッドはすべて動作しているが、バリアに"ヒット"するときに急停止する。


```
void ThreadFunction() {
    DoStuff();

    // すべてのスレッドがバリアにヒットするまで待つ
    barrier.Wait();

    // すべてのスレッドがDoStuff()を呼び出したことが分かっている
}
```

この種のものは大量のスレッドがすべてタスクを実行し終えたときを知りたいとき(fork-joinモデルにおける"join")、または、他の結果を読む必要があるスレッドがあるときに役立つ。プログラマとしては、アトミック演算によって更新される変数での"spinning"(条件を満たすまでループすること)、または、待っている間にスレッドをスリープさせたいときにはセマフォと条件変数を用いることでスレッドバリアを実装できる。

他の文脈では、"バリア"という用語は、特にロックフリープログラミングの世界にいくらか入り込んだ場合には、"メモリバリア"を指すだろう("フェンス"としても知られる)。これらの場合では、コンパイラやプロセッサ自体によって行われるメモリ操作の並べ替えを通常扱っている。これは共有メモリを介して通信する複数のプロセッサがあるときに本当に滅茶苦茶にしてしまうことがある。メモリバリアはメモリ操作がバリアの前か後のいずれかに完了することを強制させることで支援し、実質的にフェンスの一方の"側"にこれらを留める。C++では、Windows APIにおけるメモリバリアのようなプラットフォーム固有のマクロやクロスプラットフォームの`std::atomic_thread_fence`を用いてコードにこれらを挿入することができる。一般的なユースケースはこのように見えるかもしれないだろう。

```
// DataIsReadyとDataは異なるスレッドで書き込まれる
if (DataIsReady) {
    // DataIsReadyの読み出しの*後*にDataの読み出しが起こることを確実にする
    MemoryBarrier();

    DoSomething(Data);
}
```

これら２つの"バリア"という用語の意味する所は異なるが、これらに共通するものもある。これらは片方が結果を生み出し、もう片方がその結果を読み出す必要があるときに大抵使われる。別の言い方をすると、あるタスクが別のタスクへの**依存性**を持つということである。依存性はコードを書くときにいつでも発生する。つまり、オフセットを計算するために2つの値を加算するコードの1行があれば、すぐ次の行が配列から読み出すためにそのオフセットを用いるだろう。しかしながら、コンパイラがこれらの依存性を**追跡**し、正しい結果をもたらすコードを生成することを確かめるので、貴方はこれに気付く必要はそれほどない。バリアの手動挿入は、コンパイラがコンパイル時にどのようにデータが書き出され、読み出されているかを理解できないような方法で物事を行うまで通常現れない。これは同じデータにアクセスする複数のスレッドによって一般的に発生するが、(他のハードウェアの一部がメモリに書き込むときのような)他の奇妙なケースでも発生し得る。いずれにしても、適切なバリアを用いることで、誤ったデータの読み出しとならないように保証され、結果がdependent stepsから**可視**であろうことを確実にするだろう。

TODO
