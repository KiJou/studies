# Introduction to Real-Time Shading with Many Lights, SIGGRAPH 2015

## 問題定義

これから紹介するアルゴリズムは数百から数千のライトをリアルタイムで処理するとき関係してくる。言うなれば、数は問題ではないとする所までが最終目標。
ライトは影響範囲を制限され、減衰効果によってその境界で0になる。
ここでは影を考えないで、このあとのコースの方でカバーする。
事前計算しないので、シーンをフレームごとに変化させることができる。

## ライト割り当て

シェーディングポイントに及ぼす影響をすべて調べるには、単純に考えてもフレームバッファのピクセル数xライト数くらいかかるので、ピクセルあたりのライト数を最小化して高パフォーマンス化したい。その解決策として、ライト割り当て(ライトカリング)を導入する。
シェーディング技法のコースと言いつつも、実際には注目する各点に関係するライトがどれだけあるかを算出する方法についての話が主になる。
これを高パフォーマンスで行うことは、関心事とするのに十分すぎるほど複雑である。
ここではライト割り当て(light assignment)と呼ぶが、ライトカリング(light culling)の名でも知られている。

## (Traditional) Forward Shading

リアルタイムシェーディングで使われていた伝統的な手法で、コンシューマGPUの最初期にのみ使われていた。
モバイルではまだ支配的。
フレームバッファに書き込むまでにひとつのパスしかない。
ジオメトリはラスタライズされ、頂点データを補間して、フラグメントを生成する。
フラグメントは必要分すべてのライトを用いてシェーディングされ、計算した色はフレームバッファに流される。
シェーディングはフラグメントシェーダで処理する。(頂点シェーダでもできるけど)

ドローコールごとに関連するライトをすべて集めなければならず、バッチごとにライトを割り当てなければならない。
ライトの数を少なくするためには、バッチサイズは小さくしたいんだけど、描画を高速化するように、GPUを休ませずにAPIのオーバヘッドを避けるためには、バッチサイズを大きくしたい。
バッチサイズの影響が強いため、ジオメトリの形状はあまり気にしなくていい。
どっちかいいかは場合によるため、妥協するのが一番はやいが、難しい問題である。

### 問題

単なるバッチサイズの話から掘り下げてみると、ジオメトリのチャンクサイズに基づいてライトを割り当てなければならないという基本的な問題になる。
いくつかの大きなオブジェクトと大量の小さなライトがある場合、ジオメトリの一部にしか影響を与えないライトが多く、無駄なシェーディング計算しなければならなくなる。
一方で、大量の小さなオブジェクトといくつかの小さなライトがある場合、個々のオブジェクトでライトの影響範囲を求める、似たような処理を繰り返さなければならなくなる。
これらの状況はシーン中に混在するため、パフォーマンスのバランスを良好に保つのは困難に近い。
一般に、三角形の大きさやライトの密度変化が関わってくると、この話はうまく解決できなくなってしまう。

### まとめ

#### 良い点

- シングルパス
- フレームバッファだけなので、かかるメモリコストが少ない
- 透明処理ができる
- MSAAが使える
- ライトが少ないうちはシンプル
- シェーディングモデルの切り替えが簡単

#### 悪い点

- オーバードロー(overdraw)
- バッチ処理がライティングと一体となっている
- シェーダ管理

## Traditional Deferred Shading

TODO
