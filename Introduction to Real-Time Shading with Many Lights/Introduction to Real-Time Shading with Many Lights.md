# Introduction to Real-Time Shading with Many Lights, SIGGRAPH 2015

## 問題定義

これから紹介するアルゴリズムは数百から数千のライトをリアルタイムで処理するとき関係してくる。言うなれば、数は問題ではないとする所までが最終目標。
ライトは影響範囲を制限され、減衰効果によってその境界で0になる。
ここでは影を考えないで、このあとのコースの方でカバーする。
事前計算しないので、シーンをフレームごとに変化させることができる。

## ライト割り当て

シェーディングポイントに及ぼす影響をすべて調べるには、単純に考えてもフレームバッファのピクセル数xライト数くらいかかるので、ピクセルあたりのライト数を最小化して高パフォーマンス化したい。その解決策として、ライト割り当て(ライトカリング)を導入する。
シェーディング技法のコースと言いつつも、実際には注目する各点に関係するライトがどれだけあるかを算出する方法についての話が主になる。
これを高パフォーマンスで行うことは、関心事とするのに十分すぎるほど複雑である。
ここではライト割り当て(light assignment)と呼ぶが、ライトカリング(light culling)の名でも知られている。

## (Traditional) Forward Shading

リアルタイムシェーディングで使われていた伝統的な手法で、コンシューマGPUの最初期にのみ使われていた。
モバイルではまだ支配的。
フレームバッファに書き込むまでにひとつのパスしかない。
ジオメトリはラスタライズされ、頂点データを補間して、フラグメントを生成する。
フラグメントは必要分すべてのライトを用いてシェーディングされ、計算した色はフレームバッファに流される。
シェーディングはフラグメントシェーダで処理する。(頂点シェーダでもできるけど)

ドローコールごとに関連するライトをすべて集めなければならず、バッチごとにライトを割り当てなければならない。
ライトの数を少なくするためには、バッチサイズは小さくしたいんだけど、描画を高速化するように、GPUを休ませずにAPIのオーバヘッドを避けるためには、バッチサイズを大きくしたい。
バッチサイズの影響が強いため、ジオメトリの形状はあまり気にしなくていい。
どっちかいいかは場合によるため、妥協するのが一番はやいが、難しい問題である。

### 問題

単なるバッチサイズの話から掘り下げてみると、ジオメトリのチャンクサイズに基づいてライトを割り当てなければならないという基本的な問題になる。
いくつかの大きなオブジェクトと大量の小さなライトがある場合、ジオメトリの一部にしか影響を与えないライトが多く、無駄なシェーディング計算しなければならなくなる。
一方で、大量の小さなオブジェクトといくつかの小さなライトがある場合、個々のオブジェクトでライトの影響範囲を求める、似たような処理を繰り返さなければならなくなる。
これらの状況はシーン中に混在するため、パフォーマンスのバランスを良好に保つのは困難に近い。
一般に、三角形の大きさやライトの密度変化が関わってくると、この話はうまく解決できなくなってしまう。

### まとめ

#### 良い点

- シングルパス
- フレームバッファだけなので、かかるメモリコストが少ない
- 透明処理ができる
- MSAAが使える
- ライトが少ないうちはシンプル
- シェーディングモデルの切り替えが簡単

#### 悪い点

- オーバードロー(overdraw)
- バッチ処理がライティングと一体となっている
- シェーダ管理

## Traditional Deferred Shading

シェーディングからジオメトリを分離して、ライト割り当てとオーバードローの問題を解決するのが目標。
こんにち知られているGバッファを用いたDeferred Shadingは1990年に導入された。[Saito90]
"Deferred Shading"はその後に改めて作られた用語。[Tebbs92]
ゲームでは2005年頃から、MRTの登場により使われ始めた。[Shishkovtsov05]

シェーディングを遅らせる(defer)。
ジオメトリパスでは、ジオメトリがラスタライズされ、頂点データを補間してフラグメントが生成されるまでは同じで、フラグメントはシェーディングされず、ピクセル単位のアトリビュートがGバッファに格納される。
ジオメトリを全部処理したら、そのあとで、シェーディングパスを行う。
シェーディングパスは、シーンのジオメトリ表現に依存せず、可視サンプルのみをシェーディング計算する。

Gバッファには色、法線、深度、スペキュラなどがある。

### シェーディングパス

各ライトの境界領域(bounding volumes)をジオメトリとしてスクリーンに描画することでラスタライザがライトの割り当てを行う。
フラグメントシェーダはGバッファの内容を読み取ってシェーディングを行う。
計算した色はフレームバッファにブレンドする。
これなら、各ライトを独立して処理できる。

### Stencil Buffer Optimization[Arvo03]

ステンシルシャドウと要領は同じ。

- ライトボリュームの背面を描画して、深度テストに失敗した所のステンシルをマスクする。
- ライトボリュームの前面を描画して、ステンシルテストに合格した所のシェーディングを計算する。

これにより、ライトボリュームの外にあるピクセルを除外できる。
シェーディングが必要なところだけを的確に狙い撃つため、効率が改善する。
モダンなハードウェアで大量のライトを扱う状況に対して効率的に実装できるかは不明。

### その他のバリエーション(variants)

Deferred Lighting
: Gバッファには法線とshininessのみを格納する。
  Gバッファをもとにライトの影響を計算して、拡散色と鏡面色をバッファに格納する。
  最後に、もう一度ジオメトリを描画して、マテリアルにライトの影響と掛け合わせる。

Light PrePass
: 基本はDeferred Lightingと同じだが、スペキュラが単色。

deferredとパフォーマンスは似たりよったり。
それよかシェーディングモデルの制限が増えてたりする。

### まとめ

#### 良い点

- 自明なライト管理: カリングしてライト境界を描画するだけ
    - 大量ライトが可能に
- 簡単な(ライトの)シェーダ管理: 1シェーダにライトのタイプは1つだけ
- 高シェーディング効率
    - 照らされているサンプルだけ陰影を計算すればいい
- オーバードローなし
- ジオメトリパスが1つ
- シャドウマップが再利用できる

#### 悪い点

- 透明処理ができない
- フレームバッファが巨大になる
    - MSAAを使うなら特に
    - ライトを累積するために高精度フォーマットが必要
- 複数のシェーディングモデルを扱うのが難しい
    - 特定のジオメトリにカスタムしたりとか
- かなりのメモリ帯域を使う
