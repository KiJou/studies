---
title: Evolution of Programmable Models for Graphics Engines [@Tatarchuk2017]
numberSections: false
---

# グラフィクスのプログラミングモデルは複雑である[Programming Models for Graphics are Complex]

今日のトークでは、リアルタイムグラフィクスで用いるプログラミングモデルと、これらを改善できそうな方法に触れたい。会場の皆が容易に同意するであろう通りに、グラフィクスエンジニアリングのプログラミングモデルとして我々が現時点で持っているものはかなり複雑な猛獣[beast]である。我々はその領域で数々の特徴を持つ。

# 問題空間[Problem space]

## プラットフォーム及びAPIの多様性[Platform and API divergence]

近年のグラフィクスプログラミングはとても断片化した複雑なプラットフォームやAPIのエコシステムの上に生きている。

##リソース管理は必須である[Resource Management is Required]

グラフィクスに関連することを行うには何事にも、リソース(テクスチャ、シェーダ、メッシュ、アニメーション、など)をどうにかして得なければならない。これはしばしば大量の定型句[boiler plate]を意味し得る。

## ヘテロジニアスな計算モデル[Heterogenous Computational Models]

その上、ヘテロジニアスなマシンへのプログラミングについて考える必要がある --- GPUとCPUは大幅に異なるプログラミングモデルを持ち、ゲーム及びグラフィクスエンジンのプログラミングはすべての構成要素を提供する必要がある。グラフィクスアルゴリズム研究のアプリケーションも同様[ditto]。

##高級なアルゴリズム空間は深遠な構成可能性を必要とする[Rich Algorithm Space Needs Deep Configurability]

リアルタイムグラフィクスで用いる高レベルパイプラインアルゴリズムは急増している[have an explosion of] --- フォワードレンダリング、Forward+、ディファードレンダリング、Clusteredアルゴリズム、Z-Binning、GPUオクルージョン管理、例えばfine-prune tiled lightingのような様々なTiledアプローチ、などなど。これらすべては特定のパイプライン目標に対する有用性[utility]を持つ。例えば、VRはシングルパスのフォワードレンダラから利益を得るが、多くのコンソールゲームはディファードレンダリングを採用している。これらすべてのアルゴリズムは、それをサポートする予定である場合、基礎にあるエンジンの深い構成可能性を必要とする。

## コンテンツクリエイターとエンジニアリングの橋渡し[Bridge Content Creators and Engineering]

もちろん、ゲームエンジンやグラフィクスアプリケーションはしばしばコンテンツとエンジニアリングの橋渡しとして役立つ。

### グラフィクスプログラマーの務めはコンテンツ(アート)とプラットフォーム(ハードウェア)の間のインターフェイスを定義、熟考することである[The task of a graphics programmer is to define and mediate the interface between content (art) and platform (HW)]

[Foley2016: Open Problems in Real-Time Rendering course. SIGGRAPH 2016]

### コンテンツとプラットフォーム[Content and Platform]

このスライドの上部分には *コンテンツ* がある。これはアーティストが理解して作成しようとする概念のすべてである。我々には形状、動作、外観、照明なようなものがある。
このスライドの下部分には、我々が対象とする *ハードウェアプラットフォーム* がある。これは、スレッドやSIMDのサポートを持つCPUコアや伝統的なラスタライゼーションパイプラインとある種の汎用用途の計算の両方をサポートするGPUハードウェアがあり、近年似たようなものが見られる。
アーティストが生成するものを得るために、我々はコンテンツをハードウェアプラットフォームにマップする方法に対する計画を持つ必要がある。

### アセット毎、プラットフォーム毎マッピングを特定する？[Specify mapping per-asset, per-platform?]

これを行い得る(悪い)方法のひとつはアセット毎、プラットフォーム毎の基準でコードを書くことによるものである。これは明らかにスケールしない。つまりは、我々が実際に行っていることではない。And that gets us to the heart of the definition...

### アプリケーション固有のインターフェイスを用いてマップする[Map using application-specified interface]

実践で実際に行うと主張することは以下のことである。

グラフィクスプログラマーは *インターフェイス* --- 特定のエンジンやプロダクションに特有な概念を定義する。
*これ* はアニメーションリグを表現するであろう方法である。
*これ* は反射関数を表現するであろう方法である。

このインターフェイスでの表現のいくつかは(例えば、メッシュでは)純粋なデータであるかもしれないし、その他は(例えば、アーティストが"noodle graph"のようなパターン生成を記述する場合に)コードを含むかもしれない。

<!-- p.20 -->

いずれにしても、その務めは以下である。

- 選ばれたインターフェイスにおける概念に従うように、アーティストによって生成されるアセットを対応させる。そして、
- ひとつ以上の対象のプラットフォームにこれらの概念を効率的に対応させる。

## ビジュアルフィードバックのために必要とされる頻繁なイテレーション[Frequent Iteration Needed for Visual Feedback]

そしてもちろん、テクニックに対してイテレーションの回数が増やせれば、一般には、それはより良くなる。故に、*開発者が最短距離で成功するため[success of the developper directly]* に必要不可欠なものはこれら自身のイテレーションループである。

# グラフィクスコミュニティとしての我々の目標[Our goal as graphics community]

究極的にグラフィクスプログラマーとしての我々の目標は何か。極簡単に言えば、グラフィクスプログラマーとしての我々の目標はグラフィクス技術を刷新することである。

# グラフィクスを刷新するときに設計すること[When innovating graphics, we design:]

これを行うとき、我々は以下に焦点を当てる。

- 新しいハードウェア能力の設計(CPU/GPU/など)
- 新しいグラフィクス低レベルAPIの設計(例: DirectX 12、GCN、など)
- ヘテロジニアスな計算モデルの設計
- 新しいドメイン言語の設計(HLSL、Cg、など)
- 新しいアルゴリズムの設計(フォワード対ディファード、FPTL、Clustered、など)
- 新しいワークフローの設計(コンテンツ作成(プロシージャル植生配置、LODシステム、など)や開発ワークフロー(実際のアルゴリズムの開発))
- 新しいパフォーマンス技術の設計

# 本日は触れないトピック[Not covering these topics today:]

本日はグラフィクス/ゲームエンジンにおける開発のプログラミングモデルに焦点を当てているので、以下の進化や変化には触れないだろう。

- 新しいハードウェア能力
- 新しいグラフィクス低レベルAPI
- 新しい計算モデル
- 新しいドメイン言語

<!-- p.28 -->

- おすすめの読み物:
    - [@Foley2016]
    - [@Ante2017]
    - [@Lauritzen2017]

Unityでは実際に、C#のジョブ化APIをサポートするためのC#からILへのコンパイラを開発したり、とプログラミングモデルの改善を活発に調査している。

# 本日の中心[Today's Focus]

- 新しいアルゴリズム
- 新しいワークフロー
- 新しいパフォーマンス技術

本日は、グラフィクスエンジンにおいて新しい開発ワークフローを用いることによって新しいアルゴリズムのより良い開発を可能にするために我々ができることを述べたいと思う。言い換えれば、新しいアルゴリズムとレンダリングパイプラインによるグラフィクスゲームエンジンのプログラミングモデルの進化である。

# 目標: グラフィクス技術の容易な革新[Goals: Easy Innovation for Graphics Techniques]

言い換えれば、他の変数に制約を課しつつ、グラフィクスの *技術*、*可用性*、*パフォーマンス* を刷新する方法である。

# 我々の制約とは？[What are our constraints?]

前に進むために、すべてがその制約の選択を定義して理解する必要がある。

# なぜ進化には制約が重要なのか？(プログラマブルモデルか否か)[Why do constraints matter for evolution? (Programmable models or otherwise)]

なぜプログラマブルモデルの進化には制約が重要であるのか？

# 制約の利点[Constraints Benefits]

- 軸を固定して、スタックの残りの進化に焦点を当てる
    - 例: HLSL、コンピュート(ドメイン固有言語)

制約は軸を固定して、スタックの残りの進化に焦点を当てることができるようになる。低レベルAPIはいくつかの側面を制約し、その他のアクセシビリティに焦点を当てる。例: スケジューリング管理の利便性ではなく、Wavefrontスケジューリングのアクセシビリティに焦点を当てる計算モデル --- 制約はGPUがスケジューリングの厳密な詳細を管理することであり、GPUで実行しているカーネルを記述することに焦点を当てる。
ドメイン固有言語は制約から大幅に利益を得る --- 例: 一般的なC++プログラミング機能を欠くHLSL(ハードウェアを直接対象とすることでシェーダ開発において大きな革新を可能にする)。

<!-- p.35 -->

- ソフトウェアアーキテクチャはしばしば同じ原則を用いる
- いくつかの側面に制約を課すことはその領域において高速なイノベーションを可能にする

<!-- p.36 -->

RenderMonkeyは、頂点シェーダとピクセルシェーダを作成すること以外のプログラムについてのすべてのことに制約を課し、これらのプログラムを実行するのに必要なスキャフォールディング要素のすべてで動作するためのワークフローを大幅に単純化する、素晴らしい例である。

<!-- p.37 -->

ShaderToy
(ピクセルシェーダのみで記述する)

<!-- p.38 -->

[@Tatarchuk2015]では、保証されたスレッドセーフ単位を記述するために制約を課したAPIを提供する。

<!-- p.40 -->

これはマルチスレッドなグラフィクス機能を記述するための高速なイテレーションを可能にした。

<!-- p.41 -->

[@ODonnell2017]は、レンダパスを特定するための制約を課したAPIを提供して、リソース管理の可視化の簡単なイテレーションを可能にした。

<!-- p.42 -->

このアーキテクチャはリソースエイリアシングによりメモリ節約を生み出し、非同期コンピュート実行の設計の助けになり、レンダリングパイプライン構成を単純化した。注意点として、これは依然としてC++でプログラムされた。

# 革新にはどんな原則が役立つか？[What principles help innovation?]

より良いイノベーションをサポートするフレームワークの属性とは？

<!-- p.44 -->

- 再現性のある実行の挙動の容易な共有

再現性のある挙動の容易な共有はコミュニティ全体を通した学習を加速させる。もちろん、完全なコンテンツでエンドツーエンド実行できる実行ファイルが最善である。

<!-- p.45 -->

- 広範囲にサポートするインフラストラクチャ/サービス

イノベーションに役立つフレームワークはユーザーがボイラープレートコードを回避できるソリッドなインフラストラクチャを提供すべき。グラフィクスでは、これはアセットやオブジェクトの管理の提供、スレッディング、低レベルプラットフォームのサポート、などを意味する。

<!-- p.46 -->

- ゲームエンジンがそれを容易に提供する
    - 完全なコンテンツを持つUnity個人版プロジェクトを共有する

<!-- p.47 -->

- フレームワークは柔軟性を持つべき
    - 重いインフラストラクチャレイヤは革新を妨げるべきではない

# 制約を枷とするべからず[Mustn't Let Constraints Become Shackles]

- 何から何まで[the whole enchilada]扱うことができないときは主に制約を大切にする
- 能力が成長するのに伴い、トレンドは常に一般化に向かう
    - 開発しやすいため

制約それ自身に関して、問題が対処するには大きすぎるときにすべての制約は良いことに注意すべきである。システムの能力が成長するたびに、システムはこの量の柔軟性をサポートするので、より柔軟なモデルを作成するために常に一般化することにも注意する。

# 改善するのに日和見性の一般化を用いる --- パフォーマンスや能力が成熟するたび[Use Opportunistic Generalization to Improve - As performance or capabilities mature]

TODO
