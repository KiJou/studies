---
title: Evolution of Programmable Models for Graphics Engines [@Tatarchuk2017]
numberSections: false
---

# グラフィクスのプログラミングモデルは複雑である[Programming Models for Graphics are Complex]

今日のトークでは、リアルタイムグラフィクスで用いるプログラミングモデルと、これらを改善できそうな方法に触れたい。会場の皆が容易に同意するであろう通りに、グラフィクスエンジニアリングのプログラミングモデルとして我々が現時点で持っているものはかなり複雑な猛獣[beast]である。我々はその領域で数々の特徴を持つ。

# 問題空間[Problem space]

## プラットフォーム及びAPIの多様性[Platform and API divergence]

近年のグラフィクスプログラミングはとても断片化した複雑なプラットフォームやAPIのエコシステムの上に生きている。

##リソース管理は必須である[Resource Management is Required]

グラフィクスに関連することを行うには何事にも、リソース(テクスチャ、シェーダ、メッシュ、アニメーション、など)をどうにかして得なければならない。これはしばしば大量の定型句[boiler plate]を意味し得る。

## ヘテロジニアスな計算モデル[Heterogenous Computational Models]

その上、ヘテロジニアスなマシンへのプログラミングについて考える必要がある --- GPUとCPUは大幅に異なるプログラミングモデルを持ち、ゲーム及びグラフィクスエンジンのプログラミングはすべての構成要素を提供する必要がある。グラフィクスアルゴリズム研究のアプリケーションも同様[ditto]。

##高級なアルゴリズム空間は深遠な構成可能性を必要とする[Rich Algorithm Space Needs Deep Configurability]

リアルタイムグラフィクスで用いる高レベルパイプラインアルゴリズムは急増している[have an explosion of] --- フォワードレンダリング、Forward+、ディファードレンダリング、Clusteredアルゴリズム、Z-Binning、GPUオクルージョン管理、例えばfine-prune tiled lightingのような様々なTiledアプローチ、などなど。これらすべては特定のパイプライン目標に対する有用性[utility]を持つ。例えば、VRはシングルパスのフォワードレンダラから利益を得るが、多くのコンソールゲームはディファードレンダリングを採用している。これらすべてのアルゴリズムは、それをサポートする予定である場合、基礎にあるエンジンの深い構成可能性を必要とする。

## コンテンツクリエイターとエンジニアリングの橋渡し[Bridge Content Creators and Engineering]

もちろん、ゲームエンジンやグラフィクスアプリケーションはしばしばコンテンツとエンジニアリングの橋渡しとして役立つ。

### グラフィクスプログラマーの務めはコンテンツ(アート)とプラットフォーム(ハードウェア)の間のインターフェイスを定義、熟考することである[The task of a graphics programmer is to define and mediate the interface between content (art) and platform (HW)]

[Foley2016: Open Problems in Real-Time Rendering course. SIGGRAPH 2016]

### コンテンツとプラットフォーム[Content and Platform]

このスライドの上部分には *コンテンツ* がある。これはアーティストが理解して作成しようとする概念のすべてである。我々には形状、動作、外観、照明なようなものがある。
このスライドの下部分には、我々が対象とする *ハードウェアプラットフォーム* がある。これは、スレッドやSIMDのサポートを持つCPUコアや伝統的なラスタライゼーションパイプラインとある種の汎用用途の計算の両方をサポートするGPUハードウェアがあり、近年似たようなものが見られる。
アーティストが生成するものを得るために、我々はコンテンツをハードウェアプラットフォームにマップする方法に対する計画を持つ必要がある。

### アセット毎、プラットフォーム毎マッピングを特定する？[Specify mapping per-asset, per-platform?]

これを行い得る(悪い)方法のひとつはアセット毎、プラットフォーム毎の基準でコードを書くことによるものである。これは明らかにスケールしない。つまりは、我々が実際に行っていることではない。And that gets us to the heart of the definition...

### アプリケーション固有のインターフェイスを用いてマップする[Map using application-specified interface]

実践で実際に行うと主張することは以下のことである。

グラフィクスプログラマーは *インターフェイス* --- 特定のエンジンやプロダクションに特有な概念を定義する。
*これ* はアニメーションリグを表現するであろう方法である。
*これ* は反射関数を表現するであろう方法である。

このインターフェイスでの表現のいくつかは(例えば、メッシュでは)純粋なデータであるかもしれないし、その他は(例えば、アーティストが"noodle graph"のようなパターン生成を記述する場合に)コードを含むかもしれない。

<!-- p.20 -->

いずれにしても、その務めは以下である。

- 選ばれたインターフェイスにおける概念に従うように、アーティストによって生成されるアセットを対応させる。そして、
- ひとつ以上の対象のプラットフォームにこれらの概念を効率的に対応させる。

## ビジュアルフィードバックのために必要とされる頻繁なイテレーション[Frequent Iteration Needed for Visual Feedback]

そしてもちろん、テクニックに対してイテレーションの回数が増やせれば、一般には、それはより良くなる。故に、*開発者が最短距離で成功するため[success of the developper directly]* に必要不可欠なものはこれら自身のイテレーションループである。

# グラフィクスコミュニティとしての我々の目標[Our goal as graphics community]

究極的にグラフィクスプログラマーとしての我々の目標は何か。極簡単に言えば、グラフィクスプログラマーとしての我々の目標はグラフィクス技術を刷新することである。

# グラフィクスを刷新するときに設計すること[When innovating graphics, we design:]

これを行うとき、我々は以下に焦点を当てる。

- 新しいハードウェア能力の設計(CPU/GPU/など)
- 新しいグラフィクス低レベルAPIの設計(例: DirectX 12、GCN、など)
- ヘテロジニアスな計算モデルの設計
- 新しいドメイン言語の設計(HLSL、Cg、など)
- 新しいアルゴリズムの設計(フォワード対ディファード、FPTL、Clustered、など)
- 新しいワークフローの設計(コンテンツ作成(プロシージャル植生配置、LODシステム、など)や開発ワークフロー(実際のアルゴリズムの開発))
- 新しいパフォーマンス技術の設計

# 本日は触れないトピック[Not covering these topics today:]

本日はグラフィクス/ゲームエンジンにおける開発のプログラミングモデルに焦点を当てているので、以下の進化や変化には触れないだろう。

- 新しいハードウェア能力
- 新しいグラフィクス低レベルAPI
- 新しい計算モデル
- 新しいドメイン言語

<!-- p.28 -->

- おすすめの読み物:
    - [@Foley2016]
    - [@Ante2017]
    - [@Lauritzen2017]

Unityでは実際に、C#のジョブ化APIをサポートするためのC#からILへのコンパイラを開発したり、とプログラミングモデルの改善を活発に調査している。

# 本日の中心[Today's Focus]

- 新しいアルゴリズム
- 新しいワークフロー
- 新しいパフォーマンス技術

本日は、グラフィクスエンジンにおいて新しい開発ワークフローを用いることによって新しいアルゴリズムのより良い開発を可能にするために我々ができることを述べたいと思う。言い換えれば、新しいアルゴリズムとレンダリングパイプラインによるグラフィクスゲームエンジンのプログラミングモデルの進化である。

# 目標: グラフィクス技術の容易な革新[Goals: Easy Innovation for Graphics Techniques]

言い換えれば、他の変数に制約を課しつつ、グラフィクスの *技術*、*可用性*、*パフォーマンス* を刷新する方法である。

# 我々の制約とは？[What are our constraints?]

前に進むために、すべてがその制約の選択を定義して理解する必要がある。

<!-- p.32 -->

TODO
