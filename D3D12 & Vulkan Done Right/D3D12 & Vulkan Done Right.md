---
title: 'D3D12 & Vulkan Done Right'
author:
- name: 'Gareth Thomas'
  affiliation: 'AMD'
bibliography: 'bibliography.bib'
link-citations: true
---
# D3D12 & Vulkan Done Right [@Thomas2017]

## バリア(Barriers)

- **いまだに** ハイレベルAPIでパフォーマンスが落ちる原因、第一位。
- でも、バリアを正しくするのは難しい。

### 問題(Issues)

- バリアは足りないとデータが壊れる(corruption)。
- バリアが多すぎると一括処理や状態遷移に支障が出る。
- 大抵のバリアの間違いはデバッグレイヤやバリデーションレイヤで補足できる。

### 解決策(Solutions)

- 手動で置いていく。
    - シンプルなエンジンならうまくいく。
    - すぐにゴチャゴチャになってしまう。
- "シーンの背後(behind the scenes)"にバリアを自動生成する。
    - 追尾しているリソースごと。
    - 正しくするのが難しい。
    - "要求に応じて(on demand)"遷移させると、バッチ処理不足や時折の最適でないバリア設置を引き起こす。
- D3D12でもレンダパスを導入する。
    - ポータビリティが向上する。
- フレームグラフ(Frame graph)
    - 依存関係を各パスごとに解析する。
    - 各リソースのスコープが定まるので、メモリのエイリアスを付けることができる。
    - ケーススタディ: TiagoやYuriyのトーク(GDC2017)

## コピーキュー(Copy Queue)

- PCIe上でコピーを行うのに特化した専用ハードウェア。
    - 他のキューとは独立して処理する。

ものは簡単で、**システムメモリからローカル[^local_memory]にコピーするなら、コピーキューを使うべし**

[^local_memory]: ここでいう"ローカル"は、GPUから見て近場にあるということ。

- ストリーミングに最適。
- mGPUはP2Pで転送する。
- コピーキューを待たないようにするために、GPUへ十分な数の仕事を回せているかを確かめる。
    - ローカルメモリが必要になる前に、理想を言えば数フレーム前だが、できるだけ早めにコピーを開始する。

- ローカルからローカルへのコピーにはコピーキューを使わない。
    - かわりに、グラフィックスキューやコンピュートキューを使う。
    - コピーキューはPCIeの速度で動作する。
    - (ただし、メモリのデフラグのような"裏(background)"で行うならコピーキューを使うことができる。)

### メモリのデフラグ(Memory Defragging)

- 例えば1フレームあたり1%の帯域幅を使うとしたら、かわりにコピーキューを使う。
    - グラフィックスキューをレンダリングに専念させるため。
    - コピーキューがビジーでないフレームでやる。

## パイプラインシェーダ管理(Pipeline Shader Management)

TODO

## References
