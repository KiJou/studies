---
title: A Survey of Real-Time Hard Shadow Mapping Methods [@Scherzer2011]
---
# はじめに {id="sec:1"}

シャドウはシーンにおける光輸送の重要な結果である。これらはオブジェクト同士やオブジェクトと光源の幾何的な関係を明確にするための見た目の手がかりを与える。面光源[area light sources]によるソフトシャドウはゲームのようなアプリケーションにおいてますます人気になっている一方、多くのアプリケーションは依然として、ポイントライトやディレクショナルライトによってもたらされる、ハードシャドウを用いている。アプリケーションにおいていくつかの光源にソフトシャドウが用いられている場合でも、多くの光源はハードシャドウやフィルタリング技術を用いて若干ソフト化されたシャドウをもたらすポイントライトとして許容できる程度にモデル化することができる(太陽によってもたらされる影がこの例に当たる)。我々の調査では、最も広く使われているシャドウアルゴリズムであるので、ハードシャドウに注目したいが、これらのポテンシャルは、この問題に関する論文が大量に存在するが故に、特定のアプリケーションに対して最適なアルゴリズムを選ぶことが難しく、滅多にフル活用されることがない。

ある点が光源の視点から見えないとき、この点は影の中にある。この点に光線が到達するのを遮るオブジェクトはシャドウキャスター[shadow caster]、オクルーダー[occluder]、ブロッカー[blocker]と呼ばれる。影の中にある点を持つオブジェクトはシャドウレシーバー[shadow receiver]と呼ばれる([@fig:1]参照)。リアルタイムハードシャドウには*ジオメトリベース*と*イメージベース*の2つの主要なアプローチが存在する。

![シャドウキャスティングの図解](){#fig:1}

シャドウアルゴリズムはコンピューターグラフィクスそれ自体とほぼ同じくらい前から存在しているにも関わらず、堅牢で効率的なハードシャドウ生成は未だに未解決の問題である。ジオメトリベースのアルゴリズムはピクセルパーフェクトな結果を生み出す一方、異なるビュアーおよびライトの配置[constellations]による堅牢性の問題に悩まされる。これらの汎用性[versatility]により、ジオメトリベースのアルゴリズムにおけるほぼすべての研究は*シャドウボリューム*に注目している[@Cro77]。この技術の主なデメリットはすべてのシャドウボリュームをレンダリングするのに必要な大量のフィルレートである。加えて、輪郭検出を行わなければならず、ポリゴンが豊富[polygon-rich]なシーンでは、これは別のパフォーマンスペナルティを意味する。最後に、エッジを検出して押し出す[extrude]単純な方法が必要とされるので、ポリゴンデータのみで処理できる。

その一方で、イメージベースのアルゴリズムは、これらの複雑さが標準のシーンレンダリングと同様であるため、非常に高速である。*シャドウマッピング*[@Wil78]は任意のキャスターおよびレシーバーの配置を扱うことができ、セルフシャドウを計算に含めることができ、ポリゴンでない入力すら処理できるイメージベースのアルゴリズムである。基本のシャドウアルゴリズムは[@sec:2]にて触れる。

残念ながら、シャドウマッピングもまたいくつもの欠点に悩まされる。第1に、オムニディレクショナルライト[omni-directional lights]が単一の錐台を用いてキャプチャーできない。この問題は[@sec:2]で議論される。

第2の、より厳しい問題はシャドウマップのサンプリングとシャドウマップに投影されたイメージピクセルのサンプリングが通常では一致しないために起こるエイリアシングアーティファクトである。[@sec:3]では、このエイリアシングアーティファクトを解析し、この解析からいくつかの異なる誤差の種類を導きたい。一方[@sec:4]では、サンプリング誤差を減らすことができる手法の概要を与える。

第3の問題は、テクセルごとにシャドウマップに格納される深度情報におけるアンダーサンプリングおよび不正確さによって引き起こされる正しくないセルフシャドウである。これは堅牢な結果をもたらすために深度テストをバイアスする(*深度バイアス[depth biasing]*)必要性を生み出す。我々は[@sec:5]においてこの問題への様々なアプローチを議論する。

[@sec:6]では第2パスにおいてシャドウマップ中に格納された情報をより良く再構築するためのサンプリング理論を適用するフィルタリング技術を紹介する。最後に、[@sec:7]では与えられたアプリケーションに対して最適なアルゴリズムを選ぶ方法についてのガイドラインを与える。

# 基本 {id="sec:2"}

TODO

# 3 {id="sec:3"}

# 4 {id="sec:4"}

# 5 {id="sec:5"}

# 6 {id="sec:6"}

# 7 {id="sec:7"}
