---
title: A Survey of Real-Time Hard Shadow Mapping Methods [@Scherzer2011]
---
# はじめに {id="sec:1"}

シャドウはシーンにおける光輸送の重要な結果である。これらはオブジェクト同士やオブジェクトと光源の幾何的な関係を明確にするための見た目の手がかりを与える。面光源[area light sources]によるソフトシャドウはゲームのようなアプリケーションにおいてますます人気になっている一方、多くのアプリケーションは依然として、ポイントライトやディレクショナルライトによってもたらされる、ハードシャドウを用いている。アプリケーションにおいていくつかの光源にソフトシャドウが用いられている場合でも、多くの光源はハードシャドウやフィルタリング技術を用いて若干ソフト化されたシャドウをもたらすポイントライトとして許容できる程度にモデル化することができる(太陽によってもたらされる影がこの例に当たる)。我々の調査では、最も広く使われているシャドウアルゴリズムであるので、ハードシャドウに注目したいが、これらのポテンシャルは、この問題に関する論文が大量に存在するが故に、特定のアプリケーションに対して最適なアルゴリズムを選ぶことが難しく、滅多にフル活用されることがない。

ある点が光源の視点から見えないとき、この点は影の中にある。この点に光線が到達するのを遮るオブジェクトはシャドウキャスター[shadow caster]、オクルーダー[occluder]、ブロッカー[blocker]と呼ばれる。影の中にある点を持つオブジェクトはシャドウレシーバー[shadow receiver]と呼ばれる([@fig:1]を参照)。リアルタイムハードシャドウには*ジオメトリベース*と*イメージベース*の2つの主要なアプローチが存在する。

![シャドウキャスティングの図解](){#fig:1}

シャドウアルゴリズムはコンピューターグラフィクスそれ自体とほぼ同じくらい前から存在しているにも関わらず、堅牢で効率的なハードシャドウ生成は未だに未解決の問題である。ジオメトリベースのアルゴリズムはピクセルパーフェクトな結果を生み出す一方、異なるビュアーおよびライトの配置[constellations]による堅牢性の問題に悩まされる。これらの汎用性[versatility]により、ジオメトリベースのアルゴリズムにおけるほぼすべての研究は*シャドウボリューム*に注目している[@Cro77]。この技術の主なデメリットはすべてのシャドウボリュームをレンダリングするのに必要な大量のフィルレートである。加えて、輪郭検出を行わなければならず、ポリゴンが豊富[polygon-rich]なシーンでは、これは別のパフォーマンスペナルティを意味する。最後に、エッジを検出して押し出す[extrude]単純な方法が必要とされるので、ポリゴンデータのみで処理できる。

その一方で、イメージベースのアルゴリズムは、これらの複雑さが標準のシーンレンダリングと同様であるため、非常に高速である。*シャドウマッピング*[@Wil78]は任意のキャスターおよびレシーバーの配置を扱うことができ、セルフシャドウを計算に含めることができ、ポリゴンでない入力すら処理できるイメージベースのアルゴリズムである。基本のシャドウアルゴリズムは[@sec:2]にて触れる。

残念ながら、シャドウマッピングもまたいくつもの欠点に悩まされる。第1に、オムニディレクショナルライト[omni-directional lights]が単一の錐台を用いてキャプチャーできない。この問題は[@sec:2]で議論される。

第2の、より厳しい問題はシャドウマップのサンプリングとシャドウマップに投影されたイメージピクセルのサンプリングが通常では一致しないために起こるエイリアシングアーティファクトである。[@sec:3]では、このエイリアシングアーティファクトを解析し、この解析からいくつかの異なる誤差の種類を導きたい。一方[@sec:4]では、サンプリング誤差を減らすことができる手法の概要を与える。

第3の問題は、テクセルごとにシャドウマップに格納される深度情報におけるアンダーサンプリングおよび不正確さによって引き起こされる正しくないセルフシャドウである。これは堅牢な結果をもたらすために深度テストをバイアスする(*深度バイアス[depth biasing]*)必要性を生み出す。我々は[@sec:5]においてこの問題への様々なアプローチを議論する。

[@sec:6]では第2パスにおいてシャドウマップ中に格納された情報をより良く再構築するためのサンプリング理論を適用するフィルタリング技術を紹介する。最後に、[@sec:7]では与えられたアプリケーションに対して最適なアルゴリズムを選ぶ方法についてのガイドラインを与える。

# 基本 {id="sec:2"}

シャドウマッピングでは、2パスでシャドウ計算が行われる。まず、(*ライト空間*で)光源から見える現在のシーンの深度イメージ(*シャドウマップ*)がレンダリングされ、格納される([@fig:2]左を参照)。このイメージはテクセルごとに光源に最も近いオブジェクトの深度を含んでいる。この深度の背後にあるすべては光源から見えず、それ故に、影の中にある、という発想である。次のパスでは、そのシーンが(*ビュー空間で*)ビューポートからレンダリングされ、各3Dフラグメントがライト空間に再投影される。再投影されたフラグメントの深度がシャドウマップに格納された深度より遠くある(*深度テスト*)ならば、そのフラグメントは影の中にあり、そのようにシェーディングされる([@fig:2]➡を参照)。

![シャドウマッピング: まず、シーンの深度イメージ(*シャドウマップ*)は光源のビューポートからのレンダリングによって生成される(左)。次に、ビュー空間の各フラグメントの再投影された深度がシャドウマップに格納された深度と比較される(右)。](){#fig:2}

オムニディレクショナルライトはその球状のビューにより複数のバッファを用いて計算されなければならない。単一の錐台ではこれを反映できず、多くのシャドウマップと錐台がこの球状のビューを分割するために構築されるなければならない。最も一般的なアプローチでは6つの錐台(キューブマップの面ごとに1つ)を用いるが、このようなライトに大きなパフォーマンスペナルティを引き起こす。より高速な解決法は放物線[parabolic]マッピング[@BAS02b]を用いることで達成させることができる。これは結果として半球ごとに1つずつの計2つのレンダリングとなるだけでなく、グラフィクスハードフェアにおいて効率的に放物線マッピングを模倣する(線を曲線にする)方法の問題も生み出す。最も単純な解決法では、シーンが頂点だけの放物線マッピングとして事足りるように十分に細切れにされている[tessellated finely]と仮定する。アプローチには、モダンなハードウェアで直接的に曲線を計算するように、より低速で入り組んだものが存在する[@GHFP08]。

# 誤差解析 {id="sec:3"}

シャドウマップをレンダリングするとき、与えられたシーンの離散的サンプリング表現[discretely sampling representation]を生成する。シャドウマップ操作は光源に関する表面の可視性条件を再構築するためにこの表現を後に用いる。故に、シャドウマッピングについてテクスチャマッピングと似た信号の再構築処理として考えると便利である。信号の再構築は以下の手順に従う。

1. 最初に、入力関数を*サンプリング*する。すなわち、レンダリングを用いてシャドウマップを生成する。最初のサンプリングフェーズではエイリアシングを回避するために行える帯域制限は存在しないので、サンプリング周波数は理想的にはその信号のナイキスト周波数より大きい必要がある。深度比較を計算した後の実際のシャドウ信号は鋭いエッジを持ち、それ故に、無制限の周波数を持つことに注意する。
2. そのサンプリング表現から信号を*再構築*(または、補間)する。シャドウマッピングでは、これはフラグメントをシャドウマップ空間に投影して、シャドウマップテストを計算するときに発生する。深度テストの非線形性により、素直なシャドウマッピングに対して最近傍探索[nearest-neighbor lookup]のみが可能である。
3. 対象とする出力解像度では高すぎる周波数を回避するために再構築された信号に*帯域制限*(または、事前フィルタリング)を行う。これは深度テストの非線形性によりシャドウマッピングに対して簡単には[straightforwardly]できない。
4. 再構築された信号を最終ピクセル位置で*リサンプリング*する。

離散的サンプリングのシナリオでは、再構築とリサンプリングが結合しているので、再構築は最終ピクセル位置でのみ発生することに注意する。

上記の手順による信号の再構築処理としてのシャドウマッピングのメンタルモデルを容易にするため、シャドウマッピング操作を特定のオブジェクトがすでに焼き込まれたシャドウテストの結果を持つ投影テクスチャマップ[projective texture map]によるオブジェクトのテクスチャリングとして考えることができる。これは、そのテクセルが光の中にあるフラグメントに対して1に、影の中にあるフラグメントに対して0に塗り潰されていることを意味する。この方法では、再構築とリサンプリングは、再構築が最近傍探索かバイリニア補間で行われる、帯域制限がミップマッピングを用いて行われる、リサンプリングが単なる最終ピクセル位置での関数の計算である、といったところで標準のシャドウマッピングと比較されることができる。

## 誤差の種類 {id="sec:3.1"}

TODO

# 4 {id="sec:4"}

# 5 {id="sec:5"}

# 6 {id="sec:6"}

# 7 {id="sec:7"}
