---
title: >
Decima Engine: Visibility in Horizon Zero Dawn [@Vale2017]
numberSections: false
---
# はじめに[INTRODUCTION]

# 背景[BACKGROUND]

# 既存のシステム --- モデル[Existing system - Models]

- 我々のモデルデータはMeshResourceによって表現される。
    - 実際には他のMeshResourceの任意のツリー[arbitrary tree]
    - LOD切り替えとマルチメッシュの内部ノード
    - プリミティブデータを持つ静的、および、スキンメッシュのリーフノード

ゲームで見られるような3Dモデルは任意に複雑にできるMeshResourceのツリーである。異なるブランチの間を選択するLODメッシュ、ルートを基準にブランチを配置するためのマルチメッシュを持つ。そして、リーフには、ジオメトリを含む静的メッシュを持つ。他のリーフノードタイプもあるが、このトークと関係はない。

これは、様々なコンテンツワークフローを構築するのに効果的である、とても柔軟なシステムだが、最適化するときに一般的な挙動を見極め、抽出することをより難しくしている。

# 既存のシステム --- インスタンス[Existing system - Instances]

- メッシュはDrawableObjectとしてワールドに配置される。
    - 各々は自身のMeshInstanceTreeを持つ。
    - 効率的な平坦な形式でリソースツリーをエンコードする。
- MeshInstanceTreeリーフノードはDrawableSetupを含む。
    - プリミティブジオメトリ(頂点＆インデックス配列)
    - シェーダとレンダリングオプション
    - ローカルからワールドへの変換
- DrawableObjectのKdツリーは空間的な階層を提供する。

DrawableObjectとしてワールドにメッシュリソースのインスタンスを配置する。これらはランタイムで使われるMeshResourceツリーのより効率的なエンコーディングを持つ。

ある特有の問題はメッシュリソースがツリーのルートであるかを認識していないことであり、これはDrawableObjectによって配置されるときのみ明確になる。

このツリーのリーフノードは、レンダラを送り込むものであるDrawableSetupを含む。各々はレンダリングするのに必要なシェーダを持つジオメトリのチャンクである。これらはコンテンツの残りからレンダラを隔離する。

# 既存のシステム --- クエリ[Existing system - Queries]

- 可視[visible]のDrawableObjectを見つける。
    - Kdツリーを歩く。
    - 各DrawableObjectを錐台カリングする。
- 可視のDrawableSetupを見つける。
    - それぞれの可視DrawableObjectのMeshInstanceTreeを歩く。
    - 関連するLODに降りる[descend]。
    - 各DrawableSetupを錐台カリングする。
- 可視DrawableSetupのリストをレンダラに出力する。

KZ3では、PS3のSPUでソフトウェアオクルージョンカリングを用いて各オブジェクトとセットアップをカリングしていた。

KZ4では、静的コンテンツには遮蔽を含めたすべての可視性を扱うミドルウェアを用いた。

# 既存のシステム --- クエリ[Existing system - Queries]

- すべてのジオメトリに対して同じシステム
    - 静的も動的も同じ方法で取り扱う。
- フレームごとに2つ以上のクエリを実行する。
    - プレイヤーカメラ(透視投影[perspective])
    - 太陽光シャドウマップ(正投影[orthographic])
    - 他のシャドウマップ(透視投影、小さめの錐台)

クエリは一般のレンダリングジョブグラフの一部のCPUジョブである。CPU上の柔軟なジョブアーキテクチャがある --- ほとんどのコード(とすべてのレンダリングコード)はジョブで実行する。

# 既存のシステム --- 問題[Existing system - Problems]

- いくつかのスケーリング問題が存在することを理解した。
    - Kdツリーを再構築するのはコストが高い。
    - MeshInstanceTreeのクエリはコストが高い。
        - 並列ジョブにも関わらず
        - 大きかったり小さかったりするツリーが混ざりあったアンバランスなジョブ
        - それでもKdツリーのクエリは比較的高速
    - APIは少なく大きなオブジェクトを狙っていた。
        - ブロックの構築には**大量の小さなオブジェクト**がある。
        - インターフェースのオーバーヘッド(主にロック処理による)

このシステムはHorizonのワールドサイズにはあまり良いとは言えず、しばしばストリームされるコンテンツとして再構築してみたかったのでKdツリーの複雑さを減らす必要があり、また、MeshInstanceTreeクエリは高価なのでより少なくしたかった。

シーンAPIは本当は少なく大きなオブジェクトを狙っていて、Horizonのワールドを生成するブロック構築には大量の極小オブジェクトがある、という問題もあった。

# 新システム[NEW SYSTEM]

# 基本的な目標[Basic goals]

- オフライン事前計算なし
    - **マジで、なし**
- 既存のコンテンツをサポートする。
- KZ4よりはるかに多くのコンテンツを扱う。
- KZ4よりクエリ時間を短縮する。
    - **クエリはすべてのレンダリングでクリティカルパスである。**

KZ4では可視性ミドルウェアを持っていたが、これは、可視性データを事前計算する必要があり、単に我々がやっていた方法に合わなかったため、ワークフローの問題を引き起こした。変更を適切にテストするために必要な時間が増加した --- それなしにゲームを始めることもできたが、アーティストは、あるべき姿としてモノを確認できるようになる前に、焼き込み処理がバックグラウンドで終了するのを待たなければならなかった。我々は依然としてそれとともにゲームを出荷していたが、Horizonにそれを合わせられるとは考えなかった。

事前計算のアイデアを諦めることはとても難しいと分かっていたが、それは自由をもたらす --- もし焼き込み処理を待たなくて良いとしたら、同様に素早くコードの変更をテストできる。

明らかに、新しいコンテンツを、より高速に扱う必要があった。

# 新システム --- StaticScene[New system - StaticScene]

- 静的データのみを扱う。
    - 動的データより静的データのほうがはるかに多い。
    - 既存のシステムは動的データでうまく動作する。
    - 物事を過度に複雑にしない。
    - 並列に両ジョブを動作する。
- **非同期** コンピュートハードウェアを使う。
    - レンダリングではなくCPUと同期する。
    - 我々が熟知し愛好した、PS3のSPU同期のようなもの。

既存の多目的システムの負荷を軽減するために単目的システムを構築した。StaticSceneは、それが大量にあるということから、静的なジオメトリのみを扱う。

残りの動的なジオメトリを扱うために既存のシステムを使って、並列にジョブを実行することができる。

コンテンツ量をより良く扱える、CPUと同期するのが比較的簡単になると考えたため、PS4の非同期コンピュート能力を使うことを目標とした。

# 入力の制約[Input constraints]

TODO

# 参考文献[References]
