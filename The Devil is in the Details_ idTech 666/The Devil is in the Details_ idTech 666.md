---
title: The Devil is in the Details_ idTech 666 [@Sousa2016]
numberSections: false
---
# 初期の必須条件[Initial Requirements]

- パフォーマンス: 60Hz @ 1080p
- アートワークフローの高速化
- マルチプラットフォームのスケーラビリティ
- KISS
    - ミニマリスト的なコード
    - シェーダ順列が狂ったような数ではない: ~100シェーダ、~350パイプラインステート
- 次世代ビジュアル
    - HDR、PBR
    - 動的で一様なライティング、シャドウ、反射
    - 良好なアンチエイリアシングとVFX

# フレームの解剖[Anatomy of a Frame]

- シャドウキャッシング: ~3.0ms
- Pre-Z: ~0.5ms
- 不透明フォワードパス: ~6.5ms
    - クラスタデータの準備
    - テクスチャコンポジット、ライティング計算
    - 出力: Lバッファ、薄いGバッファ、フィードバックUAV
- ディファードパス: ~2.0ms
    - 反射、AO、フォグ、最終コンポジット
- 透明: ~1.5ms
    - パーティクルライトキャッシング、パーティクル/VFX、草
- ポストプロセス(非同期): ~2.5ms

# ライティング＆シェーディングのためのデータ構造[Data Structure for Lighting & Shading]

- 以下からの派生
    - "Clustered Deferred and Forward Shading" [@Olson2012]
    - "Practical Clustered Shading" [@Person2013]
- Just works™
        - 透明な表面
            - 追加のパスも処理も必要なし
        - 深度バッファから独立
        - 深度の非連続性にわたって偽陽性なし
        - 次のスライドでよりJust Works™する

# クラスタ構造の準備[Preparing Clustered Structure]

- 錐台型のボクセル化/ラスタライゼーション処理
    - 深度スライスあたり1つのCPUジョブで行われる
- 対数関数的な深度分布
    - 拡張されたニア面とファー面
    - $ZSlice = Near_z \cdot \left( \frac{Far_z}{Near_z} \right)^{\frac{slice}{num slices}}$
- 各アイテムをボクセル化する
    - アイテムは以下があり得る: ライト、環境プロブ、デカール
    - アイテムの形状は: OBB、錐台(プロジェクター)
    - スクリーン空間の$min_{xy}$、$max_{xy}$、深度境界で括った[bounded]ラスタライゼーション

<!-- p.6 -->

- refinementはクリップ空間で行われる
    - クリップ空間でのセルはAABBである
    - N個の平面 VS セルのAABB
    - OBBは平面が6つ、錐台は平面が5つ
    - すべてのボリュームに対して同じコード
    - SIMD

```cpp
for (y = MinY; y < MaxY; ++y) {
    for (x = MinX; x < MaxX; ++x) {
        intersects = N個の平面 vs セルのAABB
        if (intersects) {
            アイテムを登録する
        }
    }
}
```

<!-- p.7 -->

- 構造
    - オフセットリスト:
        - 64ビット x グリッドの大きさX x グリッドの大きさY x グリッドの大きさZ
    - アイテムリスト:
        - 32ビット x 256 x ワーストケース(グリッドの大きさX x グリッドの大きさY x グリッドの大きさZ)
- オフセットリスト、要素ごと
    - アイテムリストへのオフセット、ライト/デカール/プロブの数
- アイテムリスト、要素ごと
    - 12ビット: ライトリストへのインデックス
    - 12ビット: デカールリストへのインデックス
    - 8ビット: プロブリストへのインデックス
- グリッドの解像度はかなり低解像度: 16 x 8 x 24
    - フォールスポジティブ: 早期脱出[early out]が軽減＋アイテムリストの読み込みが一様(GCN)

<!-- p.8 -->

ホットスポット: ~300個の光源、~1.2kのデカール

# 世界の描き込み[Detailing the World]

- バーチャルテクスチャ[@10]の更新
- アルベド、スペキュラ、スムーズネス、法線、HDRライトマップ
    - ハードウェアsRGBのサポート
    - スペキュラのアンチエイリアシングのためにToksvig[@11; 12; 13; 14]をスムーズネスに焼き込む
- フィードバックバッファUAVは最終解像度に直接出力する
- 非同期コンピュートのトランスコーディング
    - コストはほぼ無関係[mostly irrelevant]
- 設計上の欠陥が未だに存在する
    - 例えば、リアクティブテクスチャストリーミング = テクスチャポッピング

<!-- p.11 -->

- ジオメトリラスタライゼーションに組み込まれたデカール
- メガテクスチャの"スタンピング"へのリアルタイム交換
    - 高速なワークフロー/低ディスク容量
- Just Works™
    - 法線マップブレンディング
    - すべてのチャンネルで線形補正ブレンディング
    - ミップマッピング/異方性
    - 透明
    - ソート
    - 0個のドローコール
- 8K x 8Kのデカールアトラス
    - BC7

<!-- p.12 -->

- ボックス投影
    - $e_0$、$e_1$、$e_2$はOBBの正規化された大きさ[extent]、$p$は位置

$$
M_{decalProj} = M_{scale} \cdot M_{decal}^{-1}
$$

$$
M_{scale} =
\left|
\begin{array} \\
    \frac{0.5}{sizeX} & 0 & 0 & 0.5 \\
    0 & \frac{0.5}{sizeY} & 0 & 0.5 \\
    0 & 0 & \frac{0.5}{sizeZ} & 0.5 \\
    0 & 0 & 0 & 1
\end{array}
\right|
$$
$$
M_{decal} =
\left|
\begin{array} \\
    e_{0_x} & e_{1_x} & e_{2_x} & p_x \\
    e_{0_y} & e_{1_y} & e_{2_y} & p_y \\
    e_{0_z} & e_{1_z} & e_{2_z} & p_z \\
    0 & 0 & 0 & 1
\end{array}
\right|
$$

- デカールアトラスへのインデックス付け
    - デカールごと: 例えば、パラメータをスケール＆バイアスする

```hlsl
const float4 albedo = tex2Dgrad(decalsAtlas, uv.xy * scaleBias.xy + scaleBias.zw, uvDDX, uvDDY);
```

<!-- p.13 -->

- アーティストにより手動で配置される
    - ブレンディングのセットアップを含む
    - "ブレンドレイヤー"の一般化
- 視錐台ごとに4Kに制限される
    - 一般に1K以下で可視
- LOD
    - アートが最大ビュー距離をセットアップする
    - プレイヤーの品質設定は同様にビュー距離に影響を与える
- 動的な非変形ジオメトリで動作する
    - デカールにオブジェクトの変換を適用する

# ライティング[Lighting]

- 単一の/統一されたライティングコードパス
    - 不透明パス、ディファード、透明、分離したパーティクルライティング用(スライド23-27)
- シェーダ順列が狂ったような数ではない
    - 静的/一貫性のある分岐はこんにちではかなり良い --- 使おう！
    - すべての静的ジオメトリで同じシェーダ
    - より少ないコンテキストスイッチ
- 構成要素
    - ディフューズ間接ライティング: 静的ジオメトリにはライトマップ、動的ジオメトリには放射照度ボリューム
    - スペキュラ間接ライティング: 反射(環境プロブ、SSR、スペキュラオクルージョン)
    - 動的: ライト＆シャドウ

<!-- p.21 -->

```hlsl
// 擬似コード

ComputeLighting(inputs, outputs) {
    ベースのテクスチャを読み込む＆パックする
    for each セル内デカール {
        早期脱出のフラグメント確認
        テクスチャを読み込む
        結果をブレンドする
    }

    for each セル内ライト {
        早期脱出のフラグメント確認
        BRDFを計算する/シャドウを適用する
        ライティングを累積する
    }
}
```

<!-- p.22 -->

- シャドウはアトラスにキャッシュ/パックされる
    - PC: 8K x 8Kのアトラス(高スペック)、32ビット
    - コンソール: 8K x 4K、16ビット
- 距離に応じた可変解像度
- 距離に応じたタイムスライシング
- 静的ジオメトリに対する最適化されたメッシュ
- ライトは移動しない？
    - 静的ジオメトリのシャドウマップをキャッシュする
    - 錐台の内側での更新なし？Ship it
    - 更新する？キャッシュされた結果で動的ジオメトリを合成する
    - 依然としてアニメーションできる(例えば、フリッカー)
- アートセットアップ/クオリティ設定が上記すべてに影響を与える

<!-- p.23 -->

- シャドウ錐台投影行列へのインデックス
- すべてのライトタイプで同じPCFルックアップコード
    - より少ないVGPRプレッシャー
- これはディレクショナルライトのカスケードを含む
    - カスケード間で使われるディザー
    - 単一のカスケードルックアップ
- VSMや派生型を試みた
    - すべていくらかのアーティファクトあり
    - 概念的にはフォワードで良好な将来性を持つ
        - 例えば、ラスタライゼーションからフィルタリング頻度を分離する

<!-- p.24 -->

- 一人称武器のセルフシャドウ
    - 専用のアトラスの一部。アトラス空間を節約するためにコンソールでは無効化される

<!-- p.25 -->

- VGPRプレッシャーに目を配る
    - 長い寿命を持つデータをパックする。例えば、HDR色ではfloat4⇔uint、RGBEエンコード
    - レジスタ寿命を最小化する
    - ネストされたループ/ワーストケースパスを最小化する
    - 分岐を最小化する
    - コンソール(PS4)で56個のVGPR
        - コンパイラの非効率さのためPCではもっと高い☹️ (AMDのコンパイラチームへ、ほんと直してください --- パフォーマンスの計算が狂っちゃうので)
- 将来的に: half精度のサポートが役に立つだろう

- NVIDIA: UBO/定数バッファを使う(分割バッファが必要 = 更なる/醜いコード)
- AMD: SSBO/UAVのほうが良い

# 透明[Transparents]

- 粗いガラスの近似
    - トップのMIPはハーフ解像度で、トータルで4つ
    - ガウシアンカーネル(おおよそGGXローブ)
    - 表面のスムーズネスに応じてMIPをブレンドする
    - 屈折の転送はパフォーマンスのためにフレームごと2つに制限される。
- 表面のパラメータ化/デカール経由のバリエーション

# パーティクルライティング[Particle Lighting]

- 頂点ごと？
    - 高周波ディテールなし(例、シャドウ)
- 頂点ごと＋テッセレーション[@Jansen2011]
    - 大きなサブディビジョンレベルを必要とする
    - GCN/コンソールでは良くない
- ピクセルごと？
    - 大量のピクセルがある/コストが高い
- 混ぜ合わせたソリューションのレンダリング？
    - [@Nguyen2004]？ソートが問題になる
    - MSAAターゲットをエイリアスする？プラットフォーム固有

# 分離したパーティクルライティング[Decoupled Particle Lighting]

- 観察
    - パーティクルは一般に低周波/低解像度
    - 多分パーティクルあたりクアッド1つをレンダリングして、ライティング結果をキャッシュする？
- スクリーン解像度からライティング周波数を分離する＝利益
    - ライティングパフォーマンスがスクリーン解像度から独立
    - スクリーン/距離に依存する適応的解像度ヒューリスティック
        - 例、32x32、16x16、8x8
- 厳密に同じライティングコードパス
- 最終的なパーティクルは依然としてフル解像度である
    - バイキュービックカーネルでライティング結果を読み込む

<!-- p.29 -->

```hlsl
// 擬似コード - パーティクルシェーディングはこのようなモノになる

Particles(inputs, outputs) {
    ...
    const float3 lighting = tex2D(particleAtlas, inputs.texcoord);
    result = lighting * inputs.albedo;
    ...
}
```

<!-- p.30 -->

- 4K x 4Kのパーティクルライトアトラス
    - サイズはプラットフォームごと/クオリティ設定で変化する
    - R11G11B10_FLOAT
- パーティクル解像度ごとに専用アトラス領域
    - いくつか無駄になる、が申し分なく動作する --- Ship it
- かなりパフォーマンスが良い: ~0.1ms
    - ワーストケースで最大1msくらい
    - それでも2、30倍[couple orders magnitude]くらい高速
    - 非同期コンピュートに対する良い候補

# ポストプロセス[Post-Process]

# データフェッチの最適化(GCN)[Optimizing Data Fitching]

- divergent[^divergence]でない処理に対するGCNスカラユニット
- データフェッチの高速化で素晴らしい
    - いくつかのVGPRを節約する
    - 一貫性のある分岐
    - より少ない命令数(SMEM: 64バイト、VMEM: 16バイト)
- クラスタードシェーディングのユースケース
    - 各ピクセルはその属するセルからライト/デカールをフェッチする
    - 生まれつきdivergentだが、解析する価値がある

[^divergence]: Branch divergence: GPUがデータ依存の分岐処理を扱う方法。GPUではスレッドは32/64個ごとにWarpにまとめられ、Warp単位で歩調を合わせて命令を実行するため、Warp内でスレッドごとに分岐先が異なる場合、先に分岐先の計算をすべて行ってしまい、その結果をスレッドが取捨選択することで実現する。一般に計算量が増えるのでパフォーマンスが低下する。参考:　http://www.irisa.fr/alf/downloads/collange/cours/gpuprog_ufmg_2015/gpu_ufmg_2015_5.pdf

# クラスタードライティングのアクセスパターン[Clustered Lighting Access Patterns]

# Analyzing the Data[データの解析]

- ほとんどのWavefrontはひとつのセルのみにアクセスする
- 近くのセルはそのコンテンツのほとんどを共有する
- スレッドはほぼ同じデータをフェッチする
- スレッドごとのセルデータフェッチは最適ではない
    - このデータ集中性[convergence]を活用していない
- マージしたセルのコンテンツにわたるスカライテレーションの可能性
    - すべてのスレッドがまったく同じデータを独立してフェッチさせない

# アクセスパターンの活用[Leveraging Access Patterns]

TODO
