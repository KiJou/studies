---
title: The Most Common Vulkan Mistakes [@Witczak2016]
bibliography: bibliography.bib
numberSections: false
---
# Vulkan --- The Beginnings

- OpenGLやDX10以前では、データをアップロードして、ステートを切り替えて、描画コマンドを発行する。
    - ドライバは巨大なステートマシンである。
        - レンダリング処理はシングルスレッドでおこなわなければならない。
    - コマンドのサブミッションは時間のかかる処理である。
        - ドライバはフレームの終わりやコマンドバッファが満杯でないとサブミットしない。
    - 毎フレームごとに異なるコマンドをサブミットする可能性がある。
        - ドライバはあらかじめにコマンドバッファをベイクしたりできない。
<!--  -->
- OpenGLやDX10時代のワークアラウンド。
    - ストリーミングデータのアップロードに複数のレンダリングスレッドを使う。
    - できるだけGPUにデータを生成する。
    - ステートの構成によってドローコールをバッチする。
    - 一部のハードウェアでは並列計算のためにコンピュートシェーダを使う。
    - GPUバブルを減らすためにできるだけ多くのフレームを前もってレンダリングする。
<!--  -->
- これらのワークアラウンドは**最大の問題**を解決するもの**ではない**。
    - GPUは**高度に非同期化**されている。
    - 数多くの種類のタスクを**並列に**処理するよう設計されている。
        - 計算。
        - DMA転送。
        - ラスタライゼーション。
        - その他(例えば、画像データ変換の高速化)。
- APIの立場からだと、
    - GPUへは**ひとつ**のレンダリングスレッドからのみ**処理チャンク(work chunk)**を実行するよう要求できる。
    - アプリケーションは**信用されていない** --- **API呼び出しの検証**に**CPU時間**が使われる。
<!--  -->
- 実際の懸念事項。
    - 段々と**CPUに縛られたアプリケーション**が市場に現れてきている。
        - ドライバスレッドがCPU時間を消費している。
        - アプリケーションの複雑さが増加している。
    - **クロスプラットフォームな方法**でこれらに対処するのは**簡単ではない**。
    - Tilers(モバイルのTiled Rendering)はOpenGL ESでフルパワーを活用できていない。
    - **ベンダ固有**の解決法のみが存在する(例えば、Pixel Local Storage)。
- 以下のユースケースには言及しない。
    - マルチGPUのサポート。
    - VR。

# Vulkan --- Do I Need It?

- Vulkanは先程述べた問題のすべてに対処する。
    - **コマンドキューファミリー(command queue families)**の集まりとして**GPU**を開示する。
    - **コマンドバッファ**を**複数のスレッド**から**キューにサブミットする**ことができる。
    - **アプリケーション**は以下の**責任を持つ**。
        - 正しい**コマンドキュー**に**処理チャンク**をサブミットすること。
        - GPU**ジョブの実行**の**同期を取る**こと。
    - **メモリヒープ**の集まりとして利用可能な**GPUメモリ**を開示する。
    - アプリケーションは**フラッシュ(flush)**、**無効化(invalidation)**、**管理**に対する責任を持つ。
- **アプリケーション**は**動いている**GPUの能力に**合わせる**必要がある。
- 作法を間違える(misbehave)と、**GPUがハングする**。
<!--  -->
- **Vulkanを必要なケース**。
    - **CPUに縛られたアプリケーション**:
        - 情報の大多数がコンピュートやレンダリングで要求される --- **ロード時に事前にベイクする**。
        - たった**2つのコマンド**でフレームがレンダリングできる！
        - **ドライバ側の検証なし** = 本当に重要なことにより多くの**CPU時間**を割ける。
    - **GPUに縛られたアプリケーション**:
        - 以下により**GPU使用率**が改善する。
            - 関連する**キューファミリー**にコンピュート及びグラフィクスジョブをサブミットする。
            - **トランスファーキュー(transfer queues)**でVRAM-VRAM間やRAM-VRAM間のコピー処理を行う。
        - **突然のパフォーマンス低下**や**スパイク**がなくなる。
            - 予測可能な時間で、アプリケーションが指定した情報に従い、すべての**GPU側のキャッシュ**は**フラッシュ**される。
            - ドライバは**当てずっぽう(guess work)**を**しなくて良くなる**。
<!--  -->
- Vulkanを必要とする**かもしれない**ケース。
    - 既存のGL4.xやDX11以下のアプリケーション:
        - Vulkanに移行すれば、パフォーマンス的な利益がもたらされる**かもしれない**し、され**ないかもしれない**。
        - かかるCPUパワーが減る可能性は高い。
- Vulkanを必要と**しない**ケース。
    - **迅速な開発期間**を要求するプロトタイプアプリケーション:
        - 検証レイヤは**まだ**仕様のすべてを網羅して**いない**。
        - 多くの**間違ったユースケース**は依然として発見されて**いない**。
        - **急勾配な**学習曲線。
    - **CPUにもGPUにも縛られていない****単純なアプリケーション**:
        - **学ぶことを目的**とする場合を除いて、Vulkanから利益を得る可能性は低い。

# Vulkan --- Problematic Areas: Introduction

- **我々(AMD)のドライバ**は世に出て**数カ月**[^few_months]経った程度。
- **トップレベル観察**:
    - Vulkan is **demanding** to use, both **app-side** and **time-wise**.
    - アプリケーションがAというGPUで作業する場合、BというGPUを予約して**はならない**。
    - **基本的な落とし穴**:
        - バリア。
        - 正しいデータのアップロード。
        - イメージ遷移。
        - レンダパス。
    - ISVは一般的には**検証レイヤ**を使うことに**消極的(reluctant)**である。
        - **使ってください**。多くの時間を取っておける。

[^few_months]: [@Witczak2016]がまとめられたのは2016年3月頃。

# Vulkan --- Problematic Areas: Command Queues

- **CPU側**:
    - Vulkanに**レンダリングスレッドはない**。
    - 複数のスレッドからGPU側の**コマンドキュー**へ**処理チャンク**をサブミットできる。
- **GPU側**:
    - **コマンドキュー**は実行できる**コマンド**のタイプでグループ化される。
- **問題点**:
    - **コマンドキュー**の数は**ハードウェア依存**！
    - **キューファミリー**の数は**ハードウェア依存**！
<!--  -->
- **これの何が問題か？**
    - 効率的に**GPUタスクを配ること**は今やVulkan**アプリケーションの責任**である。
    - 解決法はデバイスの能力に応じて**アップスケール**や**ダウンスケール**できなければならない。
    - **オープンソースな解決法**はまだない。
    - Vulkan 1.0ではひとつの**コンピュート+グラフィクスのキューファミリー**のみ保証されている。
    - 単純なアプリケーションはユニバーサルキューの存在**ひとつ(solely)**に頼る可能性が高いだろう。
    - ただし、パフォーマンス最優先で書かれたVulkanアプリケーションではない。
-  **解決法**:
    - さまざまなVulkan実装であなたのレンダリングエンジンをテストする。

# Vulkan --- Problematic Areas: Command Buffers

- Vulkanでは、**コマンドバッファは**
    - **GPU側**で実行される**コマンド**を保持している。
    - アプリケーションによって**別途**明示しない限り、**再利用可能**である。
- **問題点**:
    - アプリケーションはしばしばフレームごとに**コマンドバッファ**を**記録し直す**。
- **これの何が問題か？**
    - 多くの**CPU時間**を無駄にする。
    - 多くの場合では**必要ない**。
- **解決法**:
    - **レンダリングロジック**に影響を与える**すべてのパラメータ**を**イメージ**、**ストレージバッファ**、**ユニフォームバッファ**に移動する。
    - 必要であれば、各**スワップチェーンイメージ**ごとに一度だけすべての**コマンドバッファ**を**事前にベイクする**。
    - コマンドバッファの再利用性を改善するなら、**インダイレクトディスパッチやインダイレクト描画のコマンド**を使う。

# Vulkan --- Problematic Areas: Memory Management

- **メモリ管理**もまたVulkanアプリケーションの責任である:
    - **物理デバイス(physical device)**は1以上の**メモリヒープ**を報告する。
    - 各**メモリヒープ**は:
        - **プラットフォーム固有のサイズ**を持つ。
        - **device-local**である**かもしれない**が、必ずしも**必要ではない**。
    - **メモリヒープ** --- アプリケーションが**直接**アクセス可能では**ない**。
    - 代わりに、ドライバはハードウェア固有の"**メモリタイプ**"**の配列**を開示している。
    - GPUメモリを割り当てるとき、Vulkanアプリケーションは**メモリタイプのインデックス**を指定する。
<!--  -->
- **辛い所は？**
    - Vulkanとアプリケーションとの契約は**とても薄い**。
    - 以下が**保証されている**。
        - 少なくとも**1つのメモリタイプ**は**host-visible**かつ**host-coherent**である。
        - 少なくとも**1つのメモリタイプ**は**device-local**である。
    - **バッファメモリ**と**イメージメモリ**の割り当てはドライバ固有の**メモリタイプ**由来でなければならない。
    - そのタイプは以下に依存して変化する**かもしれない**。
        - オブジェクトの特性。
        - オブジェクトのタイプ。
<!--  -->
- **最も辛い所は？**
    - ISVは`maxMemoryAllocationCount`の制限を**無視する**傾向にある。
    - **同時に生存できる割り当ての限界**の**最大最小数**は**4096**である。
        - **複雑なアプリケーション**なら達するのは**非常に容易い**。
        - **デスクトップのVulkan実装**で報告される**普通**の値である。
- **解決法**:
    - 利用可能なGPUメモリを**アプリケーション側**で**事前に割り当て**て**管理**する。
    - 小さなメモリ割り当てを**避けて**、**大きなもの**から**副割り当て**を行う。

# Vulkan --- Problematic Areas: Descriptor Pools

TODO

# References
