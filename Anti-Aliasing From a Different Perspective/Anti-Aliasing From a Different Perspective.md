---
title: Anti-Aliasing From a Different Perspective [@Andreev2011]
numberSections: false
---
# Directionally Localized Anti-Aliasing

# そのアイデアとは…[The Idea is...]

それらの方向に沿ってエッジをブラーすることである

# エイリアシング[Aliasing]

- 信号処理
    - サンプル時の区別できない信号
    - 再構築のアーティファクト
- グラフィクス
    - ピクセル"ノイズ"
    - エッジのジャギー

# アンチエイリアシング その１[Anti-Aliasing I]

- 高周波を減らす
- 過剰サンプル、および、"ブラー"
    - 音響では時間的
    - 光学では空間的
- 完璧なフィルタは存在しない
    - サンプリング理論
    - シャープ(エイリアス)対ソフト(アンチエイリアス)

# アンチエイリアシング その2[Anti-Aliasing II]

- テクスチャ
    - MIPマッピング
- シェーディング
    - スペキュラ、リムライティング
    - 手動で回避する
- ジオメトリのエッジ
    - マルチサンプリング(MSAA)
    - カスタムソリューション

# MSAA

- 良好な品質
- 部分的なスーパーサンプリング
    - 少なくとも深度
- ディファードレンダリングとフレンドリーでない
- コンソールではコストが高い
    - 直接的にも間接的にも

# 代替品[Alternatives]

- スクリーン空間フィルタリング
    - 知覚ベース
    - ジャギーを隠す
    - モーフォロジカルAA(MLAA)
- テンポラル(Crysis2、Halo)
- エッジベースAA

# MLAA

- モーフォロジカルアンチエイリアシング
    - 元のジオメトリを再構築する
    - 近傍を再ブレンドする
- CPUフレンドリー
    - The Saboteur
    - GoW3 (4 ms / 5 SPUs)
- XBox360 GPU (-> 3.7 ms)

静的な画像では良好な結果を得るが、二値の特徴に基づくパターン認識のため、動作中にかなり目立つテンポラルアーティファクトに悩まされる。画像中のフリッカリングはノイジーな背景を通る長いエッジで最も多く見られる。

# エッジベース[Edge-Based]

- XBox360 SDKのサンプル
    - 1ピクセル幅ポリゴンをレンダリングする
    - ピクセルカバレッジとしてテクスチャ座標
    - 近傍を再ブレンドする

# 使用できなかったモノ[Could Not Use]

- MLAA
    - 不安定
    - X360では厳しい
- エッジベース
    - PS3では追加のGPUコストがかかる
- テンポラル
    - TFU2での動的解像度調節
    - モーションVS解像度

# "理想的"なAAフィルタ["Ideal" AA Filter]

- マルチプラットフォーム
    - GPU、SPU
    - プロダクションで信頼できる
- 時間的に安定
- 知覚ベース
    - ジャギーを隠す
    - ローコストで良好な品質

# もしも…[What If ...]

ピクセルカバレッジのようなルックを作る

# Fresnel項ベース[Fresnel Term Based]

- $(N \cdot V)^n$
- 再ブレンドする
- 曲面のみ
- 制御しづらい

# 深度ベース勾配[Depth Based Gradients]

- エッジの勾配を見つける
    - 深度のボックスブラー
    - レベルを局所的に調整する
- 再ブレンドする
- 平坦な表面

# 深度の再サンプリング[Depth Re-Sampling]

- 代替深度をレンダリングする
    - 回転した第二Zプリパス
    - または、深度に対する4xMSAA
- ピクセルカバレッジを計算する
    - 深度値をリマップする
- 再ブレンドする

# 観察[Observation]

# DLAAプロトタイピングその1[DLAA Prototyping I]

- Photoshop
    - レイヤVSピクセル
    - 複合的なコトを行うのが難しい
    - うまく動作するなら実装しやすい:)
- フィルタ/その他/カスタム
    - 基本的な5x5畳み込み
    - ブラー、エッジ、など…

# DLAAプロトタイピングその5[DLAA Prototyping V]

- 垂直にブラーする
- 垂直のエッジを見つける
- エッジマスクを構築する
    - `saturate(abs(x) * a - b)`
- 元のレイヤーとブレンドする
- 水平も同様に

# 短いエッジのみ[Short Edges Only]

# 2つのケース[Two Cases]

# 長いエッジの検出[Long Edge Detection]

- ハイパスマスクを取る
- ブラーする
- コントラストを調整する
- 長エッジフィルタを適用する
    - 必要なところに

# 長いエッジのフィルタリング[Long Edge Detection]

- カラーブリーディング
- 光度ブレンディングモード
- 対象としてのぶらーされた輝度
    - 合致するローカルピクセルを探す

# ノイズレベル推定[Noise Level Estimation]

- ノイズ領域を除外する
    - 長い垂直および水平エッジを持つ
    - $\|H_{hF} - V_{hF}\| > \lambda$

# 勾配レベル比較[Gradient Levels Comparison]

# ビジュアル結果[Visual Results]

# 反射のアンチエイリアシング[Reflections Anti-Aliasing]

# 実行結果@720p[Execution Results @ 720p]

- XBox360       2.2±0.2 ms
- PlayStation3  1.6±0.3 ms (5 SPUs)

- プロジェクトの時間
    - 研究        8週(パートタイム)
    - X360       2週
    - PS3 (SPU)  3週以上

# 実装戦略[Implementation Strategies]

- 実行時間
    - サンプルを再利用する
    - できるだけ多くの処理をリジェクトする
    - パイプラインをバランスする
- メモリの使い方
    - テクスチャやバッファを再利用する
    - 使い方に応じてデータをパックする
- 大局的なパイプライン最適化

# 処理リジェクション[Work Rejection]

- 前処理
    - 長いエッジ領域を見つける
    - 長いエッジ周りのハイパス
    - 解決
- 処理
    - 短いエッジ
    - 短いエッジと長いエッジ (~10-20%)
    - 解決

# 長いエッジの推定その１[Long Edge Estimation I]

- 長い軸方向のエッジを直接見つける
    - 低解像度で(例えば、HDRリダクションから)

|||||||
|-|-|-|-|-|-|
|||||||
|1|1|1|1|1|1|
|-1|-1|-1|-1|-1|-1|
|||||||
: 長いエッジを見つけるカーネル

# 長いエッジの推定その２[Long Edge Estimation II]

- 32ビットHDR入力をインターリーブする
    - HDRリダクションの一部
    - エッジ情報を十分に離す

# 長いエッジの推定その３[Long Edge Estimation III]

- Hi-Zに転送する(4x4ピクセルブロック)
    - 4xMSAAトリック
- 深度トリックでHi-Zテストを反転する
    - D3DHIZFUNCを用いる

# ハイパスフィルタ[High-Pass Filter]

- 5つのバイリニアサンプル
- 長いエッジ周りのみ
- アルファに格納する

||||
|-|-|-|
|1|2|1|
|2|-12|2|
|1|2|1|
: カーネル

# 短いエッジ[Short Edges]

- ローおよびハイパスフィルタ
    - 垂直および水平サンプルを再利用する
- 正規化されたブレンディング係数
    - $t_h = (\lambda \cdot L(edge_h) - \varepsilon) / L(blur_h)$
    - $L(x)$ --- 強度関数
- 再ブレンドする
    - $c = \text{lerp}(c, blur_h, \text{saturate}(t_h))$

# 長いエッジその１[Long Edges I]

- GPUでの疎なサンプリング
    - 短いサンプリングを再利用する
    - 追加の4つのバイリニアサンプリング
- 水平か垂直ならば、破棄する
    - ブラーされるハイパスに基づいて[branch]

# 長いエッジその２[Long Edges II]

- ブラーされる強度にマッチするローカルピクセルを見つける
    - `blurred_lum = lerp(X_lum, Y_lum, t)`
    - `t = (blurred_lum - X_lum) / (Y_lum - X_lum)`
    - `if (0 < t && t < 1) color = lerp(X, Y, t)`
- 2つの検索ケース
    - 上下の近傍
- 再ブレンドする
    - longEdgeMaskに基づく

# 典型的なSPUコード[Typical SPU Code]

- ソフトウェアパイプライニング
    - レイテンシーの隠蔽
- 偶数番および奇数番の命令のバランスを取る
- ストリーム処理
- タイルのRSXサーフェス
    - VRAMからコピーするのに0.3ms
    - DMAでの部分的アンタイリング

# DLAA On SPUs

<<省略>>

# おわりに[Conclusion]

- DLAA
    - XBox360       2.2±0.2 ms
    - PlayStation3  1.6±0.3 ms (5 SPUs)
- コンソールライフサイクルの終わり
    - すべてのミリ秒を計測する
    - トリックは不可避[inevitable]
    - 異なるソリューション＆異なる考え
