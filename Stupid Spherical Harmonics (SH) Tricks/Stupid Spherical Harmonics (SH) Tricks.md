---
title: Stupid Spherical Harmonics (SH) Tricks [@Sloan2008]
#bibliography: bibliography.bib
numberSections: false
---
# 要約

この論文は同名のGDC 2008の講義の手引である。これは、球面調和関数(SH)[Spherical Harmonics]の簡潔な概要を提供し、インタラクティブグラフィクスにおいて使用可能ないくつかの方法と発生するかもしれない問題を議論する。特に、「SHを用いて効率的にライティングモデルを求める方法」、「"リンギング[ringing]"とは何か、そして、それについてできることは何か」、「SH積の効率的な求め方とそれが使われる所」、といった問題に焦点を当てる。最新バージョンは[http://www.ppsloan.org/publications](http://www.ppsloan.org/publications)で入手できる。

# はじめに

ラプラス方程式[Laplace's equation][@2]の解である調和関数[harmonic functions]は様々な分野で広く用いられる。球面調和関数は球に制限したときの解である^[これらは球座標における解の角度部分である。]。これは物理学において熱方程式[heat equation] (時間上の温度変化のモデル化[@5; @25])、重力場や電場[@9]のようなポテンシャルの問題を解くために使われてきた。量子化学や量子力学では原子の電子配置[electron configuration]や量子角運動量[quantum angular momentum]をモデル化するためにも用いられてきた[@16; @51]。グラフィクスに近い所では、散乱現象をモデル化するために使われてきた。コンピュータグラフィックスにおいて、これは広く使われてきた。初期には、ボリューメトリック散乱効果[@18]、大局的な影を持たないマイクロファセットBRDFのための環境反射[@6]、ディフューズでないオフライン光輸送シミュレーション[@40]、BRDF表現[@53]、画像の再ライティング[@28]、制御可能なライティングを伴う画像ベースレンダリング[@54; @55]、光源発光のモデル化[@8]、といった所で使われた。時代が下ると、異方性散乱[@50]やコンピュータビジョン[@3]における研究が増えてくる。

本論の中心はインタラクティブグラフィクスに関連する技術にある。ゲームにおいて広く使われてきた最初の論文は効率的に球面調和関数を用いて放射照度環境マップを表現することで対処する[@35]ものであり、遠方の照明の下にあるディフューズオブジェクトのインタラクティブレンダリングを可能にする。これは同じ制約を持つ制限されたBRDFの種類を扱うために拡張された[@36]。Precomputed Radiance Transfer(PRT)[@41 @20; @24]はライティング環境への静的なオブジェクトやシーンの反応をモデル化するものであり、しばしばSHを用いて表現され、ソフトシャドウやディフューズと単純な艶やかな[glossy]マテリアルとの相互反射のような複雑な大域照明効果を含む。これは、より一般的なBRDFモデルを扱うため[@20; @23; @42]、表面下散乱を組み込むため[@42]、機械学習による圧縮技術を通じてレンダリング効率を大幅に改善するため[@42]、表面の詳細のような"局所的"なテクスチャをモデル化する様々な技術を扱うため[@43; @44; @45]に拡張された。SHは遠方のライティング環境による単一散乱をモデル化するために使われてきた[@49]。他には、遠方のライティング仮定を持ち上げる[lift]ために勾配を用いるとき[@1]、相互反射のサポート[@46; @33]を含めた動的オブジェクトに対処するいくつかの技術において[@56; @37]、一般的なBRDFモデルを持つオブジェクトのシャドウイングをモデル化するための可視性の表現として[@12]、変形可能なオブジェクトからの影をモデル化するためにスケーリング操作を用いるとき[@52]、屈折のパラメータ化として[@11]、法線マップによるLevel of Detailの問題に対処するための技術として[@15]用いられる。

より実践的な論文には、PRTの実装の詳細をカバーするもの[@13]、エンジンにこれらの技術を統合する方法[@30]、放射照度ボリュームに対してSHと勾配を使う方法[@31; @32]、投影に関する実践的な問題とSH係数を効率的に量子化する方法[@21]、解析的なスカイライトモデル[@34]をSHに投影して、モデルのパラメータの関数としてSHライトプロブを求めるために大局的多項式フィッティング[global polynomial fit]を用いる良い論文[@14]が含まれる。また、SHを用いて半球上に定義されるよりロバストな投影関数の計算技術[numerical techniques]も調査されてきた[@22]。

リアルタイムグラフィクスでの多くは、可視性、ライティング、反射率として、単に球面関数を表現する便利な方法として用いられる。他に、ウェーブレット[@39]、キューブマップ上のウェーブレット[@27]、球面放射基底関数[spherical radial basis functions][@9]、など[@26]の使用可能な基底関数が多く存在するが、球面調和関数はこの文書で述べられるであろういくつかの素晴らしい特性を持つ。これらのその他の基底関数がより適切となるシナリオが存在することを強調することは重要である。

球面調和関数は幾分手強そうに見えるかもしれないが、実のところ素直である。これは単位円上のFourier基底に類似した球上のソレであり、数値的に計算し易い。信号処理において用いられるFourier基底のように、発生し得る"リンギング"アーティファクトを最小限にするため、(ビデオゲームでは常に行われるであろう)級数の打ち切りを行うときには気を付けなければならない。本論は、球面調和関数を用いて効率的に光を計算および表現する方法、SH表現から従来の光を取り出す方法、"リンギング"の説明とその影響を最小限にする軽減技術、球面調和関数を用いる関数の積の調査を述べる。そこで述べられるのは、これが有用である点と、最適化する価値がある特殊ケースについてである。

# 背景

#### 定義

球面調和関数は球$S$上の正規直交^[正規直交基底は、$\int f_i f_j = \delta_{ij}$が$i = j$のとき$1$、それ以外のとき$0$となる特性を持つものである。]基底を定義する。用いるパラメータは以下となる。

$$
s = (x, y, z) = (\sin\theta\cos\varphi, \sin\theta\sin\varphi, \cos\theta)
$$

ここで、$s$は単純に単位球上の位置[locations]である。この基底関数は以下のように定義される。

$$
Y_l^m(\theta, \varphi) = K_l^m e^{im\varphi} P_l^{|m|}(\cos\theta), l \in \boldsymbol{N}, -l \le m \le l
$$

ここで、$P_l^m$はLegendre陪多項式[associated Legendre polynomials]であり、$K_l^m$は以下の正規化定数である。

$$
K_l^m = \sqrt{\frac{(2l + 1)(l - |m|)!}{4\pi(l + |m|)!}}
$$

上記の定義は(グラフィクスでない界隈で最も一般的に使われる)複素形式によるものであり、実数値基底[real valued basis]は以下の変換によって求められる。

$$
y_l^m = \left\{ \begin{array}{c}
    \sqrt{2}\text{Re}(Y_l^m) & m > 0 \\
    \sqrt{2}\text{Im}(Y_l^m) & m < 0 \\
    Y_l^0 & m = 0
\end{array} \right. = \left\{ \begin{array}{c}
    \sqrt{2}K_l^m \cos m\varphi P_l^m(\cos\theta) & m > 0 \\
    \sqrt{2}K_l^m \sin |m|\varphi P_l^{|m|}(\cos\theta) & m < 0 \\
    K_l^0 P_l^0(\cos\theta) & m = 0
\end{array} \right.
$$

添字$l$は"バンド[band]"を表す。各バンドは多項式の次数[degree]と等価であり(すなわち、0は単なる定数関数、1は線形、など)、与えられたバンドには$2l+1$個の関数が存在する。球座標は積分を計算するときに便利であるが、これらを求めるときに一般的に行われるように、多項式を用いて表現することもできる(詳細は[@sec:A1]と[@sec:A2]を参照)。次数[order][^degree_and_order]$n$のSH展開は次数[degree]$n-1$までのすべての基底関数を用いる。

[^degree_and_order]: 訳注:本文書では、SHに対する"order"は「次数」とし、多項式に対する"degree"は注記付きで「次数[degree]」とする。

![](assets/SH_vis.png)

球面調和関数はいくつかの方法で可視化できる。ある標準的な方法では、関数の絶対値で同心円状に各点をスケーリングして、符号に基づいて(正なら赤に、負なら青に)色付けすることで、単位球を歪ませる。上の図はこの技術を用いた最初の3つのバンドの画像である。

中央の列($l = 0$)にある関数はZonal Harmonics(ZH)と呼ばれ、後に述べれれるだろうが、これらの関数はZ軸周りに回転対称性を持ち、そのゼロ(関数が0となる位置)はXY平面に並行な球上の輪郭[contours]である。($l = |m|$)にある関数はSectorial Harmonicsと呼ばれ、そのゼロはリンゴのスライスのような領域を定義する。

代替案として、平面に展開したキューブマップのパラメータ化を用いて描画して可視化する方法がある。キューブマップの展開は以下のようになる。

![](assets/cubemap_unfolding.png)

ここでは、大きさ[magnitude]は色(正は赤、負は青、ゼロは緑)にエンコードされ、等強度線[iso-intensity contours]は関数の勾配に対するさらなる直観を得るために(白で)均等に配置されている(間隔が狭いと関数が素早くに変化する、など)。

#### 投影と再構築

SH基底は正規直交であるので、$S$上に定義されるスカラ関数$f$の最小二乗投影[least squares projection]は基底関数に対して投影したい関数$f(s)$を単純に積分することで行われる(証明は[@sec:A6])。

$$
f_l^m = \int f(s)y_l^m(s) ds
$$

これらの係数は関数$f$の近似を再構築するために使用できる。

$$
\tilde{f}(s) = \sum_{l = 0}^n \sum_{m = -l}^l f_l^m y_l^m(s)
$$

これは、バンド数$n$を増やすごとにますます正確になる。本論は$f$への低周波近似に専念するため、より高い周波数表現では他の基礎の方が良い仕事をする傾向にある。$n$次への投影は$n^2$個の係数を生成する。以下を介して投影係数と基底関数の両方に対する単一の添字[index]を用いることはしばしば便利である。

$$
\tilde{f}(s) = \sum_{i = 0}^{n^2} f_i y_i(s)
$$

ここで、$i = l ( l + 1) + m$である。この方程式は近似関数の方向$s$での計算が$n^2$個の係数ベクトル$f_i$と求めた基底関数$y_i(s)$の内積であることを明確にする。第1係数($f_0^0$または添字付けに依存する$f_0$)は球上の関数の平均値を表現し、DC項と時折呼ばれる。

#### 基本的な特性

SHの重要な特性のひとつは投影がとのように回転と相互作用するかということである。回転行列$Q$によって回転された$f(s)$を表現する関数を$g(s)$とすると、すなわち、$g(s) = f(Q(s))$であり、$g$の投影は$\tilde{f}$を回転して再投影することに等しい。この回転不変性[rotation invariance]はFourier変換における並進不変性[translational invariance]に似ている。これは、例えば、ライティングが回転に対して安定となるであろうこと、すなわち、エイリアシングアーティファクトや光源の"ぐらつき[wobbling]"が起こらないであろうことを意味する。下図は方向光源によって照らされる球の画像であり、上段はSHを用い、下段はValveによるアンビエントキューブ基底^[この基底はSHを求めるより効率的であり、6つの基底関数のうち任意の球上の点で非ゼロとなるのは3つのみである。]を用いている。この基底は[@sec:A9]でより詳細に述べられる。これは球上に定義される他の任意の基底である程度発生するだろう。SH基底の正規直交性により、$a$、$b$を任意のSH関数とすると、積の積分は係数ベクトルの内積である。すなわち、$\int \tilde{a}(s) \tilde{b}(s) = \sum_{i = 0}^{n^2} a_i b_i$である。

#### 畳み込み

円対称性を持つカーネル関数を$h(z)$とすると、このカーネルと元の関数$f$との畳み込みの結果として新しいSHを生成できる。$h$は、回転群[rotation group]$SO(3)$ではなく球$S$上でも表現されるようにするため、畳み込みの結果に対して円対称性を持たなければならない。畳み込みは以下の数式を用いて周波数領域で直接行うことができる。

$$
(h * f)_l^m = \sqrt{\frac{4 \pi}{2l + 1}} h_l^0 f_l^m
$$

これは$h$の対応する$m = 0$項によって$f$の各バンドを単純にスケーリングすることに等しい。

#### 回転

前述した通り、SHは回転に対して閉じている。SH回転行列はブロック構造にあり、そのとき、各バンドは回転に対して独立であり、密な$(2l+1) \times (2l+1)$の部分行列[submatrix]を持つ。この回転行列を計算する方法はいくつかあり、非常に低次(二次以下)では記号的に[symbolically]行うことが最も効率的であるが、それより高次では回転行列をZ-Y-Z系のEuler角に分離する方がより効率的であるように思われる[@19]。

#### Zonal Harmonics

ある軸の周りに回転対称性を持つ関数を球面調和関数に投影したものはZonal Harmonics(ZH)と呼ばれる。それが配向している、すなわち、この軸がZ軸であるならば、関数のゼロは一定の緯度線を形成し、その関数は$\theta$のみに依存するだろう。この配向性における係数ベクトルはバンドあたりの非ゼロがひとつだけであるので、$n$次の関数は$n^2$個ではなく$n$個の係数を持つ。Zonal Harmonicsは輸送[transfer]を近似するのに使われ[@44]、そして、散乱理論における位相関数の一般的な表現であり[@7; @17]、これは本論において光源をモデル化するときに広範囲に使われるだろう。Zonal Harmonicsの回転は一般的なSHより単純であり、事実上[effectively]対角行列であるもので行われることができ、新しい方向$d$におけるSH基底関数を求めることのみを要求する。(SH投影の$m = 0$項のみの)関数のZH係数を$z$とすると、以下の式を用いて新しい方向$d$へ回転させることができる。

$$
f(s) = \sum_l z_l \sqrt{\frac{4 \pi}{2l + 1}} \sum_m y_l^m(d) y_l^m(s)
$$

すなわち、SH係数は以下のようになる。

$$
f_l^m = \sqrt{\frac{4 \pi}{2l + 1}} z_l y_l^m(d)
$$

#### SH積

SHに投影された$n$次のSHを用いて表現される2つの関数$f$と$g$の積の$k$番目の係数は以下の形式を持つ。

$$
p_k = \int y_k(s) \left( \sum_{i = 0}^{n^2} f_i y_i(s) \right) \left( \sum_{j = 0}^{n^2} g_j y_j(s) \right) ds = \sum_{ij} \Gamma_{ijk} f_i g_j
$$

ここで、$\Gamma$は三重積のテンソル[triple product tensor]である。

$$
\Gamma_{ijk} = \int y_i(s) y_j(s) y_k(s) ds
$$

これは階数[order]3の疎な対称テンソルである。SHは多項式であるので、多項式の積は最大次数[maximal degree]$2n-2$を持つだろう。このとき、次数$2n-1$までの非ゼロの係数を持つであろうことを意味する。これは乗算されている関数の数が増えるにつれて扱いづらくなるので、早期に積を切り詰める[truncate]のが一般的である[@56; @37]。$n$の関数としての非ゼロの係数の数はかなり大きい[@47; @37]ので、効率的なコードを生成するときには注意するしなければならない。ある特殊な場合では[One special case that is useful to point out is that]、$f$が固定される(すなわち、遠方のライディングである)ならば、そのコストを大幅に削減するであろう"積の行列[product matrix]"$M_f$を計算することができる。この行列は対称であり、以下の式を用いて作られる。

$$
(M_f)_{ij} = \sum_k \Gamma_{ijk} f_k
$$

この場合における関数$g$との積の計算は単純な行列とベクトルの積となる。

# 放射照度環境マップ

放射照度環境マップ[irradiance environment map]はライトプロブとクランプされたコサイン関数との畳み込みによって生成される。これは放射輝度を表すために$\pi$で除算して正規化されるべきである。この畳み込みはSHを用いて効率的に行われることができ[@35]、同様に、直接的にSHから効率的にレンダリングされるのに十分な正確さを持つ。次数3のSHはこのカーネルを近似するのに良い働きをするが、HDR光源を用いているならば、次数5の使用を検討したくなるだろう(次数4のZHの係数はゼロなので、そのバンドは省略できる)。下図はクランプされたコサイン関数と次数3のSH近似の画像であり、赤の曲線がSH近似を示す。左側の図は$\theta$の関数としてのプロットであり、右側の図は関数の絶対値でスケールした極座標プロットである。

![](assets/sh3_plot.png)

下図は次数5の投影(青)も含めたプロットである。

![](assets/sh5_plot.png)

次数3のSH近似は$\theta = 0$(北極)で$\frac{1}{16}$だけ過剰推定し、南極に大きさ$\frac{1}{16}$を持つ不要なローブ[spurious lobe]を持つ。17の値を反射する方向光源は、法線がその方向を指すとき、反対方向に向かって1の値を反射するだろう(0を反射しているべきなのに)。次数5の近似は、同様の方向を指す法線で31を反射する方向光源では-1を反射するであろう、負のローブを持つ。これらの近似は正確であるが、特に非常に明るい光源を用いている場合、誤差を引き起こし得る。

[@sec:A10]は放射照度環境マップを効率的に求めるためのシェーダおよびCPUコードを含む。

# ライティングモデル

SHにはライディングを表現する方法が様々存在する。最も簡単なものとして単にキューブマップから投影する方法があるが、計算が高価でなく、アーティストへ公開するものとして有用である可能性を秘めた解析モデルも存在する。最近の論文[@14]では実用的なスカイライトモデル[@34]をSHに投影し、そのモデルのパラメータ空間上でSH係数の大局的多項式フィッティングを行う。

## キューブマップからの投影

キューブマップから投影するためには、キューブマップに対してSH基底関数を積分する必要がある。これは各テクセルの中心の方向においてSH基底関数を求めて、そのテクセルに対する微分立体角[differential solid angle]で重み付けして、その結果を正規化することで数値的に行われることができる。以下はその擬似コードである。

```pseudo
float f[], s[];
float fWtSum = 0;
Foreach(cube map face)
    Foreach(texel)
        float fTmp = 1 + u^2 + v^2;
        float fWt = 4 / (sqrt(fTmp) * fTmp);
        EvalSHBasis(texel, s);
        f += t(texel) * fWt * s; // ベクトル
        fWtSum += fWt;
f *= 4 * Pi / fWtSum; // 球の面積
```

上記のコードにおいて、`u`と`v`は+1または-1^[すなわち、+X面上では、yとzになるだろう。]でない与えられた面上の2つの座標を表し、`t(text)`はテクセルの色である。`EvalSHBasis`は(キューブ面での)入力座標を正規化する必要があり、その方向におけるSH基底関数を計算する。(特に低解像度のキューブマップを用いるときに)多少ずれる傾向はあるが、微分立体角の正規化された合計は$4\pi$となるはずなので、最後の正規化は省略できる(代わりに、サンプル数で割ることができる)。

下図はHDRライトプロブを次数1から6の球面調和関数に再構築した画像である。最終的に、画像は投影されたライトプロブとなる。

## 解析モデル

方向光の計算は自明であり、与えられた方向にSH基底関数を求めて適切にスケールするだけで良い([@sec:Normalization]を参照)。球光源はZonal Harmonicsを用いて効率的に求めることができる。下図はシーンの例を示す図であり、レシーバ[receiver]の位置$P$での入射する放射輝度、球関数を計算したい。中心$C$、半径$r$の球光源があるとすると、$d$だけ離れている点$P$に到達する放射輝度は幾らか？光源のなす半角のサインは$\frac{r}{d}$であるので、球の適切な部分に対する[subtend]光源を計算する必要がある。ZH係数はこの角度の関数として閉形式で計算できる。すなわち、$\int_{\theta = 0}^a \int_{\phi = 0}^{2\pi} y_l^0 d\phi d\theta$である。ここで、$a$はそのなす半角である。次数6までの式については[@sec:A3]を参照。

![球光源](asserts/spherical_light_source.png){#fig:1}

球での技術は一定の放射[emission]を持つ円錐(無限大にある円板として考える)をモデル化するのにも使用できる。より柔らかい円錐は可視部分で滑らかな減衰[fall-off]を持つようにモデル化できる^["ease spline"が用いられる。これは制約$f(0) = 1, f'(0) = 0, f(a) = 0, f'(a) = 0$を持つ三次多項式$f(x)$であり、一意に定まる三次多項式は$f(x) = \frac{2x^3}{a^3} - \frac{3x^2}{a^2} + 1$である。] --- 式は[@sec:A4]を参照。

列は次数4と6のものを表し、上段は円錐の投影を、下段は滑らかな減衰を持つ円錐を表す。角度は90°(緑)、45°(赤)、30°(青)、12.5°(黒)である。破線は実際の関数を表し(重ならないようにちょっとだけ円錐に対してずらしてある)、実線はSH近似を表す。一般に、柔らかい円錐のほうが行儀が良い。投影おいて発生するアーティファクトに対処する方法は以下の[@sec:Ringing]の主題である。

### 正規化 {id="sec:Normalization"}

[0, 1]のライティングが用いられているならば、光源を直接指す法線を持つ影に隠れていない[unshadowed]レシーバに対して反射した放射輝度が1.0になるだろうから、放射輝度ベクトルを正規化するのに便利である。数学的にスケールファクタ$c$を計算したいとする。これは、ライティングベクトル$L$で乗算してベクトル$T$に対して積分すると反射した単位放射輝度になり、遮蔽されていないクランプされたコサインローブを表す(正規化されたクランプしたコサインのSHへの投影)。すなわち、以下となる。

$$
1 = \int c L(s) T(s) ds \xrightarrow{yields} c = \frac{1}{L \cdot V}
$$

正規化ファクタを計算するときは、レンダリングで使用したいバンドのみを使うべきである。$T$を$+Z$と並行にすると、単純な解析式[analytic formula]が得られる。ここでは最初の6つのバンドに対する$T$の係数を示す。

$$
\frac{1}{2 \sqrt{\pi}}, \frac{\sqrt{3}}{3 \sqrt{\pi}}, \frac{\sqrt{5}}{8 \sqrt{\pi}}, 0, \frac{-1}{16 \sqrt{\pi}}, 0
$$

解析的な光では解析的な正規化項を用いることができ、角度$a$の円錐光では以下になる。

$$
\frac{1}{\sin^2 a}
$$

しかし、クランプしたコサイン関数と光源の両方の投影誤差が考慮されていないので、結果の光は単位放射輝度を反射しない。方向光^[これは4次より大きいライティングを仮定していない。5次および6次では正規化ファクタは$\frac{32\pi}{31}$となる。]では正規化ファクタは$\frac{16\pi}{17}$となり、"アンビエント"光では$2\sqrt{\pi}$となる。

## SHからの従来の光の抽出

SHのライティングベクトルを仮定すれば、単一の方向光源とアンビエント光源として近似することができる。これは頂点シェーダをサポートしないハードウェア上で使われていた。数学的に、反射した放射輝度の二乗誤差が任意の表面法線($N$)に対して最小化するように、方向光の強度($c$)とアンビエント光の強度($a$)を計算したいとする。光源に対する固定の距離($d$)を仮定すると、最小化したい誤差関数は以下のようになる。

$$
E(c, a) = \int \left( cH_N(d) + a - \int L_e(s) H_N(s) ds \right)^2 dN
$$

ここで、$H_N(x) = \text{max}(\frac{N \cdot x}{\pi}, 0)$は正規化されたクランプしたコサインである。ライティング$L_e(s)$がSHで表されるならば、これは単純な解を持つ。新しいライティング環境で表される放射照度環境マップはできるだけ入力の放射照度環境マップに近くあるべきである --- これら2つの環境マップの二乗誤差を最小化することはすべての法線で反射した放射輝度を最小化することと等価である。

$$
E(c, a) = \int (cL_d(s) * H_N(s) + aL_a(s) * H_N(s) - L_e(s) * H_N(s))^2 ds
$$

ここで、$L_d(s)$は方向$d$における正規化されたSHの方向光であり、$L_a(s)$は正規化されたSHの定数光である(単にDCに依存する)。$a$と$c$の最適な値は以下となる。

$$
\begin{array}{ccl}
    c & = & \frac{867}{316\pi} \text{dot}(\hat{L}_d, \hat{L}_e) \\
    a & = & \left( \hat{L}_e[0] - c \frac{8\sqrt{\pi}}{17} \right) \frac{\sqrt{\pi}}{2}
\end{array}
$$

上記のライティングベクトルはすべて正規化されたクランプしたコサインカーネルとの畳み込みによって放射照度環境マップに変換される。上記の内積はDC項を無視し、$\hat{L}_e[0]$はライティング環境のDC項である。上記は既知の方向を仮定する。その候補となる方向は"最適線形[optimal linear]"な方向[@44]であり、ベクトル$(-\hat{L}_e[3], -\hat{L}_e[1], \hat{L}_e[2])$を正規化することで形成される。これは、ライティング環境の線形な係数である。

## 複数の光の抽出

SHライトプロブから複数の光を抽出することもできる。これは、(解析的な光は負のローブを持たないので)リンギングに対抗するため、(この方法で取り出される光源による)艶やかな[glossy]反射をモデル化するため、少数のシャドウZバッファを用いる(BRDFの拡散と光沢[glossy]の両部分のために光を取り出す)ために行われるかもしれない。最適線形な方向はライトプロブが単一の光源によって支配されるときに正常に動作する。そうでないには、方向と強度は何らかの方法で最適化される必要がある。これを行う方法のひとつに、関数の極大[local maxima]を見つけるために"上り坂[up hill]"を登ることがある。SHの滑らか具合が与えられたとき、与えられた次数に対して有限の距離が存在し、そこでは、明確な[distinct]ピークから遠ざかる任意の点が最急上昇法[gradient ascent]を用いてその点に到達することが保証される[Given how smooth SH are, for a given order there is a finite distance where any point that distance from a distinct peak is guaranteed to reach the point using gradient ascent.]。点の集合はそのVoronoi^[球上の点の集合を$X$とすると、与えられた点$x_i$のVoronoi cellはその集合における他のいかなる点より$x_i$に近い球上のすべての点を含む。] cellの中心から最も遠い球上の点がこの距離より小さいという特性によって生成できる。これらの点のそれぞれから探査を始めるならば、極大点のすべてを見つける必要がある。これらの距離は、デルタ関数の投影を調べて、ピークとゼロとの角距離[angular distance]を計算することで見つけることができる。この半径の$\frac{2}{3}$の控えめな推定[conservative estimate]を用いると、次数ごとに必要となる点の数は最初の6つの次数では{1, 3, 6, 10, 15, 22}となる。

この点の集合はシミュレーションを計算することで計算できる。すなわち、すべての点が他のすべての点に作用するある減衰(例えば$1/d^2$、$d$はそれらのユークリッド距離)を伴う力を持つとする。各点で作用する合力[net force]を生成し、(これは単なる接線力[tangential force]なので)垂直成分[normal component]を差し引いて、重み$w$と一緒にこの力によって点を移動する。合力の合計が増加するならば、$w$を半分に減らして再度行い、減少するならば、$w$を倍にして再度行う。これはelectrostatic chargesの合計を最小化する電子の集合を解いている。

SHライティング環境を$L(s)$として、極大となる球上の点を見つけたいとする。これは、$-L(s)$の極小[local minima]を見つけることと同じことである。これは非線形最適化問題であり、経験上BFGS法の反復をいくらか行えばそのピークに収束する。基底関数の勾配は最適化手法を用いるときに計算される必要がある。球上の点に対して、多項式の微分は自明であるが、その点が直線探索[line search]を行うときに球を離れられるようにする必要がある。そのため、係数を正規化する記号的な入力を用いたい(すなわち、$f(x, y, z)$の代わりに$f(\frac{x}{\sqrt{x^2 + y^2 + z^2}}, \frac{y}{\sqrt{x^2 + y^2 + z^2}}, \frac{z}{\sqrt{x^2 + y^2 + z^2}})$)。これは正規化された位置での勾配を計算して以下の正規化関数のヤコビアンで乗算することで行われる。

$$
\left[ \begin{array}{ccc}
    \frac{L^2 - x^2}{L^3} & \frac{-xy}{L} & \frac{-xz}{L} \\
    \frac{-xy}{L} & \frac{L^2 - y^2}{L^3} & \frac{-yz}{L} \\
    \frac{-xz}{L} & \frac{-yz}{L} & \frac{L^2 - z^2}{L^3}
\end{array} \right]
$$

ここで、$L$は$\sqrt{x^2 + y^2 + z^2}$である。

![](assets/multiple_lights.png)

上図は3個、2個、1個の方向光とアンビエント光で近似したときの放射輝度(上段)および放射照度(下段)ライティング環境の比較画像である。$N$個の(大きさの観点で)最重要なピークがあるとすると、これは最小二乗的に方向およびアンビエント強度を解く。

2つのローブに対する光の強度を計算するための式は以下となる。

$$
\left[ \begin{array}{c}
    c_0 \\
    c_1
\end{array} \right] = \left[ \begin{array}{cc}
    \frac{A}{A^2 - B^2} & \frac{-B}{A^2 - B^2} \\
    \frac{-B}{A^2 - B^2} & \frac{A}{A^2 - B^2}
\end{array} \right] \left[ \begin{array}{c}
    L_e \circ L_{d0} \\
    L_e \circ L_{d0}
\end{array} \right]
$$

ここで、$A = L_{d0} \circ L_{d0}, B = L_{d0} \circ L_{d1}$である。

そのアンビエント項は以下である。

$$
a = (L_e[0] - (c_0 L_{d0}[0] + c_1 L_{d1}[0])) \frac{\sqrt{\pi}}{2}
$$

3つの光に対して、その強度は以下となる。

$$
\left[ \begin{array}{c}
    c_0 \\
    c_1 \\
    c_2
\end{array} \right] = \left[ \begin{array}{ccc}
    \frac{A^2 - D^2}{E} & \frac{CD - AB}{E} & \frac{BD - AC}{E} \\
    \frac{CD - AB}{E} & \frac{A^2 - C^2}{E} & \frac{BC - AD}{E} \\
    \frac{BD - AC}{E} & \frac{BD - AD}{E} & \frac{A^2 - B^2}{E} \\
\end{array} \right] \left[ \begin{array}{c}
    L_e \circ L_{d0} \\
    L_e \circ L_{d1} \\
    L_e \circ L_{d2}
\end{array} \right]
$$

ここで、$C = L_{d0} \circ L_{d2}, D = L_{d1} \circ L_{d2}, E = 2BCD + A(A^2 - B^2 - C^2 - D^2)$である。

この行列は対称であり、そのアンビエント係数は以下である。

$$
a = (L_e[0] - (c_0 L_{d0}[0] + c_1 L_{d1}[0] + c_2 L_{d2}[0])) \frac{\sqrt{\pi}}{2}
$$

これらの式の導出は[@sec:A5]にある。

自由度(方向と強度)のすべてを追加して非線形ソルバを用いると、初期の推測として上記の技術を用いるとすれば、より高品質な結果を生成するだろう。

# リンギング {id="sec:Ringing"}

リンギングは、Gibbs現象とも呼ばれ、信号処理における一般的な問題である。不連続性[discontinuity]を持つ信号が(連続的な関数のみを表現できる)有限のFourier基底に投影されるとき、オーバーシュート[overshoot]やアンダーシュート[undershoot]がその不連続性の周囲に発生する。不連続性を持たない関数でも投影が切り詰められる[truncated]場合に同様の挙動を示す可能性がある。我々は、ライティングモデルを調査するとき、そして、放射照度環境マップの表現(クランプしたコサイン関数の投影)において、これらの問題をすでに確認していた。同様の問題は表面設計[surface design]において発生する。ここでは、一連の幾何的制約を満たそうとするとき、望ましくない振動[oscilations]が発生する可能性がある。これらの問題には2つの一般的な解法が存在する。

1. 切り詰めた投影係数にシグマファクタを用いて窓を掛ける[windowing]方法。これは信号処理において最も一般的な解法であり、球面調和関数で自明に使用できる[@8; @41; @37]。
2. 標準の最小二乗誤差ではなく、変分関数[variational function]のいくつかの形式を最小化する方法(例えば、曲率の大きさを最小化する)。これはコンピュータを利用した幾何的設計[computer aided geometric design]において一般的に行われるが、球面調和関数を用いて効率的に行われることもできる[@38]。

## 窓掛け[^windowing]

[^windowing]: 信号処理における"窓を掛ける[windowing]"という用語は空間領域においてより一般的に使用される。例えば、画像をフィルタリングするときにフィルタの空間的な大きさが"窓掛け"され、1Dの信号のFFTを取るときにその信号は周期的にするためにスケールされるかもしれない。本論において、これらは周波数領域において行われている。

リンギングアーティファクトを最小化する方法のひとつに、カットオフ周波数に近づくにつれてゼロに漸減[taper]する投影係数を持つカーネルを周波数領域において乗算する方法がある。この関数は切り詰めた周波数帯でゼロに到達するように引き伸ばされたsinc関数[^sinc]であり、Lanczosのシグマファクタ[^Lanczos_sigma_factors]を用いる、と言われる。直観的に、(1Dで)これが行っていることは、その関数を過度な[excessive]リンギングなしで表現されるのに十分な滑らかさにするための、空間領域におけるタイトなボックス関数との畳み込みである。Gibbs現象に対抗するより洗練された方法[@10; @4]が存在するが、これらはゲーム用として便利ではないであろう区分的な解析関数を生成するのにSH係数を用いる。

[^sinc]:<!-- HACK -->$\text{sinc}(x) = \frac{\sin x}{x}$であり、$x = 0$のとき最大値$1$となる。

[^Lanczos_sigma_factors]: 時折シグマファクタはGibbs現象をより積極的に減らすために持ち上げられる[be raised to a power]だろう。これは、その信号を繰り返し畳み込むのと同等である。

![](assets/window_functions.png)

経験上、窓関数の選択はリンギングとブラーリング[blurring]の間をトレードオフするために柔軟性を持つことほど重要ではない。左の画像は6次のSH用にスケールされた2つの窓関数(赤はsinc、青はHanning窓と呼ばれるraised cosineローブ)を示している(7次のバンドではゼロに達するので、使われる最後の値は5次で求められ、その関数は整数でのみ求められるだろう)。Hanning関数はLancosz関数より速く減衰[decay]する。これは、より積極的にそれをブラーさせる^[Lancoszの二乗はHanning関数に近いが、少しだけ速く減衰する。2.25の高さとなるデルタ関数の再構築では、Hanning関数は大きさ12.0105の窓を必要とし、Lancoszは大きさ9.8725の窓を必要とする。その結果は見た目には区別できないように見える。]。

![](assets/sigma_factors.png)

上図はLanczosおよびHanningのシグマファクタを用いた結果を示す。投影されている信号は次数6のデルタ関数である。これは、SHに投影できる"最大ピークの[peakiest]"信号であり、リンギングアーティファクトを示す。デルタ関数の投影はZHでありので、これらは球の断面[cross section]を示し、$\phi$は固定される。放射状の大きさがプロットされ、ローブの符号は互い違いになる。

すべてのグラフを一緒に見ると(赤はデルタ関数のそのままの投影を示す)、窓掛けがどれだけ信号をブラーしつつ、リンギングを除去しているかを確認できる(図の原点近くに見られる)。

![](assets/all_sigma_factors.png)

## 汎関数[functional]の最小化

代わりのアプローチとして、二乗近似誤差に加えていくつかの関数を最小化することを試みる。これを行う方法のひとつに、一連の制約を満たし(例えば、少数の点での厳密な再構築)、そして、いくつかの誤差汎関数[error functional]を最小化するために(十分な自由度があると仮定して)余りの"スラック[slack]"変数を用いる方法がある[@38]。ゲームやグラフィクスでしばしば用いられる低いSH次数であれば、このアプローチは実践的であるように思えないので、これ以上の時間を費やすことはないだろう。代替案として、大きな振動に不利となるノルムを最小化することを試みる。これは素直なやり方で球面調和関数で行われることができる。Laplace作用素[operator]、または、Laplacianはスカラ関数の勾配の発散[divergence]であり、非混合偏微分[unmixed partial derivatives]の和と等価である。

$$
\Delta f = \frac{\partial^2 f}{\partial x^2} + \frac{\partial^2 f}{\partial y^2} + \frac{\partial^2 f}{\partial z^2}
$$

単位球上の球面座標では、これは以下のようになる。

$$
\Delta f = \frac{1}{\sin\theta} \frac{\partial}{\partial\theta} \left( \sin\theta \frac{\partial f}{\partial\theta} \right) + \frac{1}{\sin^2 \theta} \frac{\partial^2 f}{\partial \phi^2}
$$

二乗Laplacianの積分は球上で用いられる曲率の大きさである[@38]。その最小化したい関数は以下となる。

$$
E(c) = \int \left( \tilde{f}(s) - f(s) \right)^2 ds + \lambda \int \left( \Delta \tilde{f}(s) \right)^2 ds
$$

これに若干の調整を加えたい。生の投影係数$f_l^m$は既知であるので、重み付けされた二乗Laplacianを最小化しつつも、できるだけ最小二乗の結果に近い新しい係数$c_l^m$を見つけたい。これは閉形式で行われることができ([@sec:A6]参照)、$\lambda$与えられると最終的に以下の係数になる。

$$
c_l^m = \frac{f_l^m}{(1 + \lambda l^2 (l + 1)^2)}
$$

これは$\lambda$に依存する窓関数に等しいことに注意する。$\lambda$がゼロのときは最小二乗の係数が得られ、$\lambda$が無限大のときは曲率がゼロでありDC項が得られる。$\lambda$を選ぶアプローチのひとつに、固定量、例えば、半分に二乗Laplacianを減らして解く方法がある。これはいずれかの標準の求根[root finding]テクニックを用いて行われることができる。Newtons法を用いてこれを行う方法の説明は[@sec:A7]を参照のこと。下図は6次のデルタ関数を二乗Laplacianが元の10%($\lambda = 0.004209$の緑)、50%($\lambda = 0.000632$の青)になるように解いた結果である。最後のプロットはデルタ関数それ自身と合わせたものである。

![](assets/squared_laplacian.png)

下図は実際のライティング環境を用いた画像である。画像の1列目は2列目の等値線プロット(青が負)であり、幅の広い(より滑らかな)窓で窓掛けしている。4列目は3列目の等値線プロットであり、より狭い(ブラーの少ない)フィルタで平滑化している。上段は元の画像であり、すべての結果は6次で示される。

![](assets/windowing.png)

窓掛けは賢く用いられるべきである。放射照度環境マップを用いるとき、クランプされたコサイン関数との畳み込みは高周波を積極的に減衰し、窓掛けはほとんど必要としない。また、法線の変化が多く存在するシーンではレシーバの法線が滑らかであるシーンほどリンギングアーティファクトを示さない傾向にある。下図はシェーディング結果に窓掛けがどれだけ影響を与えるかを示す("ドア"と地面の)単純なシーンの画像である。リンギングが発生しているエリアは2段目で強調される。

![](assets/ringing_simple_scene.png)

HDRや適度に明るい光を用いるとき、リンギングはより厳しい問題であり、放射照度環境マップでさえある程度の窓掛けを必要とするかもしれない。

リンギングで起こり得るもうひとつの問題は色アーティファクトである。下の画像では、方向性の黄色の光で(右上から次数6でほぼ縁が)照らされる球と白色の適度なアンビエント光がある。上段は放射照度環境マップを用い、下段は次数6のPRTを用いる(すなわち、コサインカーネルのより正確な近似が用いられる)。1列目は窓掛けなしであり、2列目は次数4のHanning窓を用い、その下は次数5である。窓掛けしないバージョンは両方とも正のローブ(次数3、負の次数6)を示し、青の帯は方向光の負のリングに起因する(アンビエント光により赤と緑が除かれるが、青だけそのままにする)。

![](assets/ringing_sphere.png)

## 内容依存[Content Sensitive]の窓掛け

ライティングは大局的に窓を掛けられることができるが、最後の陰影付けされた画像にリングが与える影響度に基づいて窓を掛けることもできる。その例を以下に示す。(ハイライトが飽和する)明るい方向光源を用いてマットな(ただし、ディフューズではなく、パワー10を持つPhongの)ボールのようなものをレンダリングする。窓掛けを適用しないならば、主要なハイライトはより鋭いが、リング由来のアーティファクトは明確である。ライティングが窓を掛けられるならば、リングは消えるが、主要なハイライトは同様にブラーされる。代わりに、鋭いハイライトを維持しつつリンギングアーティファクトを取り除くために、反射ベクトルと支配的な光ベクトルとの間の角度に対して、これが小さい場合に窓掛けはせず、大きくなるに従って窓掛けした光源と窓掛けしない光源とをブレンドすることができる。この画像の列は以下に示される。

![](assets/content_sensitive_windowing.png)

ブレンディングを制御するのに使われる式は以下のようになる。

$$
w_a = \left( \text{max}\left( 0, \frac{(n \circ r) - c_t}{1 - c_t} \right) \right)^p
$$

ここで、$w_a$は窓掛けされていない光源の重み(窓掛けされる方は$1 - w_a$)であり、$c_t$は窓掛けされた光源を完全に用いるときを定めるしきい値であり、$p$はブレンドの遷移領域を制御する。この図では、$c_t = 0.07$であり、$p = 0.8$である。これらのパラメータを試すことができ、しきい値は窓掛けの量とマテリアル特性に大きく依存するだろう。

光源が方向性のものでないならば、方向光源によってどれだけうまく近似できるを計算して、どれだけブレンドするかを決めるときにそれを計算に入れることができる(最も単純な方法は、ライティング環境が方向光による近似にどれだけ近いか、と、法線または反射ベクトルが支配的な光ベクトルにどれだけ近いか、との間のテンソル積を計算することだろう)。より複雑なシェーディング、例えば、PRTでは、支配的な輸送方向が使用でき、輸送関数への近似度合いは未だにテンソル積においてもうひとつのファクタとすることができる(なので、項のいずれもうまく近似しないときに窓を掛ける)。

ライティングが動的であるならば、光が変化するたびに発生し得る時間的なアーティファクトに気を付ける必要があるだろう(すなわち、シャドウや反射が鋭くなる、など)。それでも、静的SHライトプロブのようなものでは、この技術は上手く動作するはずである。

# SH積

SHを用いて表される2つの関数の積のSH表現を計算することはしばしば有用である。例となるシナリオには以下がある。

1. 大きな飛行物体(可視性×光)、または、シーンの単純な可視性モデル(大きな建物など)に基づいてスカイライトモデルに穴を開ける。
2. 可視性関数を乗算する。これは動的で近似的な大域照明を行うときに発生する。
3. SHライトプロブをスケールまたは修正する。0から1までのある定数の乗算は、例えば、雲を近似するのに使われることができる。

周波数領域における積の計算は非常に複雑であり、要するに、2つのSHベクトルと"三重積テンソル"の掛け算になる。このコードは効率的に生成でき[@47]、本論では説明されないだろう。とはいえ、言及する価値のある特殊な場合がいくつかある。

## 定数関数との積

SH関数のひとつをたくさん使いたい場合、積の行列と呼ばれる密な行列を作ることができ、これは三重積を、計算コストがかなり小さくなる、単純な行列とベクトルの積にする。次数6の積は、2527個の掛け算が、[@47]で生成されたコードでは1296個の掛け算になる。

## 可変次数との積

これは出力次数が、局所的な放射輝度環境を表現できるように、例えば2次のように、低次であるときに特に一般的である。これらの場合でのコードの特例化[special casing]はコードの複雑さを大幅に減少させる。例えば、2つの6次のSHの積は、6次の結果を計算するときは2527の乗算と1995の加算があるが、3次の結果を計算するときは933の乗算と676の加算^[これらの結果は[@47]の出力を適用したナイーブなアルゴリズムを用いているので、より効率的なコードが生成できるかもしれない。]のみで済む。もうひとつの例は単純なアンビエントオクルージョンであり、この場合、項のひとつは単なるDCであり、DCの値で他のベクトルをスケールしなければならない。最後に、2つの関数のひとつはより低次(すなわち、線形な可視性を乗算するだけ)となるかもしれない。これも、そのコストを削減できる。

## Zonal Harmonicsとの積

関数のひとつがZonal Harmonicであるならば、それと同じフレームに他の関数を回転して(その対称性により2つのEuler角のみを必要とするため、回転の計算コストがより小さい)、積を計算して、回転し直すことができる。ZHフレームにおける疎な性質[sparsity]は相当量の作業を取り除き、パーフォーマンスを増加することができる。1つがZを向くZHである、2つの6次関数の積は380個の乗算と249個の加算のみ必要とする。任意のZHでは、(関数のひとつが常にある任意の方向にある)100万回の積の計算時間は約1.2秒であり、一方で、一般的な6次の積は3秒以上かかるので、この技術はほぼ3倍速くする。

## 解析的関数との積

関数のひとつが解析的な形式をもつならば、積の行列に等しいものを解析的に計算することでより正確になる。一例として、水平線より下ではすべてゼロとするとき(地面があるときに便利)、クランプしたコサイン関数との積を取るとき、がある。これを解析的に行うことは、解析的関数の無限次数展開を持つことと等価であり、一般に、これらの場合ではSH展開を用いるよりはるかに高速であるだろう。これらの2つの例のコードは[@sec:A8]にある。

# おわりに

球面調和関数は、ゲームでは特にライティングで、極めて有用なツールである。本論が、これの使い方とこれを使う時に当たり得る課題の和らげ方、に光明を投じることを願うばかりである。本論で述べたアイデアを拡張する方法がいくつかある。(窓関数で用いる)窓掛け係数は負(または正)のローブの大きさ、または、ゼロになるべき方向を指すときに反射した放射輝度の大きさを最小化するために解くことができる。光を抽出するとき、非線形最適化に基づくより厳格な技術は使用できるかもしれず[@29; @44]、より一般的なライティングモデル(例えば、光源からの円錐の角度を含む)が抽出できるかもしれない。フィッティング処理に窓を掛けてみることの調査をする価値もあるかもしれない。まず、関数の滑らかなバージョンにフィットさせて、窓掛けの量をdial backすることで、より良い極小値へ効果的に舵取りを行う。内容依存の窓掛けのアイデアは、特にPRTのような技術と統合するとき、具体化する必要がある。

球面調和関数で色々やっているときに非常に貴重であると判明したツールのひとつは記号的計算プログラムである。私はMaple([https://www.maplesoft.com/](https://www.maplesoft.com/))を用いたが、Mathematica([http://www.wolfram.com/](http://www.wolfram.com/))のような他のプログラムも同様に機能するだろう。DirectX SDK([http://msdn.microsoft.com/directx](http://msdn.microsoft.com/directx))はPRTと放射照度環境マップの両方を使うサンプルを付属した、計算[evaluation]、回転、積、いくつかの解析的ライティングモデルのための関数を持つ。

# 謝辞

作業の多くは、Microsoft Researchのグラフィクスグループに配属されたときに始まり、他の協力者と、特に、長期に渡る実りの多い論文シリーズを執筆するJohn Snyderと共に行われた。また、Hao Chen(Bungie)、Arn Arndt、James Grieves、Clint Hanson(当時EA)、Loren McQuade(Blizzard在籍中)、Dan Baker(MSとFiraxis)、Alex Evans(当時Lionhead)、Tom Forsyth(Muckyfoot)、Willem de Boer(Muckyfoot)、Alex Manchor Ko(Naughty Dog)、Naty Hoffman(SCEA)、chris Oat(ATI)等、幾人かのゲーム開発者と球面調和関数の議論をさせて頂いた。Jason Sandlin、Ben Luna、Jon SteedはMicrosoftにてサンプルやテストコードに関してやってもらった。そして、SHやその他の話題についてGDAlgorithmsメーリングリストにて議論に参加できたことを嬉しく思う。

# References

\appendix

# A1 SH基底関数の計算のための再帰的規則 {id="sec:A1"}

漸化式[recurrence relations][@48]はSH基底関数の多項式の形式を効率的に求めるのに使用できる。基底関数の定式を再掲する。

$$
y_l^m = \left\{ \begin{array}{c}
    \sqrt{2}\text{Re}(Y_l^m) & m > 0 \\
    \sqrt{2}\text{Im}(Y_l^m) & m < 0 \\
    Y_l^0 & m = 0
\end{array} \right. = \left\{ \begin{array}{c}
    \sqrt{2}K_l^m \cos m\varphi P_l^m(\cos\theta) & m > 0 \\
    \sqrt{2}K_l^m \sin |m|\varphi P_l^{|m|}(\cos\theta) & m < 0 \\
    K_l^0 P_l^0(\cos\theta) & m = 0
\end{array} \right.
$$

単位球上の点を$(x, y, z)$とすると、(Zのみに依存し、$\sin\theta^m$で割られる)Legendre陪多項式はこれらの再帰性[recurrences]を用いて求めることができる($P_0^0 = 1$)。

$$
\begin{array}{ccc}
P_m^m & = & (1 - 2m) P_{m-1}^{m-1} \\
P_{m+1}^m & = & (2m + 1) z P_m^m \\
P_l^m & = & \frac{(2l -1) z P_{l-1}^m - (l+m-1) P_{l-2}^m}{l-m}
\end{array}
$$

ここで、$l$は内部ループで増加し、$m$は外部ループで増加する。

三角関数の加法定理[trigonometric addition formula]は(球上の座標$(x,y)$から計算できるように$\sin\theta^m$をかけられた)$\phi$依存の項を求めるのに使用できる。ここで、$S(0) = 0, C(0) = 1$である。

$$
\begin{array}{ccc}
S(m) & = & xS(m-1)+yC(m-1) \\
C(m) & = & xC(m-1)+yS(m-1) \\
\end{array}
$$

元の式では、$\sin|m|\phi$を$S(m)$に、$\cos m\phi$を$C(m)$に置き換えている。一般に、共通の部分式を自然と因数に分解するため、これらの式に基づくコードを生成することはより効率的である。

# A2 SH基底の多項式の形式 {id="sec:A2"}

SH基底関数の多項式の形式は以下にリスト化される。$L$はバンド番号、$M$は基底関数である。Mapleが$L$と$M$の順をごちゃまぜにすることに注意する…

$$
\begin{array}{l}
\{L = 0, M = 0\}, \frac{1}{2\sqrt{\pi}} \\
\{L = 1, M = -1\}, -\frac{\sqrt{3}y}{2\sqrt{\pi}} \\
\{L = 1, M = 0\}, \frac{\sqrt{3}z}{2\sqrt{\pi}} \\
\{L = 1, M = 1\}, -\frac{\sqrt{3}x}{2\sqrt{\pi}} \\
\{L = 2, M = -2\}, \frac{\sqrt{15}yx}{2\sqrt{\pi}} \\
\{L = 2, M = -1\}, -\frac{\sqrt{15}yz}{2\sqrt{\pi}} \\
\{L = 2, M = 0\}, \frac{\sqrt{5}(3z^2 - 1)}{4\sqrt{\pi}} \\
\{L = 2, M = 1\}, -\frac{\sqrt{15}xz}{2\sqrt{\pi}} \\
\{L = 2, M = 2\}, \frac{\sqrt{15}(x^2 - y^2)}{4\sqrt{\pi}} \\
\{L = 3, M = -3\}, -\frac{\sqrt{2}\sqrt{35}y(3x^2-y^2)}{8\sqrt{\pi}} \\
\{L = 3, M = -2\}, \frac{\sqrt{105}yxz}{2\sqrt{\pi}} \\
\{L = 3, M = -1\}, -\frac{\sqrt{2}\sqrt{21}y(-1+5z^2)}{8\sqrt{\pi}} \\
\{L = 3, M = 0\}, \frac{\sqrt{7}z(5z^2-3)}{4\sqrt{\pi}} \\
\{L = 3, M = 1\}, -\frac{\sqrt{2}\sqrt{21}x(-1+5z^2)}{8\sqrt{\pi}} \\
\{L = 3, M = 2\}, \frac{\sqrt{105}(x^2-y^2)z}{4\sqrt{\pi}} \\
\{L = 3, M = 3\}, \frac{\sqrt{2}\sqrt{35}x(x^2-3y^2)}{8\sqrt{\pi}} \\
\{L = 4, M = -4\}, \frac{3\sqrt{35}yx(x^2-y^2)}{4\sqrt{\pi}} \\
\{L = 4, M = -3\}, -\frac{3\sqrt{2}\sqrt{35}y(3x^2-y^2)z}{8\sqrt{\pi}} \\
\{L = 4, M = -2\}, \frac{3\sqrt{5}yx(-1+7z^2)}{4\sqrt{\pi}} \\
\{L = 4, M = -1\}, -\frac{3\sqrt{2}\sqrt{5}yz(-3+7z^2)}{8\sqrt{\pi}} \\
\{L = 4, M = 0\}, \frac{3(35z^4-30z^2+3)}{16\sqrt{\pi}} \\
\{L = 4, M = 1\}, -\frac{3\sqrt{2}\sqrt{5}xz(-3+7z^2)}{8\sqrt{\pi}} \\
\{L = 4, M = 2\}, \frac{3\sqrt{5}(x^2-y^2)(-1+7z^2)}{8\sqrt{\pi}} \\
\{L = 4, M = 3\}, \frac{3\sqrt{2}\sqrt{35}x(x^2-3y^2)z}{8\sqrt{\pi}} \\
\{L = 4, M = 4\}, \frac{3\sqrt{35}(x^4-6y^2x^2+y^4)}{16\sqrt{\pi}} \\
\{L = 5, M = -5\}, -\frac{3\sqrt{2}\sqrt{77}y(5x^4-10y^2x^2+y^4)}{32\sqrt{\pi}} \\
\{L = 5, M = -4\}, \frac{3\sqrt{385}yx(x^2-y^2)z}{4\sqrt{\pi}} \\
\{L = 5, M = -3\}, -\frac{\sqrt{2}\sqrt{385}y(3x^2-y^2)(-1+9z^2)}{32\sqrt{\pi}} \\
\{L = 5, M = -2\}, \frac{\sqrt{1155}yxz(-1+3z^2)}{4\sqrt{\pi}} \\
\{L = 5, M = -1\}, -\frac{\sqrt{165}y(-14z^2+21z^4+1)}{16\sqrt{\pi}} \\
\{L = 5, M = 0\}, \frac{\sqrt{11}z(63z^4-70z^2+15)}{16\sqrt{\pi}} \\
\{L = 5, M = 1\}, -\frac{\sqrt{165}x(-14z^2+21z^4+1)}{16\sqrt{\pi}} \\
\{L = 5, M = 2\}, \frac{\sqrt{1155}(x^2-y^2)z(-1+3z^2)}{8\sqrt{\pi}} \\
\{L = 5, M = 3\}, -\frac{\sqrt{2}\sqrt{385}x(x^2-3y^2)(-1+9z^2)}{32\sqrt{\pi}} \\
\{L = 5, M = 4\}, \frac{3\sqrt{385}(x^4-6y^2x^2+y^4)z}{16\sqrt{\pi}} \\
\{L = 5, M = 5\}, -\frac{3\sqrt{2}\sqrt{77}x(x^4-10y^2x^2+5y^4)}{32\sqrt{\pi}}
\end{array}
$$

# A3 球光源に対するZH係数 {id="sec:A3"}

ラジアン角$a$に対する球光源があるとすると、最初の6つのバンドの記号的な積分は以下のようになる。

$$
\begin{array}{ll}
L = 0: & -\sqrt{\pi}(-1 + \cos(a)) \\
L = 1: & \frac{1}{2}\sqrt{3}\sqrt{\pi}\sin(a)^2 \\
L = 2: & -\frac{1}{2}\sqrt{5}\sqrt{\pi}\cos(a)(-1 + \cos(a))(\cos(a) + 1) \\
L = 3: & -\frac{1}{8}\sqrt{7}\sqrt{\pi}(-1 + \cos(a))(\cos(a) + 1)(7\cos(a)^2 - 3) \\
L = 4: & -\frac{3}{8}\sqrt{\pi}\cos(a)(-1 + \cos(a))(\cos(a)+1)(7\cos(a)^2 - 3) \\
L = 5: & -\frac{1}{16}\sqrt{11}\sqrt{\pi}(-1 + \cos(a))(\cos(a)+1)(21\cos(a)^4 - 14\cos(a)^2 + 1)
\end{array}
$$

# A4 滑らかな円錐に対するZH係数 {id="sec:A4"}

ラジアン角$a$に対する円錐があるとすると、その光源は北極で強度1を持ち、角度$a$で0に減衰する。6次では、この関数は単精度を用いて約8°以下の角度を求めるべきではない。平滑化関数の微分は北極と$a$で0となる。最初の6つのバンドは以下となる。

$$
\begin{array}{l}
\frac{(a^3+6a-12\sin(a)+6\cos(a)a)\sqrt{\pi}}{a^3} \\
\frac{1}{4}\frac{\sqrt{3}(a^3+3\cos(a)\sin(a)+3\cos(a)^2a)\sqrt{\pi}}{a^3} \\
\frac{1}{9}\frac{\sqrt{5}(-6a-2\cos(a)^2\sin(a)-9\cos(a)a+14\sin(a)+3\cos(a)^2a)\sqrt{\pi}}{a^3} \\
\frac{1}{256}\frac{\sqrt{7}4a^3+15a-108\cos(a)^2a-30\cos(a)^3\sin(a)+63\cos(a)\sin(a)+60\cos(a)^4a)\sqrt{\pi}}{a^3} \\
\frac{1}{1500}\frac{-480a+742\sin(a)+596\cos(a)^2\sin(a)+225\cos(a)a-378\sin(a)\cos(a)^4-1650\cos(a)^3a+945\cos(a)^5a)\sqrt{\pi}}{a^3} \\
\frac{1}{3072}\frac{\sqrt{11}(-63a+12a^3+350\cos(a)^3\sin(a)-1260\cos(a)^4a-15\cos(a)\sin(a)-224\cos(a)^5\sin(a)+672\cos(a)^6a+540\cos(a)^2a)\sqrt{\pi}}{a^3}
\end{array}
$$

# A5 方向およびアンビエント光を伴うSH環境マップを近似するために係数を解く {id="sec:A5"}

方向$d$にある方向光と元のライティング環境との間の近似誤差を最小化する強度$s$を計算できる。

$$
E(c) = (L_e - cL_d)^2
$$

ここで、$L_e$はライティング環境のSH表現であり、$L_d$は方向$d$にあるライティングモデルのSH表現である^[放射輝度(ベクトルのまま)か放射照度(ベクトルの畳み込み)のいずれかを用いて最適化できる。]。この解は以下となる。

$$
c = \frac{L_e \circ L_d}{L_d \circ L_d}
$$

アンビエント光を追加したいならば、誤差関数を最小化する必要がある。

$$
E(c, a) = \int (cL_d(s) * H_N(s) + aL_a(s) + H_N(s) - L_e(s) * H_N(s))^2 ds
$$

ライティングに畳み込みを吸収させ、各変数に関して微分すると以下のようになる。

$$
\begin{array}{ccc}
\frac{dE}{dc} & = & 2 \int (c \hat{L}_d(s) + a \hat{L}_a(s) - \hat{L}_e(s)) \hat{L}_d(s) ds \\
\frac{dE}{da} & = & 2 \int (c \hat{L}_d(s) + a \hat{L}_a(s) - \hat{L}_e(s)) \hat{L}_a(s) ds
\end{array}
$$

そして、最小値を見つけるために2つの式が0^[そのHessian行列は$\left[ \begin{array}{cc} 3 & 1 \\ 1 & 1 \end{array} \right]$であり、正の固有値$2 \pm \sqrt{2}$を持つ。すなわち、これは最小値である。]に等しいとして解く。$\hat{L}_a(s)$はスカラの関数であり^[SHベクトルはDC項において非ゼロのみを持つ。]、SHの直交性により、その積分はすべて単純なSHベクトルの内積となる。これは以下の式となる。

$$
\begin{array}{l}
cA + aB = D \\
cB + aC = E
\end{array}
$$

ここで、

$$
A = \frac{508\pi}{867}, B = \frac{16}{17}, C = \frac{4}{\pi}, D = \text{dot}(\hat{L}_d, \hat{L}_e), E = \text{dot}(\hat{L}_a, \hat{L}_e)
$$

$c$と$a$について解くと、

$$
\begin{array}{l}
c = \frac{867}{316\pi} \text{dot}(\hat{L}_d, \hat{L}_e) - \frac{51}{79} \text{dot}(\hat{L}_a, \hat{L}_e) \\
a = \frac{127\pi}{316} \text{dot}(\hat{L}_a, \hat{L}_e) - \frac{51}{79} \text{dot}(\hat{L}_d, \hat{L}_e)
\end{array}
$$

同じ結果に達するより単純な方法が存在することが判明している。環境と光の両方がDC項を含まない方向光の強度を解き、スケールされた方向光を用いるときに環境のDC項を再構築するアンビエント項を計算する。これは最終的に以下となる。

$$
c = \frac{867}{316\pi} \text{dot}(\hat{L}_d, \hat{L}_e) \\
a = \left( \hat{L}_e[0] - c \frac{8\sqrt{\pi}}{17} \right) \frac{\sqrt{\pi}}{2}
$$

上記の式において、内積はDC項を無視し、$\hat{L}_e[0]$は環境光のDC項である。2つや3つの光に対して同様の技術を用いるだろう(その場合、光の強度と同時に$a$を扱うと式はより汚く[much nastier]なる)。

複数の光は同様のやり方で行われることができ、まず、すべての光ベクトルからDCを取り除き、2つの光で、以下の誤差関数をもたらす。

$$
E(c_0, c_1) = \int (c_0 L_{d0}(s) + c_1 L_{d1}(s) - L_e(s))^2 ds
$$

その後、係数のそれぞれに関して微分して0に対して解く。以下の式で強度を得る。

$$
\left[ \begin{array}{c}
    c_0 \\
    c_1
\end{array} \right] = \left[ \begin{array}{cc}
    \frac{A}{A^2 - B^2} & \frac{-B}{A^2 - B^2} \\
    \frac{-B}{A^2 - B^2} & \frac{A}{A^2 - B^2}
\end{array} \right] \left[ \begin{array}{c}
    L_e \circ L_{d0} \\
    L_e \circ L_{d0}
\end{array} \right]
$$

ここで、

$$
A = L_{d0} \circ L_{d0}, B = L_{d0} \circ L_{d1}
$$

$A$が方向に独立して一定であることは指摘しておく価値がある(これは次数とベクトルが畳み込まれるかどうかに依存する)。そのアンビエント項は以下のようになる。

$$
a = (L_e[0] - (c_0 L_{d0}[0] + c_1 L_{d1}[0])) \frac{\sqrt{\pi}}{2}
$$

3つの光では、その強度は以下となる。

$$
\left[ \begin{array}{c}
    c_0 \\
    c_1 \\
    c_2
\end{array} \right] = \left[ \begin{array}{ccc}
    \frac{A^2 - D^2}{E} & \frac{CD - AB}{E} & \frac{BD - AC}{E} \\
    \frac{CD - AB}{E} & \frac{A^2 - C^2}{E} & \frac{BC - AD}{E} \\
    \frac{BD - AC}{E} & \frac{BD - AD}{E} & \frac{A^2 - B^2}{E} \\
\end{array} \right] \left[ \begin{array}{c}
    L_e \circ L_{d0} \\
    L_e \circ L_{d1} \\
    L_e \circ L_{d2}
\end{array} \right]
$$

ここで、$C = L_{d0} \circ L_{d2}, D = L_{d1} \circ L_{d2}, E = 2BCD + A(A^2 - B^2 - C^2 - D^2)$である。

この行列は対称であり、このアンビエント係数は以下となる。

$$
a = (L_e[0] - (c_0 L_{d0}[0] + c_1 L_{d1}[0] + c_2 L_{d2}[0])) \frac{\sqrt{\pi}}{2}
$$

# A6 最小二乗投影 {id="sec:A6"}

まず、正規直交基底関数に対して、実際に最小二乗投影が基底関数に対して積分することで達成されることを示そう。以下の関数を最小化する係数ベクトル$c$を見つけたいとする。

$$
E(c) = \int \left( \sum_i c_i y_i (s) - f(s) \right)^2 ds
$$

これは各係数に関して微分することで行われることができ、第1階微分を0に対して解く^[二階混合偏微分[second derivative mixed partials]はすべてゼロであり、非混合偏微分[unmixed partials]はすべて1であるので、そのHessianは単位行列であり、極小を持つ。]。

$$
\frac{dE}{dc_k} = 2 \int \left( \sum_i c_i y_i(s) - f(s) \right) y_k(s) ds
$$

基底関数は正規直交であるので、$\int y_i(s) y_j(s) ds = \delta_{ij}$であることが知られ、この事実を利用して0に対して解くと、以下を得る。

$$
\frac{dE}{dc_k} = 0 \xrightarrow{yields} c_k = \int y_k(s) f(s) ds
$$

こうして、直接積分が最小二乗の結果をもたらすようにする。

そして、球上で積分された二乗Laplacianに基づくペナルティを含む誤差汎関数を最小化する係数ベクトル$g$を導く。上の式により、純粋な二乗誤差を最小化する係数ベクトル$c$は分かっている。indexingに使われる関数$h$を導入する。

$$
\int (\Delta \tilde{f})^2 ds = \sum_{l=1}^n \sum_{m=-1}^l l^2 (l+1)^2 (f_l^m)^2 = \sum_{i=0}^{n^2} h_i (f_i)^2
$$

そして、その誤差関数は以下となる。

$$
E(g) = \left( \sum_i (g_i - c_i)^2 \right) + \lambda \sum_i h_i g_i^2
$$

微分すると、以下を得る。

$$
\frac{dE}{dg_k} = 2(g_k - c_k) + 2\lambda h_k g_k
$$

0に対して解くと、以下を得る。

$$
g_k = \frac{c_k}{(1 + \lambda h_k)}
$$

# A7 二乗Laplacianを減らすためにラムダに対して解く {id="sec:A7"}

これはNewtons法を用いて極めて簡単に行われることができる。二乗Laplaciandは以下となる。

$$
\Delta^2 = \sum_{l=1}^n \sum_{m=-1}^l l^2 (l+1)^2 (f_l^m)^2 = \sum_{l=1}^n l^2 (l+1)^2 \sum_{m=-1}^l (f_l^m)^2 = \sum_{l=1}^n L_l B_l
$$

$L$の値($L_l = l^2 (l+1)^2$)の配列は静的であり、$B$の値の配列は$B_l = \sum_{m=-1}^l (f_l^m)^2$で計算できる。Newtons法は初期の推定値を取り(この問題では0でうまく機能する)、以下の漸化式を用いて洗練する。

$$
\lambda_{n+1} = \lambda_n - \frac{f(\lambda_n)}{f'(\lambda_n)}
$$

ここで、$f$は根を探索する関数であり、$f'$は一階微分である。$f_l^m$を$\lambda$を含む$c_l^m$で置き換え、因数分解すると、以下となる。

$$
f(\lambda) = \Delta^2 - \sum_{l=1}^n \frac{L_l B_l}{(1+\lambda L_l)^2}
$$
$$
f'(\lambda) = 2 \sum_{l=1}^n \frac{L_l^2 B_l}{(1+\lambda L_l)^3}
$$

ここで、$\Delta^2$は元の二乗Laplacianである。反復回数が最大に達するか、逐次近似の絶対値がしきい値を下回るまで反復する(実践では1e-6が上手く機能するように思える)。これは次数[degree]$(n-1)^2$の(すべての分母の積で乗算する)多項式として表現できる。ここで、$n$はその次数[order]である。これは2次かそれより下の次数でのみ有用であるだろう。この場合、根の閉形式の解が計算できたとしても、反復による解よりはるかに速いかどうかは明らかでない。

# A8 解析的関数によるSH乗算のコード {id="sec:A8"}

以下の2つは両方とも半球上で定義される関数である。ひとつ目は支配的な地面を持つシーンで役立ち得る定数である。ふたつ目はZでクランプしたコサインである。

```c
// Zにおける半球での6次のライティングの乗算から6次のSH係数を生成する
void HemiMult(float* R, float* L) {
    R[0] = 0.433012702f * L[2] - 0.1653594569f * L[12] + 0.1036445247f * L[30] + 0.5f * L[0];
    R[1] = 0.5f * L[1] + 0.4192627457f * L[5] - 0.1711632992f * L[19];
    R[2] = -0.05412658775f * L[20] + 0.5f * L[2] + 0.2420614591f * L[6] + 0.433012702f * L[0];
    R[3] = 0.5f * L[3] - 0.1711632992f * L[21] + 0.4192627457f * L[7];
    R[4] = 0.5f * L[4] - 0.1713860232f * L[28] + 0.4133986423f * L[10];
    R[5] = -0.06477782793f * L[29] + 0.4192627457f * L[1] + 0.5f * L[5] + 0.2614562582f * L[11];
    R[6] = 0.5f * L[6] - 0.1448476267f * L[30] + 0.2420614591f * L[2] + 0.3697549864f * L[12];
    R[7] = -0.06477782793f * L[31] + 0.4192627457f * L[3] + 0.5f * L[7] + 0.2614562582f * L[13];
    R[8] = 0.5f * L[8] - 0.1713860232f * L[32] + 0.4133986423f * L[14];
    R[9] = 0.5f * L[9] + 0.41015625f * L[17];
    R[10] = 0.2685102947f * L[18] + 0.5f * L[10] + 0.4133986423f * L[4];
    R[11] = 0.360244363f * L[19] + 0.5f * L[11] + 0.2614562582f * L[5];
    R[12] = 0.2790440836f * L[20] + 0.5f * L[12] - 0.1653594569f * L[0] + 0.3697549864f * L[6];
    R[13] = 0.5f * L[13] + 0.360244363f * L[21] + 0.2614562582f * L[7];
    R[14] = 0.2685102947f * L[22] + 0.4133986423f * L[8] + 0.5f * L[14];
    R[15] = 0.41015625f * L[23] + 0.5f * L[15];
    R[16] = 0.408100316f * L[26] + 0.5f * L[16];
    R[17] = 0.2720668773f * L[27] + 0.5f * L[17] + 0.41015625f * L[9];
    R[18] = 0.2685102947f * L[10] + 0.35621916f * L[28] + 0.5f * L[18];
    R[19] = 0.2856107251f * L[29] - 0.1711632992f * L[1] + 0.5f * L[19] + 0.360244363f * L[11];
    R[20] = 0.2790440836f * L[12] + 0.5f * L[20] + 0.3498002708f * L[30] - 0.05412658775f * L[2];
    R[21] = 0.2856107251f * L[31] + 0.360244363f * L[13] + 0.5f * L[21] -
 0.1711632992f * L[3];
    R[22] = 0.5f * L[22] + 0.35621916f * L[32] + 0.2685102947f * L[14];
    R[23] = 0.2720668773f * L[33] + 0.5f * L[23] + 0.41015625f * L[15];
    R[24] = 0.5f * L[24] + 0.408100316f * L[34];
    R[25] = 0.5f * L[25];
    R[26] = 0.408100316f * L[16] + 0.5f * L[26];
    R[27] = 0.5f * L[27] + 0.2720668773f * L[17];
    R[28] = 0.5f * L[28] - 0.1713860232f * L[4] + 0.35621916f * L[18];
    R[29] = -0.06477782793f * L[5] + 0.5f * L[29] + 0.2856107251f * L[19];
    R[30] = 0.3498002708f * L[20] + 0.1036445247f * L[0] - 0.1448476267f * L[6] + 0.5f * L[30];
    R[31] = -0.06477782793f * L[7] + 0.2856107251f * L[21] + 0.5f * L[31];
    R[32] = 0.5f * L[32] - 0.1713860232f * L[8] + 0.35621916f * L[22];
    R[33] = 0.5f * L[33] + 0.2720668773f * L[23];
    R[34] = 0.5f * L[34] + 0.408100316f * L[24];
    R[35] = 0.5f * L[35];
}

// Zにおけるクランプしたコサインでの6次のライティングの乗算から6次のSH係数を生成する
void CosMult(float* R, float* L) {
    // 整形用の定数
    const float T1 = 0.09547032698f;
    const float T2 = 0.1169267933f;
    const float T3 = 0.2581988897f;
    const float T4 = 0.2886751347f;
    const float T5 = 0.2390457218f;
    const float T6 = 0.2535462764f;
    const float T7 = 0.2182178903f;
    const float T8 = 0.1083940384f;
    const float T9 = 0.2519763153f;
    const float TA = 0.2439750183f;
    const float TB = 0.3115234375f;
    const float TC = 0.2512594538f;
    const float TD = 0.31640625f;
    R[0] = 0.25f * L[0] - 0.03125f * L[20] + T4 * L[2] + 0.1397542486f * L[6];
    R[1] = 0.2236067977f * L[5] + T2* L[11] - 0.02896952533f * L[29] + 0.1875f * L[1];
    R[2] = 0.375f * L[2] + T4 * L[0] + T3 * L[6] - 0.01495979856f * L[30] + T1 * L[12];
    R[3] = 0.2236067977f * L[7] - 0.02896952533f * L[31] + T2* L[13] + 0.1875f * L[3];
    R[4] = 0.101487352f * L[18] + 0.1889822365f * L[10] + 0.15625f * L[4];
    R[5] = 0.2236067977f * L[1] + T5 * L[11] + 0.3125f * L[5] + 0.09568319309f * L[19];
    R[6] = T6 * L[12] + T3 * L[2] + 0.3125f * L[6] + 0.113550327f * L[20] + 0.1397542486f * L[0];
    R[7] = T5 * L[13] + 0.09568319309f * L[21] + 0.2236067977f * L[3] + 0.3125f * L[7];
    R[8] = 0.15625f * L[8] + 0.101487352f * L[22] + 0.1889822365f * L[14];
    R[9] = 0.09068895910f * L[27] + 0.1666666667f * L[17] + 0.13671875f * L[9];
    R[10] = T7 * L[18] + 0.2734375f * L[10] + 0.09068895910f * L[28] + 0.1889822365f * L[4];
    R[11] = T8 * L[29] + TA * L[19] + T5 * L[5] + 0.30078125f * L[11] + T2* L[1];
    R[12] = T9 * L[20] + 0.328125f * L[12] + T6 * L[6] + 0.1028316139f * L[30] + T1 * L[2];
    R[13] = 0.30078125f * L[13] + T8 * L[31] + TA * L[21] + T5 * L[7] + T2* L[3];
    R[14] = 0.2734375f * L[14] + 0.09068895910f * L[32] + 0.1889822365f * L[8] + T7 * L[22];
    R[15] = 0.0906889591f * L[33] + 0.13671875f * L[15] + 0.1666666667f * L[23];
    R[16] = 0.1507556723f * L[26] + 0.123046875f * L[16];
    R[17] = 0.24609375f * L[17] + 0.1666666667f * L[9] + 0.201007563f * L[27];
    R[18] = 0.101487352f * L[4] + T7 * L[10] + 0.2302830933f * L[28] + 0.28125f * L[18];
    R[19] = TD * L[19] + 0.09568319309f * L[5] + TA * L[11] + 0.2461829819f * L[29];
    R[20] = T9 * L[12] + TC * L[30] + 0.113550327f * L[6] - 0.03125f * L[0] + TD   * L[20];
    R[21] = 0.2461829819f * L[31] + TA * L[13] + 0.9568319309e-1f * L[7] + TD * L[21];
    R[22] = 0.101487352f * L[8] + 0.28125f * L[22] + T7 * L[14] + 0.2302830933f * L[32];
    R[23] = 0.201007563f * L[33] + 0.1666666667f * L[15] + 0.24609375f * L[23];
    R[24] = 0.1507556723f * L[34] + 0.123046875f * L[24];
    R[25] = 0.1127929688f * L[25];
    R[26] = 0.2255859375f * L[26] + 0.1507556723f * L[16];
    R[27] = 0.9068895910e-1f * L[9] + 0.201007563f * L[17] + 0.2631835938f * L[27];
    R[28] = 0.2302830933f * L[18] + 0.9068895910e-1f * L[10] + 0.30078125f * L[28];
    R[29] = 0.1083940385f * L[11] + 0.2461829819f * L[19] - 0.02896952533f * L[1] + TB * L[29];
    R[30] = 0.322265625f * L[30] + TC * L[20] - 0.01495979856f * L[2] + 0.1028316139f * L[12];
    R[31] = 0.2461829819f * L[21] - 0.02896952533f * L[3] + TB * L[31] + 0.1083940385f * L[13];
    R[32] = 0.09068895910f * L[14] + 0.2302830933f * L[22] + 0.30078125f * L[32];
    R[33] = 0.09068895910f * L[15] + 0.201007563f * L[23] + 0.2631835938f * L[33];
    R[34] = 0.2255859375f * L[34] + 0.1507556723f * L[24];
    R[35] = 0.1127929688f * L[35];
}
```

# A9 アンビエントキューブ基底 {id="sec:A9"}

TODO

# A10 {id="sec:A10"}
