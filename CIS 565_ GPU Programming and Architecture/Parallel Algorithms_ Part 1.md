---
title: >
Parallel Algorithms: Part 1 [@Cozzi2017b]
numberSections: false
---
# 並列リダクション[Parallel Reduction]

- 数値の配列が与えられたとき、総和を見つける並列アルゴリズムを設計する
- 以下を考慮する
    - *演算強度[arithmetic intensity]*: 計算とメモリアクセスの比

<!-- p.4 -->

- 数値の配列が与えられたとき、以下を見つける並列アルゴリズムを設計する
    - 総和
    - 最大値
    - 値の積
    - 平均値
- これらのアルゴリズムはどれだけ異なるか？

<!-- p.5 -->

- *リダクション[Reduction]*: データのセットから単一の結果を計算する処理
- *並列リダクション*: それを並列にやる

<!-- p.6 -->

- 例: 総和を見つける

<!-- p.10 -->

- 勝ち抜き戦に似ている[Similar to brackets for a basketball tournament]
- n個の要素に対してlog(n)個のパス

<!-- p.11 -->

- +=に注目
- 配列はその場で修正する

# All-Prefix-Sums

- *All-Prefix-Sums*
    - 入力
        - n個の要素の配列: $[a_0, a_1, \dots, a_{n-1}]$
        - 二項の結合オペレータ[binary associate operator]: $\oplus$
        - 単位元[identity]: $I$
    - 配列を出力する: $[I, a_0, (a_0 \oplus a_1), \dots, (a_0 \oplus a_1 \oplus \dots \oplus a_{n-1})]$

<!-- p.16 -->

- 例
    - $\oplus$が加算なら、配列`[3 1 7 0 4 1 6 3]`は
    - `[0 3 4 11 11 15 16 22]`に変換される
- 順次処理のように見えるが、効率的な並列ソリューションがある

# 走査[Scan]

- *排他的走査[Exclusive Scan]*: 結果のj番目の要素は入力のj番目の要素を含まない
    - 入力: `[3 1 7 0 4 1 6 3]`
    - 出力: `[0 3 4 11 11 15 16 22]`
- *包含的走査[Inclusive Scan]*(*プリスキャン[Prescan]*): jを含むすべての要素を総和する
    - 入力: `[3 1 7 0 4 1 6 3]`
    - 出力: `[3 4 11 11 15 16 22 25]`

<!-- p.18 -->

- どうやって*包含的走査*から*排他的走査*を生成するか？
    - 入力: `[3 1 7 0 4 1 6 3]`
    - 包含的: `[3 4 11 11 15 16 22 25]`
    - 排他的: `[0 3 4 11 11 15 16 22]`
        - 右にずらして、単位元を挿入する
- 反対方向ならどうする？

<!-- p.19 -->

- *包含的走査* の並列アルゴリズムを設計する
    - 入力: `[3 1 7 0 4 1 6 3]`
    - 出力: `[3 4 11 11 15 16 22 25]`
- 考慮:
    - 加算の合計数

<!-- p.20 -->

- シングルスレッドでは素直

```c
out[0] = in[0];
for (int k = 1; k < n; ++k)
    out[k] = out[k - 1] + in[k];
```

- 長さ*n*の配列に対する*n-1*個の加算
    - (配列のインデックスを無視)
- 我々の並列バージョンにはいくつの加算があるだろう？

<!-- p.21 -->

TODO
