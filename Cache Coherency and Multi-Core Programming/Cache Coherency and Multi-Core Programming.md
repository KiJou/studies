---
title: Cache Coherency and Multi-Core Programming [@Gyrling2017]
bibliography: bibliography.bib
---
# 疑問[Questions]

- どのようにキャッシュはコア間のデータを共有するのか？
- 複数コアが同時にメモリを更新しているとき、どのようにデータの整合性を保つ[stay consistent]のか？

# 単純な2コアCPU[Simple 2-core CPU]

![](assets/04.png){width=400px}

# キャッシング[Caching]

![](assets/05.png){width=400px}

- データはキャッシュラインに格納される(64/128バイト)。
- 最近使われたキャッシュラインへは高速にアクセスできる。

# メモリは遠く離れている[Memory Is Far Away]

![PS3のアーキテクチャ](assets/06.png){width=400px}

# ICB --- インターコネクトバス[ICB - Inter Connect Bus]

- コアを接続する。
- 単なるデータではない。
- キャッシュコヒーレンスのプロトコル。
- "キャッシュコヒーレンスの分野[domain]"。
    - 通常はすべてのプロセッサとすべてのコア。

# MESIプロトコル[MESI Protocol]

- キャッシュコヒーレンス。
- キャッシュラインは一度にひとつのコアでのみ変更することができる。
- キャッシュラインは4つの状態を取ることができる。^[訳注:文言に関して[@Wikipedia:MESI]を参考にした。]
    - **M** 変更[Modified]
        - そのキャッシュだけに存在し、メインメモリ上の値から変更されている。
    - **E** 排他[Exclusive]
        - そのキャッシュだけに存在し、メインメモリ上の値と一致している(コピーを持つ)。
    - **S** 共有[Shared]
        - 他のキャッシュにも存在し、すべてがメインメモリ上の値と一致している(コピーを持つ)。
    - **I** 無効[Invalid]
        - キャッシュラインが古くなり、もはや正しくない。

# MESIプロトコルのメッセージ[MESI Protocol Message]

- メッセージはキャッシュ間のコヒーレンシーを維持するためICBで送られる。
- ICB上の誰もが'読み込み[Read]'メッセージに応答することができる。
    - メモリコントローラだけでなく他のコアも。

# MESIのメッセージタイプ[MESI Message Types]

- メッセージタイプ(キャッシュラインに関連するもの)
    - 読み込み/読み込み応答[Read / Read Acknowledge]
    - RWITW --- 書き込み目的の読み込み[Read With Intent To Write]
        - 読み込み＋無効化
    - 無効化/無効化応答[Invalidate / Invalidate Acknowledge]
        - このキャッシュラインを無効化するよう他のコアに依頼する。
    - 書き戻し[Writeback]
        - キャッシュラインをメインメモリに書き戻す。

# キャッシュライン遷移[Cache line transitions]

- キャッシュラインを読み込む。
    - 無効 -> 排他
        - ひとつのコアだけがコピーを持つ場合
    - 無効 -> 共有
        - 他のコアもコピーを持つ場合
- キャッシュラインに書き込む。
    - 排他 -> 変更
    - 共有 -> 変更
        - 他のすべてのコアはそのコアが持つこのキャッシュラインを無効化する。
- 無効化するよう指示する。
    - 排他/共有 -> 無効
    - 変更 -> 無効
        - メインメモリへの'書き戻し'が誘発する。
- 別のコアが変更済みキャッシュラインを読み込もうとする。
    - 変更 -> 共有
        - メインメモリへの'書き戻し'が誘発する。

# 選手入場[The Players...]

- 例
    - コア0 --- プロデューサー
        - `void foo() {data = 1; flag = 1;}`
    - コア1 --- コンシューマー
        - `void bar() {while (flag == 0); assert(data);}`

# キャッシュ所有権の例[Cache Ownership Example]

```c
if (a) {
    b = 4;
}
```

<!-- p.14--20 -->

1. 'a = 1'と'b = 0'は別のキャッシュライン上にあるとする。コア0のキャッシュは空であり、コア1のキャッシュは'a'と'b'のキャッシュラインを"排他"状態で持つとする。
1. コア0が`if (a)`を評価しようとするとき、
    1. コア0は自身のキャッシュに'a'を持っていないので、'a'を要求するためICBに'読み込み(a)'メッセージを送る。
    1. コア1はICBのメッセージを見て、'a'のキャッシュラインを持っていることを確認する。そして、そのキャッシュラインを"共有"状態に遷移して、ICBにそのキャッシュラインを含めた'読み込み応答(a = 1)'メッセージを送る。
    1. コア0はICBからキャッシュラインを受け取り、自身のキャッシュにインストールする。これで、コア0は'a'による分岐を評価できるようになる。
1. コア0が`b = 4`を評価しようとするとき、
    1. コア0は自身のキャッシュに'b'を持っていないので、'b'を要求するためICBに'RWITW(b)'メッセージを送る。
        - 今回は読み込み後に書き込む必要があるので、その意向を示すために'RWITW[書き込み目的の読み込み]'を送る。
    1. コア1はICBのメッセージを見て、'b'のキャッシュラインを持っていることを確認する。そして、そのキャッシュラインを"無効"状態に遷移して、ICBにそのキャッシュラインを含めた'RWITW(b = 0)'メッセージを送る。
        - 'RWITW'メッセージは'無効化'の要求でもある。
    1. コア0はICBからキャッシュラインを受け取り、自身のキャッシュに"排他"状態でインストールする。これで、コア0は'b'を単独で持っていることになる。
    1. コア0は'b'に4を格納する。このとき、そのキャッシュラインを"変更"に遷移させるが、メインメモリにはまだ書き戻さない。

# 2コアCPU＋StoreQ[^store_q][2-core CPU + Store Qs]

[^store_q]: 訳注:store queueのこと？

![](assets/21.png){width=400px}

# StoreQの理由[Reasons for Store Q]

- 不足分の/無効なキャッシュラインを待っている間のCPU実行ストールを軽減する。
- キャッシュラインがより容易に利用可能である場合、ロードはストアを"通過[pass]"する。
    - すでにローカルキャッシュで、または、隣接するコアによって利用可能かもしれない。
- メモリが局所的に動作しているコアに対して同じに見えることを保証するためにロードに対するStoreQのスヌーピング(覗き見)[snooping]を要求する。
    - ストアがキャッシュに入れなかったとしても、続くロードは格納された値をロードするべきである。

# StoreQ問題の例[Store Q Issue Example]

```c
void foo() {
    data = 1;
    flag = 1;
}
```
: コア0

```c
void bar() {
    while (flag == 0);
    assert(data);
}
```
: コア1

<!--  -->

1. 前提として、
    - コア0は`foo`を実行する。
    - コア1は`bar`を実行する。
    - `flag`のキャッシュラインはコア0が所有する。
    - `data`のキャッシュラインはコア1が所有する。
1. コア0はストア命令をStoreQに保存する。そして、`data`がキャッシュに存在しないので、それ用のRWITWメッセージを送る。
1. コア1は、`flag`がキャッシュに存在しないので、それ用の読み込みメッセージを送る。
1. コア0は`flag`を所有しているので、キャッシュを1に更新して"変更"状態に遷移させる。
1. コア0は`flag`の読み込み要求に応答して、そのキャッシュラインをメインメモリに書き戻して、"共有"状態に遷移させる。
1. コア1は読み込み応答を受け取り、キャッシュラインを"共有"状態に遷移させる。
1. コア1は次の命令に移行する。`data`はキャッシュにあり、読み込まれる。アサート!!
1. コア1は遅れてきたRWITWメッセージを受け取り、キャッシュラインを"無効"状態に遷移させる。
1. コア0はキャッシュラインを受け取り、キャッシュにインストールする。
1. コア0のStoreQは`flag`のキャッシュラインへの書き込みをコミットできるが、これでは遅すぎる。コア1は停止[halt]し、実行がストップする。

# どうやってこの問題を解決するか？[How do we solve this issue?]

- すべてのキャッシュはメインメモリの一貫性のある視点を持つが、ローカルな書き込みはその範疇ではない。
- 格納されるデータは'キャッシュコヒーレントな領域[domain]'の一部であることを保証する方法が必要である。
    - すなわち、他のコアによって見えている。
        - すなわち、他のコアによってフェッチされることができる。
- StoreQをキャッシュにフラッシュできる？
    - メモリストアバリア(`__mb_release`)

# メモリストアバリア[Memory Store Barirers]

- メモリバリアより先行しているStoreQ中のすべてのデータがキャッシュ中に存在するようになるまで返らないCPU命令。
    - CPUは悪である！
- コンパイラがこのバリアをまたいでメモリストアを最適化するのを防ぐ。
    - コンパイラは悪である！
- キャッシュ中にデータが存在するようになれば、すべての他のキャッシュでキャッシュラインが無効化されるため、すべての他のキャッシュによって確認できるようになる。
    - RWITW(書き込み目的の読み込み)
        - 読み込み＋無効化

# StoreQ問題の例(修正版)

TODO

# 参考文献[References]
