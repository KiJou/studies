---
title: Physically Based and Unified Volumetric Rendering in Frostbite [@Hillaire2015]
---
# FROSTBITE

# Physically Based and Unified Volumetric Rendering in Frostbite

# 背景[context]

- Frostbiteにおける**物理ベースレンダリング**
    - [@Lagarde & de Rousiers 2014]を参照
    - ビジュアル上の品質における大幅な向上

# 背景

- Frostbiteにおける**ボリューメトリックレンダリング**は制約があった
    - 大局的な距離/高さフォグ
    - スクリーン空間のライトシャフト
    - パーティクル

# 現実のボリューメトリック

大気と雲
密度の変化
散乱事象
さらなるフォグ
散乱の遮蔽

# 過去の研究[previous work]

- **ビルボード**
- **解析的なフォグ**[@Wenzel07]
- **解析的な光散乱**[@Miles]
- **ライトシャフト**
    - ポストプロセス[@Mitchell07]
    - エピポーラサンプリング[@Engelhardt10]

解析的なフォグ/光散乱
高速！
影付けされない
均質媒質のみ

スクリーン空間のライトシャフト
高品質
太陽/空がスクリーン上に見えている必要がある
均質媒質のみ
エピポーラサンプリングでできるが、これが窮地から救ってくれることはないだろう

# 過去の研究

- **Splatting**
    - ライトボリューム
        - [@Valliant14; @Glatzel14; @Hillaire]
    - エミッシブボリューム[@Lagarde13]
- **ボリューメトリックフォグ**[@Wronski14]
    - 太陽とローカルライト
    - 不均質媒質

splatting手法は、例えばlight volume splattingのようなものとして、この新しいコンソール世代と共に広く現れた。これは高品質な散乱となり得るが、通常は、シーンの関与媒質と一致しない。

より最近では、Wronskiは*Volumetric Fog*と呼ばれる、空間的に変化する関与媒質やローカルライトの散乱を可能にする技術をプレゼンテーションした。我々は、このプレゼンテーションで分かる通り、この時点で我々が行っていたことと一致[align with]したので、これと出会えたことが嬉しかった。しかし、この時点で本当に物理ベースであるようには見えず、我々の望んだいくつかの機能が欠けていた。

# 研究範囲[scope]と動機

- **ビジュアル上の品質を向上**させ、アートディレクションへのさらなる自由度をもたらす！
- **物理ベースのボリューメトリックレンダリング**
    - 意味のあるマテリアルパラメータ
    - ライティングからマテリアルを分離する
    - 一貫性のある結果
- **統一された**ボリューメトリック的相互作用

ボリューメトリックレンダリングをもたらすことはビジュアル上の複雑さの向上を可能にし、より多用なビジュアルやアートディレクションをもたらすだろう。

我々はそれが物理ベースであることを欲する。これは関与媒質のマテリアルが光源から分離されることを意味する(例えば、ライトエンティティ上では色が散乱しない)。媒質のパラメータは意味のあるパラメータセットでもある。これにより、我々はより制御し易く理解し易い、より一貫性のある結果を得るはずである。

また、Frostbiteではボリューメトリックと相互作用するエンティティがいくつか存在するためでもある(フォグ、パーティクル、不透明および透明な表面、など)。我々は、X種の相互作用に対してXつの手法を持たないように、それを扱う方法を統一したいとも考えている。

# 結果

# 概要

- **ボリューメトリックレンダリング**
- ボリューメトリックシャドウ
- Frostbiteにおけるさらなるボリューメトリックレンダリング
- 終わりに

# ボリューメトリックレンダリング: 単一散乱[single scattering]

$$
L_i(x, \omega_i) = T_r(x, x_s) L_s(x_s, \omega_o) + \int_0^s T_r(x, x_t) \sigma_t(x) L_{scat}(x_t, \omega_i) dt
$$

$$
Tr(x, x_s) = \exp \left( -\int_0^s \sigma_t(x) dt \right)
$$

$$
L_{scat}(x_t, \omega_i) = \rho \sum_{l = 0}^{lights} f(v, l) Vis(x, l) L_i(x, l)
$$

$$
Vis(x, l) = shadowMap(x, l) * volumetricShadowMap(x, l)
$$

今現在、我々はボリューメトリックをレンダリングするときに自身を単一散乱に制約する。これでもきちんと理解するには相応の力が必要になる[This is already challenging to get right]。

light surfaceが表面と相互作用するとき、例えばBRDFを計算することによってカメラにバウンスする光の量を計算できる。だが、関与媒質の存在によって、事はより複雑になる。

- 光が媒質の中を伝わってゆくときに透過率を計算に入れなければならない
- その後、多数のサンプルを取ることによって視線[view ray]に沿って散乱光[scattered light]を積分する必要がある
- これらのサンプルごとに、視点への透過率を計算に入れる必要もある
- 各点での散乱光を積分する必要もある
- そして、位相関数、通常のシャドウマップ(不透明オブジェクト)、ボリューメトリックシャドウマップ(関与媒質とその他のボリューメトリックエンティティ)を計算に入れる必要もある

# 我々のアプローチ: クリップ空間のボリューム

- **錐台に並行**な3Dテクスチャ[@Wronski14]
    - ワールド空間における錐台ボクセル => *Froxel*
- 注意: Frostbiteは**タイルベースのディファード**ライティングである
    - カリングされたライトリストを持つ16x16タイル
- **ライトタイルにボリュームタイルを揃える**
    - タイルあたりのカリングされたライトリストを再利用する
    - ボリュームタイルはより小さくできる(8x8、4x4、など)
    - 解像度の整数の除算に対する*補正*に気を付ける
- **デフォルト**: 8x8のボリュームタイル、64の深度スライス

Wronskiにある通り、すべてのボリュームはクリップ空間に並行な3Dテクスチャである(そのようなボクセルはワールド空間における*Froxel*になる。Alex EvansとSony ATGのおかげ[credit]、*Learning from Failure: a Survey of Promising, Unconventional and Mostly Abandoned Renderers for ‘Dreams PS4’, a Geometrically Dense, Painterly UGC Game’, Advances in Real-Time Rendering course, SIGGRAPH 2015*を参照)。

このボリュームはスクリーンライトタイルに並行でもある。これは散乱光の計算を加速するためにフォワードライトタイルリストカリングの結果を再利用しているためである(Frostbiteはタイルベースのディファードライティングエンジンであることを思い出して欲しい)。

スクリーン空間におけるボリュームタイルは(16x16ピクセルである)ライトタイルより小さくできる。

デフォルトでは、我々は以下を用いる。

- 64の深度解像度
- 8x8のボリュームタイル
<!--  -->
- 720pは160x90x64を必要とする(RGBAF16テクスチャあたり約7MB)
- 1080pは240x135x64を必要とする(RGBAF16テクスチャあたり約15MB)

# 我々のアプローチ: データの流れ

|||||
|-|-|-|-|
|**入力データ**|関与媒質のエンティティ<br>↓|ライティングおよびシャドウイング情報<br>↓||
|**クリップ空間**ボリューム|1. マテリアル特性→|2. Froxel光散乱→|3. 最終統合|

これは我々のデータの流れの概要である。
我々は様々なパイプラインのステージでデータを格納するためにクリップ空間のボリュームを用いている。

我々は関与媒質のエンティティから最初にボクセル化されたマテリアル特性を持つ。

すると、シーンの光源とこのマテリアル特性ボリュームを用いて、froxelあたりの散乱光データを生成できる。このデータは品質を向上させるために時間的にアップサンプリングできる。最後に、我々はレンダリングのためのデータを準備する統合ステップを持つ。

# 我々のアプローチ: データの流れ

1. マテリアル特性

# 関与媒質のマテリアルの定義

- 理論に従う[@PBR]
    - **吸収** $\sigma_a [m^{-1}]$
    - **散乱** $\sigma_s [m^{-1}]$
    - **位相** $g$
    - **発光[emissive]** $\sigma_e [放射照度 \cdot m^{-1}]$
    - 消散 $\sigma_t = \sigma_s + \sigma_a$
    - アルベド $\rho = \sigma_s / \sigma_t$
- アーティストは{吸収、散乱}か{アルベド、消散}を制作できる
    - アーティストを訓練しよう！それらの意味する所を理解することが彼らにとって重要である！

関与媒質は物理ベースレンダリングにおける最新技術に従って定義される。

我々は以下の特性のリストを持つ。

- 吸収、ある経路長以上で媒質によって吸収される光の量を説明する
- 散乱、ある経路長以上で散乱する光の量を説明する
- 発光、放射する光をを説明する
- 単一ローブ位相関数、光がどれだけ粒子でバウンスするかを説明する(一様に、全貌散乱、など)。これはHenyey-Greensteinに基づく(そして、Schlick近似を用いることができる)。

すべての物理ベース要素にある通り、これらを理解すること、つまり、アーティストを教育するのに時間をかけることが彼らにとって非常に重要である。

# 関与媒質(PM)の特性のボクセル化

- PM源
    - 深度フォグ
    - 高さフォグ
    - ローカルフォグボリューム
        - 密度テクスチャあり/なし
- PMの特性を**Vバッファ**にボクセル化する
    - 散乱、発光、消散を追加する
    - 位相$g$を平均化る(複数ローブなし)
    - 波長に非依存な$\sigma_t$(今の所は)

|||||フォーマット|
|-|-|-|-|-|
|散乱R|散乱G|散乱B|消散|RGBA16F|
|発光R|発光G|発光B|位相(g)|RGBA16F|
: Vバッファ(Froxelあたりのデータ)

深度/高さフォグとローカルフォグボリュームはボクセル化できるエンティティである。ここではそのまま、または、密度テクスチャに従って変化する密度を持つローカルフォグボリュームを確認できる。

我々は、ボリューム(クリップ空間)である以外はスクリーンのGバッファに類似しているVバッファにこれらをボクセル化する。これらは線形であるので基本的にすべてのマテリアルパラメータを一緒に加算する。平均される位相関数を除いて。HG位相関数に従って今のところは単一ローブのみを考慮する。

我々はより安価なボリューム(マテリアル、ライティング、シャドウイング)を持つために波長に非依存な消散で行うことを意図的に選択した。しかし、これはいくつかの点で必要ならば拡張するのが非常に容易であるだろう。発光をサポートすることは、散乱のように光を放射するがローカルライトと一致しないローカルフォグボリュームを配置する[position]ためのアーティストに対する利点である。これは安価なアンビエントライティングで使える。

# 我々のアプローチ: データの流れ

2. Froxel光散乱

# Froxelの積分

- froxelあたり
    1. PM特性のデータをサンプルする
    2. 計算する
        1. 散乱光$L_{scat}(x_t, \omega_o)$
        2. 消散
- 散乱光:
    - froxelあたり1サンプル
    - すべての光源を積分する: 間接光＋太陽＋ローカルライト

|||フォーマット|
|-|-|-|
|カメラへの散乱光RGB|消散|RGBA16F|
: 散乱/透過率バッファ

froxelごとに、ひとつのスレッドは散乱光と消散の収集を担当する[be in charge of]だろう。

消散はそのマテリアルから単に[copy over]される。あなたはこれが最終ステージにおけるビジュアル上の品質のために重要である訳を後に理解するだろう(エネルギー保存される散乱に対して透過率ではなく消散を使うため)。消散は線形でもあり、そのため、非線形な透過率の値ではなくこれを時間的に積分するのがより良いだろう。

# Froxelの積分: 太陽/アンビエント/発光

- ローカルフォグボリュームでの間接光
    - FrostbiteのディフューズSHライトプロブに由来
        - ボリュームの中心にプロブが1つ
        - SHコサインローブのように位相関数に関して積分する[@Wronski14]
- 太陽光
    - カスケードされたシャドウマップをサンプルする

そして、散乱光を積分する。froxelあたり1サンプル。

まずWronskiと同じ方法でアンビエントを積分する。FrostbiteはディフューズSHライトプロブをサンプルすることが可能である。我々はローカルフォグボリュームあたりにこれらの中心に配置される1つを用いる。

我々はカスケードされたシャドウマップに従って太陽光を積分する。指数シャドウマップを用いることができるだろうが、テンポラルアップサンプリングが結果をソフトにするのに十分であるので、使わない。

ここで示されるローカルフォグの不均質な特徴に容易に気付くことができる。

# Froxelの積分: ローカルライト

- ローカルライト
    - tiled-lightingのコードを再利用する
    - カリング後のフォワードタイルライトリストを用いる
    - 散乱しない？ローカルライトを省略する
- シャドウ
    - 通常のシャドウマップ
    - **ボリューメトリックシャドウマップ**

我々はローカルライトも統合する。そして、我々は各タイル内で可視であるライトを計算に入れるためだけにタイルカリングの結果を再利用する。
良い最適化のひとつはマテリアル特性に従って散乱が起こり得ない場合にすべてを省略することである。

これらのライトのそれぞれもまた関連するシャドウマップをサンプルできる。通常のシャドウマップとボリューメトリックシャドウマップもサポートする(後述)。

# テンポラルボリューメトリック積分

- フレームあたり1つの散乱/消散サンプル
    - 非常に強烈な[strong]マテリアルでの**アンダーサンプリング**
    - カメラ動作中の**エイリアシング**
    - シャドウはこれをより悪くする

述べた通り、我々はfroxelあたり1つのサンプルを用いるのみである。

これは残念ながら、非常に薄い関与媒質に対して、および、ローカルライトの寄与を統合するとき、非常に強烈なエイリアシングをもたらし得る。

# テンポラルボリューメトリック積分

# テンポラルボリューメトリック積分

- 解法: テンポラル積分
    - **ジッタリングされるサンプル**(Halton)
        - 視線に沿ったすべてのサンプルに対する同じオフセット
        - **散乱およびマテリアル**のサンプルを同時にジッタリングする
    - 前の散乱/消散を**再投影**する
        - 現在のものを前のものと5%ブレンドする
        - 指数関数的な移動平均[exponential moving average] [@Karis14]
        - 錐台の外: 履歴を省略する

これらの問題を和らげるため、我々はフレームの結果を前のフレームのものと時間的に統合する(ご存知の通り、去年KarisがTAAで使ってもいる)。

これを達成するため、

- 我々は視線に沿って一様にフレームあたりのサンプルをジッタリングする
- マテリアルおよび散乱光のサンプルは(計算されるマテリアルおよび散乱光をソフトにするために)同じオフセットを用いてジッタリングされる
- 指数関数的な移動平均に従って各フレームを統合する
- 履歴サンプルが利用できない(前の錐台の外)場合には前の結果を無視する

# テンポラルボリューメトリック積分あり

# テンポラルボリューメトリック積分あり

# テンポラルボリューメトリック積分

- 残っている**問題**
    - **マテリアルのアニメーション**は跡を残す[leaves trails]
        - 速度を用いて再投影する？
        - 複数のボリュームの交差では？
        - アニメーションするボリューム(たとえば、流体シミュレーション)では？
    - **ライトの移動**は跡を残す
        - 近傍クランプ[neighbour clamping]を使う？[@Karis14]
    - チャレンジングなR&D領域！


# 我々のアプローチ: データの流れ

3. 最終統合

# 最終的なPMボリューム

- 視線に沿ってfroxelの{散乱、消散}を統合する
    - 位置$x_s$でのfroxelごとの{$L_i(x, \omega_o)$、$T_r(x, x_s)$}を解く

我々は基本的に透過率に従って近から遠の散乱を累積する。これは視線に沿ってfroxelごとに積分された散乱光と透過率を解くだろう。

ここに示されるコードサンプルを用いることができるだろう。つまり、accumulate scattering and then transmittance for the next froxel, and this slice by slice.しかし、これは完全に誤りである。確かに、accumScatteringTransmittance.aの値(透過率)への依存性がある。我々は散乱の透過率をはじめに更新すべきだろうか？

# 最終的なPMボリューム

- エネルギー保存的でない積分
    - 単一散乱光は$S = L_{scat}(x_t, \omega_o)$をサンプルする。OK
    - 単一透過率は$T_r(x, x_s)$をサンプルする。NOT OK
- -> froxelの深度$D$上で透過率に関するライティングを積分する
    - $\int_0^D e^{-\sigma_t x} \times S dx = \frac{S - S \times e^{\sigma_t D}}{\sigma_t}$

ここでは散乱の特性を増加させたときの複数のボリュームを確認できる。散乱の後に透過を統合することがエネルギー保存的でないことがわかりやすい。
我々は操作の順序を逆にできるだろう。…。

これを改善する方法とは？1つのライトサンプルおよび1つ消散サンプルを持つことが分かっている。

ライトサンプルを維持できる。計算するのが高価であり、深度スライス内で視線に沿って一定であると仮定するのに十分である。

ただし、単一の透過率は完全に誤りである。透過率は実際に深度レイヤの近くの界面で0に、幅$d$の深度スライスの遠くの界面で$\exp(-\mu_t d)$になるはずである。

これを解くためにすることはスライス内で視線範囲上の各点における透過率に従って解析的に散乱光を積分することである。これは1つの消散サンプルに従って定められた範囲上で一定の散乱光の解析的積分がこの方程式を減らせることを容易に求めることができる。
これを用いて、最終的に散乱および単一の消散サンプルに関するこれに対する一貫性のあるライティング結果を得る。

# 最終的なPMボリューム

- ボリューメトリックシャドウと共に改善する

修正した積分なし: ライトリーク
改善した積分あり

# 最終的なPMボリューム シーンレンダリング

- 事前乗算済み色/アルファと似た{$L_i(x, \omega_o)$、$T_r(x, x_s)$}
- ピクセルごとに不透明な表面に適用される
- 頂点ごとに透明な表面で計算され、ピクセルごとに適用される

ひとたび最終的に統合されたバッファを持てば、我々は空レンダリングパス中にシーンのすべてに適用できる。カメラに届く散乱光や透過率を含むため、すべてに事前計算済み色/アルファのように適用するのが容易である。

効率性のため、透明物には頂点ごとに適用されるが、より良い品質のためにピクセルごとに切り替えることを考えている。

# 結果の評価

- Mitsubaによるリファレンスと結果を比較する
    - 物理ベースのパストレーサー
    - 同じ条件: 単一散乱のみ、露出、ほか
- シーン1:

# 結果の評価 --- シーン1

# 結果の評価 --- シーン2

# パフォーマンス

- 太陽＋シャドウカスケード
- 14つのポイントライト
    - 2つは通常およびボリューメトリックシャドウ付き
- 6つのローカルライトボリューム
    - すべて密度テクスチャ付き

# パフォーマンス: PS4, 900p

# 概要

- ボリューメトリックレンダリング
- **ボリューメトリックシャドウ**
- Frostbiteにおけるさらなるボリューメトリックレンダリング
- 終わりに

# ボリューメトリックシャドウマップ

- 追加の**消散ボリューム**
    - 錐台に向いた**3つのクリップマップ**
        - 視界外[out-of-view]のシャドウキャスタのために必要
    - **消散を格納する**
- ボリューメトリックシャドウマップ
    - 3Dテクスチャは**透過率**を格納する
    - ポイント/スポットライトに対する正投影[ortho]/透視投影[perspective]マッピング

我々はボリューメトリックシャドウマップもサポートする(我々のシーンではシャドウ結果はボクセル化されたボリューメトリックエンティティに由来する)。

この目的のために、我々は単純で高速な解法で行った。

- まずカメラに従いカメラを含める3つのカスケードされたクリップマップボリュームを定義する。
    - 調整可能なレベルごとのボクセルサイズやワールド空間のスナッピング付き
- このボリュームはその中に再びボクセル化されるすべての関与媒質エンティティを含む(視界外のシャドウキャスタのために必要で、クリップ空間のボリュームでは不十分であろう)。
- ボリューメトリックシャドウマップは透過率を格納する(ライトひとつに割り当てられる)3Dテクスチャとして定義される。
    - 透過率は消散ボリュームをレイマーチングすることで計算される。
    - 投影はライトタイプに最もフィットするものを選ぶ(例、スポットライトに対する錐台)。
- ボリューメトリックシャドウマップは使用時に(UVスケーリングとバイアスを伴い)単一のテクスチャのみをバインドするだけでよくするためにアトラスに格納される。

# ボリューメトリックシャドウマップ

- **共通のライトシャドウシステム**の一部
    - 不透明
    - パーティクル
    - 関与媒質

ボリューメトリックシャドウマップは完全に共有されたライティングパイプラインとシェーダコードの一部である。これは、この映像に見られるように、有効化されてシーンにおけるすべて(パーティクル、不透明な表面、関与媒質)に適用されるようにしたライトごとにサンプルされる。

# ボリューメトリックシャドウマップ

トライリニア
既定

スフィア
高品質オプション
エミッタごとに選択可能

もうひとつのおまけはパーティクルのボクセル化も行うことである。

我々はたくさんのボクセル化手法を試してきた。だが、ポイントおよびそのブラーしたバージョンは単にノイジーすぎた。我々の既定のボクセル化手法はトライリニアである。シャドウが非常にソフトであり、poppingが見えないことが確認できる。

我々は、すべてのスレッドがパーティクルの球の中に含まれるボクセルすべてを書き出す、高品質なボクセル化も持つ。現時点では若干ブルートフォースだが、必要とされれば上手く機能する。

最後の映像では関与媒質上のパーティクルからのボリューメトリックシャドウの結果を確認できる。

(さらなる詳細はボーナススライドを参照)

# パフォーマンス: PS4

- 32^3の**ボリューメトリックシャドウマップ**のレイマーチング
    - スポットライト: 0.04ms
    - ポイントライト: 0.14ms
- 1Kのパーティクルボクセル化
    - デフォルト品質: 0.03ms
    - 高品質: 0.25ms

スポットライトはslice by sliceで積分されるのに対して、完全なレイトレースがポイントライトのシャドウボクセルごとに行われるので、ポイントライトはスポットライトより高価である。近い将来これを直すアイデアがある。

既定のパーティクルのボクセル化は1Kのパーティクルに対して間違いなく安価である。

# 概要

- ボリューメトリックレンダリング
- ボリューメトリックシャドウ
- **Frostbiteにおけるさらなるボリューメトリックレンダリング**
- 終わりに

# パーティクル/太陽の相互作用

- 太陽/パーティクルの相互作用に対する高品質な**散乱およびセルフシャドウイング**
- Fourier Opacity Maps [@Jansen10]
- **現在プロダクションで使われる**

Frostbiteにおける我々の半透明シャドウ(@Andersson11 を参照)はパーティクルが自分自身を除いて不透明な表面にシャドウをキャストすることを可能にする。この技術もまた散乱をサポートしない。

我々はFourier opacity mappingを用いてFrostbiteにサポートを追加した。これは非常に高品質な色付きシャドウイングを持つことを可能にし、このスクリーンショットや雲の映像に見られるように、散乱は鋭い銀色の線取りのビジュアルエフェクトをもたらす。

これは太陽に対する1つの特例(統一されていない)だが、特別な注目[attention]を必要とする太陽の特別なケースに対して必要とされた少しの追加の品質を得るために必要とされた。

# 物理ベースの空/大気

- [@Elek09]から改善した ([@Bruneton08]より単純だがより高速)
- Frostbite、Ghost、DICEチームの共作
- 実践では: **Mirror's Edge Catalyst**、**Need for Speed**、**Mass Effect Andromeda**


# おわりに

**物理ベースのボリューメトリックレンダリングフレームワークは将来のFrostbite製ゲームのすべてで用いられる**

- **物理ベース**のボリューメトリックレンダリング
    - 関与媒質のマテリアル定義
    - ライティングとシャドウイングの相互作用
- より**統一された**ボリューメトリックレンダリングシステム
    - 多くの相互作用を扱う
        - 関与媒質、ボリューメトリックシャドウ、パーティクル、不透明な表面、など

# 今後の研究

- **関与媒質レンダリング**の改善
    - エリアライトの立体角に関する位相関数の積分
    - 反射ビューの組み入れ[inclusion]
    - グラフベースのマテリアル定義、GPUシミュレーション、ストリーミング
    - より良いテンポラルインテグレーション！なにかない？[any ideas?]
    - 太陽のボリューメトリックシャドウ
    - 透明な表面からの透明なシャドウ？
- **最適化**
    - Vバッファのパッキング
    - パーティクルのボクセル化
    - ボリューメトリックシャドウマップの生成
    - 効率的に4Kスクリーンへスケールする方法

# 参考文献

# ご質問は？

# ボーナススライド

# ボリューメトリックシャドウ

このシーンは32x32x32と48x48x48の解像度でのボリューメトリックシャドウマップのデバッグビューを示している。

完璧なボクセル交差は**Amanatideのレイトレーシング**(*A Fast Voxel Traversal Algorithm for Ray Tracing* Amanatides & Woo, 1987)である。本当にオススメ！これは少ないステップでのブルートフォースレイマーチより間違いなく安価であるクリーンなボリューメトリックデバッグビューを可能にする。

# ボリューメトリックシャドウは重要である！

- 正確なセカンダリレイシャドウイング
    - 不均質媒質に対して重大
    - ボリューメトリックシャドウなし: ライト位置において$\sigma_t$で近似する

ボリューメトリックシャドウは正確に影付けされるセカンダリレイを得るために必須である。これは、不均質な関与媒質の特性および密度をサポートすることができる唯一の方法であるので、重要でもある。

ボリューメトリックシャドウを持たないライトでは、ライト位置で消散をサンプルしてライト位置の周りで一定であると仮定できるだろう。これはオーバー/アンダーシャドウをもたらすだろうが、依然としてビジュアルを改善するのに役立つだろう。

# パーティクルエフェクトボリューメトリックライティング

- 我々にはすでに**太陽からのシャドウ**がある
    - カスケードされた半透明シャドウ
    - [@Andersson11]を参照
- **ローカルライト**: ボリューメトリックシャドウマップ
    - 以下にシャドウをキャストする
        - 不透明な表面、他のエフェクト、透明物
        - 関与媒質
    - **パーティクルをボクセル化する**必要がある

# パーティクルのボクセル化

- 中間の*uint*のカスケードされた消散ボリュームを用いる
    - 1.0fの消散は2048uにマップする
    - **InterlockedAdd**を使ってボクセル化する
        - particleCountに対してメモリへのコンピュートスレッドコヒーレントな書き込みを必要とする

#

TODO
