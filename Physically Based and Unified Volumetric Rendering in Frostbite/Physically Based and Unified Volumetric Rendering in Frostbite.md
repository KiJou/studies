---
title: Physically Based and Unified Volumetric Rendering in Frostbite [@Hillaire2015]
---
# FROSTBITE

# Physically Based and Unified Volumetric Rendering in Frostbite

# 背景[context]

- Frostbiteにおける**物理ベースレンダリング**
    - [@Lagarde & de Rousiers 2014]を参照
    - ビジュアル上の品質における大幅な向上

# 背景

- Frostbiteにおける**ボリューメトリックレンダリング**は制約があった
    - 大局的な距離/高さフォグ
    - スクリーン空間のライトシャフト
    - パーティクル

# 現実のボリューメトリック

大気と雲
密度の変化
散乱事象
さらなるフォグ
散乱の遮蔽

# 過去の研究[previous work]

- **ビルボード**
- **解析的なフォグ**[@Wenzel07]
- **解析的な光散乱**[@Miles]
- **ライトシャフト**
    - ポストプロセス[@Mitchell07]
    - エピポーラサンプリング[@Engelhardt10]

解析的なフォグ/光散乱
高速！
影付けされない
均質媒質のみ

スクリーン空間のライトシャフト
高品質
太陽/空がスクリーン上に見えている必要がある
均質媒質のみ
エピポーラサンプリングでできるが、これが窮地から救ってくれることはないだろう

# 過去の研究

- **Splatting**
    - ライトボリューム
        - [@Valliant14; @Glatzel14; @Hillaire]
    - エミッシブボリューム[@Lagarde13]
- **ボリューメトリックフォグ**[@Wronski14]
    - 太陽とローカルライト
    - 不均質媒質

splatting手法は、例えばlight volume splattingのようなものとして、この新しいコンソール世代と共に広く現れた。これは高品質な散乱となり得るが、通常は、シーンの関与媒質と一致しない。

より最近では、Wronskiは*Volumetric Fog*と呼ばれる、空間的に変化する関与媒質やローカルライトの散乱を可能にする技術をプレゼンテーションした。我々は、このプレゼンテーションで分かる通り、この時点で我々が行っていたことと一致[align with]したので、これと出会えたことが嬉しかった。しかし、この時点で本当に物理ベースであるようには見えず、我々の望んだいくつかの機能が欠けていた。

# 研究範囲[scope]と動機

- **ビジュアル上の品質を向上**させ、アートディレクションへのさらなる自由度をもたらす！
- **物理ベースのボリューメトリックレンダリング**
    - 意味のあるマテリアルパラメータ
    - ライティングからマテリアルを分離する
    - 一貫性のある結果
- **統一された**ボリューメトリック的相互作用

ボリューメトリックレンダリングをもたらすことはビジュアル上の複雑さの向上を可能にし、より多用なビジュアルやアートディレクションをもたらすだろう。

我々はそれが物理ベースであることを欲する。これは関与媒質のマテリアルが光源から分離されることを意味する(例えば、ライトエンティティ上では色が散乱しない)。媒質のパラメータは意味のあるパラメータセットでもある。これにより、我々はより制御し易く理解し易い、より一貫性のある結果を得るはずである。

また、Frostbiteではボリューメトリックと相互作用するエンティティがいくつか存在するためでもある(フォグ、パーティクル、不透明および透明な表面、など)。我々は、X種の相互作用に対してXつの手法を持たないように、それを扱う方法を統一したいとも考えている。

# 結果

# 概要

- **ボリューメトリックレンダリング**
- ボリューメトリックシャドウ
- Frostbiteにおけるさらなるボリューメトリックレンダリング
- 終わりに

# ボリューメトリックレンダリング: 単一散乱[single scattering]

$$
L_i(x, \omega_i) = T_r(x, x_s) L_s(x_s, \omega_o) + \int_0^s T_r(x, x_t) \sigma_t(x) L_{scat}(x_t, \omega_i) dt
$$

$$
Tr(x, x_s) = \exp \left( -\int_0^s \sigma_t(x) dt \right)
$$

$$
L_{scat}(x_t, \omega_i) = \rho \sum_{l = 0}^{lights} f(v, l) Vis(x, l) L_i(x, l)
$$

$$
Vis(x, l) = shadowMap(x, l) * volumetricShadowMap(x, l)
$$

今現在、我々はボリューメトリックをレンダリングするときに自身を単一散乱に制約する。これでもきちんと理解するには相応の力が必要になる[This is already challenging to get right]。

light surfaceが表面と相互作用するとき、例えばBRDFを計算することによってカメラにバウンスする光の量を計算できる。だが、関与媒質の存在によって、事はより複雑になる。

- 光が媒質の中を伝わってゆくときに透過率を計算に入れなければならない
- その後、多数のサンプルを取ることによって視線[view ray]に沿って散乱光[scattered light]を積分する必要がある
- これらのサンプルごとに、視点への透過率を計算に入れる必要もある
- 各点での散乱光を積分する必要もある
- そして、位相関数、通常のシャドウマップ(不透明オブジェクト)、ボリューメトリックシャドウマップ(関与媒質とその他のボリューメトリックエンティティ)を計算に入れる必要もある

# 我々のアプローチ: クリップ空間のボリューム

- **錐台に並行**な3Dテクスチャ[@Wronski14]
    - ワールド空間における錐台ボクセル => *Froxel*
- 注意: Frostbiteは**タイルベースのディファード**ライティングである
    - カリングされたライトリストを持つ16x16タイル
- **ライトタイルにボリュームタイルを揃える**
    - タイルあたりのカリングされたライトリストを再利用する
    - ボリュームタイルはより小さくできる(8x8、4x4、など)
    - 解像度の整数の除算に対する*補正*に気を付ける
- **デフォルト**: 8x8のボリュームタイル、64の深度スライス

Wronskiにある通り、すべてのボリュームはクリップ空間に並行な3Dテクスチャである(そのようなボクセルはワールド空間における*Froxel*になる。Alex EvansとSony ATGのおかげ[credit]、*Learning from Failure: a Survey of Promising, Unconventional and Mostly Abandoned Renderers for ‘Dreams PS4’, a Geometrically Dense, Painterly UGC Game’, Advances in Real-Time Rendering course, SIGGRAPH 2015*を参照)。

このボリュームはスクリーンライトタイルに並行でもある。これは散乱光の計算を加速するためにフォワードライトタイルリストカリングの結果を再利用しているためである(Frostbiteはタイルベースのディファードライティングエンジンであることを思い出して欲しい)。

スクリーン空間におけるボリュームタイルは(16x16ピクセルである)ライトタイルより小さくできる。

デフォルトでは、我々は以下を用いる。

- 64の深度解像度
- 8x8のボリュームタイル
<!--  -->
- 720pは160x90x64を必要とする(RGBAF16テクスチャあたり約7MB)
- 1080pは240x135x64を必要とする(RGBAF16テクスチャあたり約15MB)

# 我々のアプローチ: データの流れ

|||||
|-|-|-|-|
|**入力データ**|関与媒質のエンティティ<br>↓|ライティングおよびシャドウイング情報<br>↓||
|**クリップ空間**ボリューム|1. マテリアル特性→|2. Froxel光散乱→|3. 最終統合|

これは我々のデータの流れの概要である。
我々は様々なパイプラインのステージでデータを格納するためにクリップ空間のボリュームを用いている。

我々は関与媒質のエンティティから最初にボクセル化されたマテリアル特性を持つ。

すると、シーンの光源とこのマテリアル特性ボリュームを用いて、froxelあたりの散乱光データを生成できる。このデータは品質を向上させるために時間的にアップサンプリングできる。最後に、我々はレンダリングのためのデータを準備する統合ステップを持つ。

# 我々のアプローチ: データの流れ

1. マテリアル特性

# 関与媒質のマテリアルの定義

- 理論に従う[@PBR]
    - **吸収** $\sigma_a [m^{-1}]$
    - **散乱** $\sigma_s [m^{-1}]$
    - **位相** $g$
    - **発光[emissive]** $\sigma_e [放射照度 \cdot m^{-1}]$
    - 消散 $\sigma_t = \sigma_s + \sigma_a$
    - アルベド $\rho = \sigma_s / \sigma_t$
- アーティストは{吸収、散乱}か{アルベド、消散}を制作できる
    - アーティストを訓練しよう！それらの意味する所を理解することが彼らにとって重要である！

関与媒質は物理ベースレンダリングにおける最新技術に従って定義される。

我々は以下の特性のリストを持つ。

- 吸収、ある経路長以上で媒質によって吸収される光の量を説明する
- 散乱、ある経路長以上で散乱する光の量を説明する
- 発光、放射する光をを説明する
- 単一ローブ位相関数、光がどれだけ粒子でバウンスするかを説明する(一様に、全貌散乱、など)。これはHenyey-Greensteinに基づく(そして、Schlick近似を用いることができる)。

すべての物理ベース要素にある通り、これらを理解すること、つまり、アーティストを教育するのに時間をかけることが彼らにとって非常に重要である。

# 関与媒質(PM)の特性のボクセル化

- PM源
    - 深度フォグ
    - 高さフォグ
    - ローカルフォグボリューム
        - 密度テクスチャあり/なし
- PMの特性を**Vバッファ**にボクセル化する
    - 散乱、発光、消散を追加する
    - 位相$g$を平均化る(複数ローブなし)
    - 波長に非依存な$\sigma_t$(今の所は)

|||||フォーマット|
|-|-|-|-|-|
|散乱R|散乱G|散乱B|消散|RGBA16F|
|発光R|発光G|発光B|位相(g)|RGBA16F|
: Vバッファ(Froxelあたりのデータ)

深度/高さフォグとローカルフォグボリュームはボクセル化できるエンティティである。ここではそのまま、または、密度テクスチャに従って変化する密度を持つローカルフォグボリュームを確認できる。

我々は、ボリューム(クリップ空間)である以外はスクリーンのGバッファに類似しているVバッファにこれらをボクセル化する。これらは線形であるので基本的にすべてのマテリアルパラメータを一緒に加算する。平均される位相関数を除いて。HG位相関数に従って今のところは単一ローブのみを考慮する。

我々はより安価なボリューム(マテリアル、ライティング、シャドウイング)を持つために波長に非依存な消散で行うことを意図的に選択した。しかし、これはいくつかの点で必要ならば拡張するのが非常に容易であるだろう。発光をサポートすることは、散乱のように光を放射するがローカルライトと一致しないローカルフォグボリュームを配置する[position]ためのアーティストに対する利点である。これは安価なアンビエントライティングで使える。

# 我々のアプローチ: データの流れ

2. Froxel光散乱

# Froxelの積分

TODO
