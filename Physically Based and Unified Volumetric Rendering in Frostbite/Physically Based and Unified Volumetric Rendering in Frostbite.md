---
title: Physically Based and Unified Volumetric Rendering in Frostbite [@Hillaire2015]
---
# FROSTBITE

# Physically Based and Unified Volumetric Rendering in Frostbite

# 背景[context]

- Frostbiteにおける**物理ベースレンダリング**
    - [@Lagarde & de Rousiers 2014]を参照
    - ビジュアル上の品質における大幅な向上

# 背景

- Frostbiteにおける**ボリューメトリックレンダリング**は制約があった
    - 大局的な距離/高さフォグ
    - スクリーン空間のライトシャフト
    - パーティクル

# 現実のボリューメトリック

大気と雲
密度の変化
散乱事象
さらなるフォグ
散乱の遮蔽

# 過去の研究[previous work]

- **ビルボード**
- **解析的なフォグ**[@Wenzel07]
- **解析的な光散乱**[@Miles]
- **ライトシャフト**
    - ポストプロセス[@Mitchell07]
    - エピポーラサンプリング[@Engelhardt10]

解析的なフォグ/光散乱
高速！
影付けされない
均質媒質のみ

スクリーン空間のライトシャフト
高品質
太陽/空がスクリーン上に見えている必要がある
均質媒質のみ
エピポーラサンプリングでできるが、これが窮地から救ってくれることはないだろう

# 過去の研究

- **Splatting**
    - ライトボリューム
        - [@Valliant14; @Glatzel14; @Hillaire]
    - エミッシブボリューム[@Lagarde13]
- **ボリューメトリックフォグ**[@Wronski14]
    - 太陽とローカルライト
    - 不均質媒質

splatting手法は、例えばlight volume splattingのようなものとして、この新しいコンソール世代と共に広く現れた。これは高品質な散乱となり得るが、通常は、シーンの関与媒質と一致しない。

より最近では、Wronskiは*Volumetric Fog*と呼ばれる、空間的に変化する関与媒質やローカルライトの散乱を可能にする技術をプレゼンテーションした。我々は、このプレゼンテーションで分かる通り、この時点で我々が行っていたことと一致[align with]したので、これと出会えたことが嬉しかった。しかし、この時点で本当に物理ベースであるようには見えず、我々の望んだいくつかの機能が欠けていた。

# 研究範囲[scope]と動機

- **ビジュアル上の品質を向上**させ、アートディレクションへのさらなる自由度をもたらす！
- **物理ベースのボリューメトリックレンダリング**
    - 意味のあるマテリアルパラメータ
    - ライティングからマテリアルを分離する
    - 一貫性のある結果
- **統一された**ボリューメトリック的相互作用

ボリューメトリックレンダリングをもたらすことはビジュアル上の複雑さの向上を可能にし、より多用なビジュアルやアートディレクションをもたらすだろう。

我々はそれが物理ベースであることを欲する。これは関与媒質のマテリアルが光源から分離されることを意味する(例えば、ライトエンティティ上では色が散乱しない)。媒質のパラメータは意味のあるパラメータセットでもある。これにより、我々はより制御し易く理解し易い、より一貫性のある結果を得るはずである。

また、Frostbiteではボリューメトリックと相互作用するエンティティがいくつか存在するためでもある(フォグ、パーティクル、不透明および透明な表面、など)。我々は、X種の相互作用に対してXつの手法を持たないように、それを扱う方法を統一したいとも考えている。

# 結果

# 概要

- **ボリューメトリックレンダリング**
- ボリューメトリックシャドウ
- Frostbiteにおけるさらなるボリューメトリックレンダリング
- 終わりに

# ボリューメトリックレンダリング: 単一散乱[single scattering]

$$
L_i(x, \omega_i) = T_r(x, x_s) L_s(x_s, \omega_o) + \int_0^s T_r(x, x_t) \sigma_t(x) L_{scat}(x_t, \omega_i) dt
$$

$$
Tr(x, x_s) = \exp \left( -\int_0^s \sigma_t(x) dt \right)
$$

$$
L_{scat}(x_t, \omega_i) = \rho \sum_{l = 0}^{lights} f(v, l) Vis(x, l) L_i(x, l)
$$

$$
Vis(x, l) = shadowMap(x, l) * volumetricShadowMap(x, l)
$$

今現在、我々はボリューメトリックをレンダリングするときに自身を単一散乱に制約する。これでもきちんと理解するには相応の力が必要になる[This is already challenging to get right]。

light surfaceが表面と相互作用するとき、例えばBRDFを計算することによってカメラにバウンスする光の量を計算できる。だが、関与媒質の存在によって、事はより複雑になる。

- 光が媒質の中を伝わってゆくときに透過率を計算に入れなければならない
- その後、多数のサンプルを取ることによって視線[view ray]に沿って散乱光[scattered light]を積分する必要がある
- これらのサンプルごとに、視点への透過率を計算に入れる必要もある
- 各点での散乱光を積分する必要もある
- そして、位相関数、通常のシャドウマップ(不透明オブジェクト)、ボリューメトリックシャドウマップ(関与媒質とその他のボリューメトリックエンティティ)を計算に入れる必要もある

# 我々のアプローチ: クリップ空間のボリューム

- **錐台に並行**な3Dテクスチャ[@Wronski14]
    - ワールド空間における錐台ボクセル => *Froxel*
- 注意: Frostbiteは**タイルベースのディファード**ライティングである
    - カリングされたライトリストを持つ16x16タイル
- **ライトタイルにボリュームタイルを揃える**
    - タイルあたりのカリングされたライトリストを再利用する
    - ボリュームタイルはより小さくできる(8x8、4x4、など)
    - 解像度の整数の除算に対する*補正*に気を付ける
- **デフォルト**: 8x8のボリュームタイル、64の深度スライス

Wronskiにある通り、すべてのボリュームはクリップ空間に並行な3Dテクスチャである(そのようなボクセルはワールド空間における*Froxel*になる。Alex EvansとSony ATGのおかげ[credit]、*Learning from Failure: a Survey of Promising, Unconventional and Mostly Abandoned Renderers for ‘Dreams PS4’, a Geometrically Dense, Painterly UGC Game’, Advances in Real-Time Rendering course, SIGGRAPH 2015*を参照)。

このボリュームはスクリーンライトタイルに並行でもある。これは散乱光の計算を加速するためにフォワードライトタイルリストカリングの結果を再利用しているためである(Frostbiteはタイルベースのディファードライティングエンジンであることを思い出して欲しい)。

スクリーン空間におけるボリュームタイルは(16x16ピクセルである)ライトタイルより小さくできる。

デフォルトでは、我々は以下を用いる。

- 64の深度解像度
- 8x8のボリュームタイル
<!--  -->
- 720pは160x90x64を必要とする(RGBAF16テクスチャあたり約7MB)
- 1080pは240x135x64を必要とする(RGBAF16テクスチャあたり約15MB)

# 我々のアプローチ: データの流れ

|||||
|-|-|-|-|
|**入力データ**|関与媒質のエンティティ<br>↓|ライティングおよびシャドウイング情報<br>↓||
|**クリップ空間**ボリューム|1. マテリアル特性→|2. Froxel光散乱→|3. 最終統合|

これは我々のデータの流れの概要である。
我々は様々なパイプラインのステージでデータを格納するためにクリップ空間のボリュームを用いている。

我々は関与媒質のエンティティから最初にボクセル化されたマテリアル特性を持つ。

すると、シーンの光源とこのマテリアル特性ボリュームを用いて、froxelあたりの散乱光データを生成できる。このデータは品質を向上させるために時間的にアップサンプリングできる。最後に、我々はレンダリングのためのデータを準備する統合ステップを持つ。

# 我々のアプローチ: データの流れ

1. マテリアル特性

# 関与媒質のマテリアルの定義

- 理論に従う[@PBR]
    - **吸収** $\sigma_a [m^{-1}]$
    - **散乱** $\sigma_s [m^{-1}]$
    - **位相** $g$
    - **発光[emissive]** $\sigma_e [放射照度 \cdot m^{-1}]$
    - 消散 $\sigma_t = \sigma_s + \sigma_a$
    - アルベド $\rho = \sigma_s / \sigma_t$
- アーティストは{吸収、散乱}か{アルベド、消散}を制作できる
    - アーティストを訓練しよう！それらの意味する所を理解することが彼らにとって重要である！

関与媒質は物理ベースレンダリングにおける最新技術に従って定義される。

我々は以下の特性のリストを持つ。

- 吸収、ある経路長以上で媒質によって吸収される光の量を説明する
- 散乱、ある経路長以上で散乱する光の量を説明する
- 発光、放射する光をを説明する
- 単一ローブ位相関数、光がどれだけ粒子でバウンスするかを説明する(一様に、全貌散乱、など)。これはHenyey-Greensteinに基づく(そして、Schlick近似を用いることができる)。

すべての物理ベース要素にある通り、これらを理解すること、つまり、アーティストを教育するのに時間をかけることが彼らにとって非常に重要である。

# 関与媒質(PM)の特性のボクセル化

- PM源
    - 深度フォグ
    - 高さフォグ
    - ローカルフォグボリューム
        - 密度テクスチャあり/なし
- PMの特性を**Vバッファ**にボクセル化する
    - 散乱、発光、消散を追加する
    - 位相$g$を平均化る(複数ローブなし)
    - 波長に非依存な$\sigma_t$(今の所は)

|||||フォーマット|
|-|-|-|-|-|
|散乱R|散乱G|散乱B|消散|RGBA16F|
|発光R|発光G|発光B|位相(g)|RGBA16F|
: Vバッファ(Froxelあたりのデータ)

深度/高さフォグとローカルフォグボリュームはボクセル化できるエンティティである。ここではそのまま、または、密度テクスチャに従って変化する密度を持つローカルフォグボリュームを確認できる。

我々は、ボリューム(クリップ空間)である以外はスクリーンのGバッファに類似しているVバッファにこれらをボクセル化する。これらは線形であるので基本的にすべてのマテリアルパラメータを一緒に加算する。平均される位相関数を除いて。HG位相関数に従って今のところは単一ローブのみを考慮する。

我々はより安価なボリューム(マテリアル、ライティング、シャドウイング)を持つために波長に非依存な消散で行うことを意図的に選択した。しかし、これはいくつかの点で必要ならば拡張するのが非常に容易であるだろう。発光をサポートすることは、散乱のように光を放射するがローカルライトと一致しないローカルフォグボリュームを配置する[position]ためのアーティストに対する利点である。これは安価なアンビエントライティングで使える。

# 我々のアプローチ: データの流れ

2. Froxel光散乱

# Froxelの積分

- froxelあたり
    1. PM特性のデータをサンプルする
    2. 計算する
        1. 散乱光$L_{scat}(x_t, \omega_o)$
        2. 消散
- 散乱光:
    - froxelあたり1サンプル
    - すべての光源を積分する: 間接光＋太陽＋ローカルライト

|||フォーマット|
|-|-|-|
|カメラへの散乱光RGB|消散|RGBA16F|
: 散乱/透過率バッファ

froxelごとに、ひとつのスレッドは散乱光と消散の収集を担当する[be in charge of]だろう。

消散はそのマテリアルから単に[copy over]される。あなたはこれが最終ステージにおけるビジュアル上の品質のために重要である訳を後に理解するだろう(エネルギー保存される散乱に対して透過率ではなく消散を使うため)。消散は線形でもあり、そのため、非線形な透過率の値ではなくこれを時間的に積分するのがより良いだろう。

# Froxelの積分: 太陽/アンビエント/発光

- ローカルフォグボリュームでの間接光
    - FrostbiteのディフューズSHライトプロブに由来
        - ボリュームの中心にプロブが1つ
        - SHコサインローブのように位相関数に関して積分する[@Wronski14]
- 太陽光
    - カスケードされたシャドウマップをサンプルする

そして、散乱光を積分する。froxelあたり1サンプル。

まずWronskiと同じ方法でアンビエントを積分する。FrostbiteはディフューズSHライトプロブをサンプルすることが可能である。我々はローカルフォグボリュームあたりにこれらの中心に配置される1つを用いる。

我々はカスケードされたシャドウマップに従って太陽光を積分する。指数シャドウマップを用いることができるだろうが、テンポラルアップサンプリングが結果をソフトにするのに十分であるので、使わない。

ここで示されるローカルフォグの不均質な特徴に容易に気付くことができる。

# Froxelの積分: ローカルライト

- ローカルライト
    - tiled-lightingのコードを再利用する
    - カリング後のフォワードタイルライトリストを用いる
    - 散乱しない？ローカルライトを省略する
- シャドウ
    - 通常のシャドウマップ
    - **ボリューメトリックシャドウマップ**

我々はローカルライトも統合する。そして、我々は各タイル内で可視であるライトを計算に入れるためだけにタイルカリングの結果を再利用する。
良い最適化のひとつはマテリアル特性に従って散乱が起こり得ない場合にすべてを省略することである。

これらのライトのそれぞれもまた関連するシャドウマップをサンプルできる。通常のシャドウマップとボリューメトリックシャドウマップもサポートする(後述)。

# テンポラルボリューメトリック積分

- フレームあたり1つの散乱/消散サンプル
    - 非常に強烈な[strong]マテリアルでの**アンダーサンプリング**
    - カメラ動作中の**エイリアシング**
    - シャドウはこれをより悪くする

述べた通り、我々はfroxelあたり1つのサンプルを用いるのみである。

これは残念ながら、非常に薄い関与媒質に対して、および、ローカルライトの寄与を統合するとき、非常に強烈なエイリアシングをもたらし得る。

# テンポラルボリューメトリック積分

# テンポラルボリューメトリック積分

- 解法: テンポラル積分
    - **ジッタリングされるサンプル**(Halton)
        - 視線に沿ったすべてのサンプルに対する同じオフセット
        - **散乱およびマテリアル**のサンプルを同時にジッタリングする
    - 前の散乱/消散を**再投影**する
        - 現在のものを前のものと5%ブレンドする
        - 指数関数的な移動平均[exponential moving average] [@Karis14]
        - 錐台の外: 履歴を省略する

これらの問題を和らげるため、我々はフレームの結果を前のフレームのものと時間的に統合する(ご存知の通り、去年KarisがTAAで使ってもいる)。

これを達成するため、

- 我々は視線に沿って一様にフレームあたりのサンプルをジッタリングする
- マテリアルおよび散乱光のサンプルは(計算されるマテリアルおよび散乱光をソフトにするために)同じオフセットを用いてジッタリングされる
- 指数関数的な移動平均に従って各フレームを統合する
- 履歴サンプルが利用できない(前の錐台の外)場合には前の結果を無視する

# テンポラルボリューメトリック積分あり

# テンポラルボリューメトリック積分あり

# テンポラルボリューメトリック積分

- 残っている**問題**
    - **マテリアルのアニメーション**は跡を残す[leaves trails]
        - 速度を用いて再投影する？
        - 複数のボリュームの交差では？
        - アニメーションするボリューム(たとえば、流体シミュレーション)では？
    - **ライトの移動**は跡を残す
        - 近傍クランプ[neighbour clamping]を使う？[@Karis14]
    - チャレンジングなR&D領域！


# 我々のアプローチ: データの流れ

3. 最終統合

# 最終的なPMボリューム

- 視線に沿ってfroxelの{散乱、消散}を統合する
    - 位置$x_s$でのfroxelごとの{$L_i(x, \omega_o)$、$T_r(x, x_s)$}を解く

我々は基本的に透過率に従って近から遠の散乱を累積する。これは視線に沿ってfroxelごとに積分された散乱光と透過率を解くだろう。

ここに示されるコードサンプルを用いることができるだろう。つまり、accumulate scattering and then transmittance for the next froxel, and this slice by slice.しかし、これは完全に誤りである。確かに、accumScatteringTransmittance.aの値(透過率)への依存性がある。我々は散乱の透過率をはじめに更新すべきだろうか？

# 最終的なPMボリューム

- エネルギー保存的でない積分
    - 単一散乱光は$S = L_{scat}(x_t, \omega_o)$をサンプルする。OK
    - 単一透過率は$T_r(x, x_s)$をサンプルする。NOT OK
- -> froxelの深度$D$上で透過率に関するライティングを積分する
    - $\int_0^D e^{-\sigma_t x} \times S dx = \frac{S - S \times e^{\sigma_t D}}{\sigma_t}$

ここでは散乱の特性を増加させたときの複数のボリュームを確認できる。散乱の後に透過を統合することがエネルギー保存的でないことがわかりやすい。
我々は操作の順序を逆にできるだろう。…。

これを改善する方法とは？1つのライトサンプルおよび1つ消散サンプルを持つことが分かっている。

ライトサンプルを維持できる。計算するのが高価であり、深度スライス内で視線に沿って一定であると仮定するのに十分である。

ただし、単一の透過率は完全に誤りである。透過率は実際に深度レイヤの近くの界面で0に、幅$d$の深度スライスの遠くの界面で$\exp(-\mu_t d)$になるはずである。

これを解くためにすることはスライス内で視線範囲上の各点における透過率に従って解析的に散乱光を積分することである。これは1つの消散サンプルに従って定められた範囲上で一定の散乱光の解析的積分がこの方程式を減らせることを容易に求めることができる。
これを用いて、最終的に散乱および単一の消散サンプルに関するこれに対する一貫性のあるライティング結果を得る。

# 最終的なPMボリューム

- ボリューメトリックシャドウと共に改善する

修正した積分なし: ライトリーク
改善した積分あり

# 最終的なPMボリューム シーンレンダリング

- 事前乗算済み色/アルファと似た{$L_i(x, \omega_o)$、$T_r(x, x_s)$}
- ピクセルごとに不透明な表面に適用される
- 頂点ごとに透明な表面で計算され、ピクセルごとに適用される

ひとたび最終的に統合されたバッファを持てば、我々は空レンダリングパス中にシーンのすべてに適用できる。カメラに届く散乱光や透過率を含むため、すべてに事前計算済み色/アルファのように適用するのが容易である。

効率性のため、透明物には頂点ごとに適用されるが、より良い品質のためにピクセルごとに切り替えることを考えている。

# 結果の評価

- Mitsubaによるリファレンスと結果を比較する
    - 物理ベースのパストレーサー
    - 同じ条件: 単一散乱のみ、露出、ほか
- シーン1:

# 結果の評価 --- シーン1

# 結果の評価 --- シーン2

# パフォーマンス

- 太陽＋シャドウカスケード
- 14つのポイントライト
    - 2つは通常およびボリューメトリックシャドウ付き
- 6つのローカルライトボリューム
    - すべて密度テクスチャ付き

# パフォーマンス: PS4, 900p

# 概要

- ボリューメトリックレンダリング
- **ボリューメトリックシャドウ**
- Frostbiteにおけるさらなるボリューメトリックレンダリング
- 終わりに

# ボリューメトリックシャドウマップ

TODO
