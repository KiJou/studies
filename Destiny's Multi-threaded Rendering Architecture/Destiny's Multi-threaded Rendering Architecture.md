---
title: Destiny's Multi-threaded Rendering Architecture [@Tatarchuk2015]
numberSections: true
---
# Destiny's Multi-threaded Rendering Architecture

## このトークが扱わないこと

- Destinyのグラフィクスアルゴリズム
- Destinyのシェーダテクニック
- これらについてもっと学びたいなら、
    - 我々のテクニックのいくつかはSIGGRAPH 2009〜2014のトークやI3D 2015のキーノートを参照
        - **http://advances.realtimerendering.com**


<aside class="notes">
本日のトークは[TODO]
</asides>

## 前提

- タスクベースの並列化、ジョブマネージャの設計、同期プリミティブの基本に精通していること
- 役に立つDestinyエンジン設計は以下でその詳細を述べる
    - ***Multithreading the Entire Destiny Engine*** by Barry Genova (3月5日火曜日 午後4時〜午後5時)

<aside class="notes">
このトークでは、[TODO]
</asides>

## 本日のオススメ

- Destinyのコアレンダラアーキテクチャ
- GPUデータフローへのゲームシミュレーション
- ジョブ化と負荷分散の検討事項
- レイテンシリダクションテクニック
    - 入力およびレンダリングレイテンシリダクション
    - GPUを完全に飽和させ続ける
- 複雑さのカプセル化

## まえがき

- 粒度の粗い並列化
- Destinyのレンダラの目標
- シミュレーションとレンダリングの分離
- コアワークロードのジョブ化
- データ駆動レンダリングサブミッション
- 高度な最適化
- おわりに

<aside class="notes">
これは[TODO]
</asides>

# 粒度の粗い並列化

## A 10,000' View of a Frame in a Game

<aside class="notes">
ゲームの1フレームで起こっていることを高レベルで見ていこう。
</asides>

## A 10,000' View of a Frame in a Game

- ゲームオブジェクトをシミュレートする

<aside class="notes">
すべてのgame tickごとに、ゲームシミュレーションを走らせることから始める。これは物理エンジン、AI、アニメーション、ゲームプレイに影響を与えるいずれかのコードをを走らせる所である。
</asides>

## A 10,000' View of a Frame in a Game

- ゲームオブジェクトをシミュレートする
- レンダリングするものを決定する

<aside class="notes">
そして、最新のシミュレーションデータを使って、見えているであろう要素を決定する。
</asides>

## A 10,000' View of a Frame in a Game

- ゲームオブジェクトをシミュレートする
- レンダリングするものを決定する
- GPUコマンドを生成する

<aside class="notes">
そして、これらの要素をGPUコマンドのセットに変換する。我々はこの操作を"CPUサブミット"と呼んでいる。この結果はGPUに流し込む[flush]GPUコマンドバッファである。
</asides>

## A 10,000' View of a Frame in a Game

- ゲームオブジェクトをシミュレートする
- レンダリングするものを決定する
- GPUコマンドを生成する
- GPUワークを処理する
- 表示する

<aside class="notes">
[TODO]
</asides>

## A 10,000' View of a Frame in a Game

- ゲームオブジェクトをシミュレートする
- レンダリングするものを決定する
- GPUコマンドを生成する
- GPUワークを処理する
- 表示する

このパイプラインはsystem-on-a-thread設計にうまく対応する

## System-on-A-Thread設計

<aside class="notes">
Halo: Reachでは、スレッドのいくつかに主要なゲーム関数を対応させた。例えば、レンダリング、オーディオ、シミュレーションには単独のスレッドを対応させた。ここでは、各スレッドはハードウェアスレッドにも対応させた。
</asides>

##

<aside class="notes">
実行を見るための異なる方法として、frame tick diagramがある。
ここには、N番目のGame Tickでは、シミュレーションはフレームNのgame tickを計算しつつ、前のフレームをレンダリングしていることが示されている。
</asides>

##

シミュレーションが完了したら、次のgametick中にこのフレームをレンダリングし始めるようにgamestateをコピーする。
Halo: Reachでは、すべての出力システムの処理はシミュレーションスレッドが現在のgame tickのワークを終えて、完全なgamestateをコピーした後にのみ始めていた。

##

<aside class="notes">
完全なgamestateのコピーを用いて各レンダリングループの初めにシリアライズされた可視性の計算をを走らせた。可視性が行われるまで、ドローコールを生成し始めることはできない。
</asides>

## System-on-A-Threadの負荷分散

<aside class="notes">
静的なスレッドごとの負荷分散は準最適なワークロード分布を意味した。
シミュレーションやレンダリングループ(最大のワークロード)ではそのスレッドは高い使用率を示す傾向にあったが、他のスレッドはたくさんのアイドル時間が確認された。
</asides>

## System-on-A-Threadの観察結果: 悪い点

- 世代やプラットフォームをまたいでの採用は難しい
    - ヘテロジニアスなプラットフォームでスケールしない

<aside class="notes">
[TODO]
</asides>

## System-on-A-Threadの観察結果: 悪い点

- 世代やプラットフォームをまたいでの採用は難しい
    - ヘテロジニアスなプラットフォームでスケールしない
- 同期必須の完全なgamestateのダブルバッファ

<aside class="notes">
[TODO]
</asides>

## System-on-A-Threadの観察結果: 悪い点

- 世代やプラットフォームをまたいでの採用は難しい
    - ヘテロジニアスなプラットフォームでスケールしない
- 同期必須の完全なgamestateのダブルバッファ
- シリアライズされた先払いの重い可視性コスト
    - GPU idle bubblesの可能性

<aside class="notes">
[TODO]
</asides>

## System-on-A-Threadの観察結果: 良い点

- 便利なデータアクセス
- 拡張可能
- 簡単

<aside class="notes">
[TODO]
</asides>


## System-on-A-Threadの観察結果: 良い点

- 便利なデータアクセス
- 拡張可能
- 簡単
- 単純なスレッディングモデル

<aside class="notes">
[TODO]
</asides>


## System-on-A-Threadの観察結果: 良い点

- 便利なデータアクセス
- 拡張可能
- 簡単
- 単純なスレッディングモデル
- シミュレーションとレンダリングのパイプライン化された並行実行

<aside class="notes">
[TODO]
</asides>

## まえがき

- 粒度の粗い並列化
- **Destinyのレンダラの目標**
- シミュレーションとレンダリングの分離
- コアワークロードのジョブ化
- データ駆動レンダリングサブミッション
- 高度な最適化
- おわりに

# Destinyレンダラの目標

<aside class="notes">
[TODO]
</asides>

## Destinyレンダラの目標

- 素晴らしいビジュアルと即応性の高いゲームプレイを伴うゲームを出荷する
    - 複雑で、生き生きとした、美しい世界
    - 多様な環境を伴う多数の行き先
    - 高品質なライティング、動的な時刻変化、リアルタイムシャドウ、天候要素、高解像度レンダリング
    - 多くのグラフィクス特徴

<aside class="notes">
[TODO]
</asides>

## Destinyレンダラの目標

- 素晴らしいビジュアルと即応性の高いゲームプレイを伴うゲームを出荷する
    - 証明されたレンダラアーキテクチャ
    - 4つのコンソールプラットフォームにわたる1.7百万のプレイヤー

<aside class="notes">
[TODO]
</asides>

## Destinyレンダラの目標

- 素晴らしいビジュアルと即応性の高いゲームプレイを伴うゲームを出荷する
- スケーラブルにしておこう
    - 世代間やプラットフォーム間
    - すべてのプラットフォーム上で堅実なパフォーマンス

<aside class="notes">
[TODO]
</asides>

## クロスプラットフォームとクロスジェネレーション

- 前世代
    - PlayStation 3
        - 2つのハードウェアPPUスレッド
        - 約6つのSPUスレッド
    - Xbox 360
        - 6つのハードウェアCPUスレッド
        - 3つの3.2GHzのIBM PowerPCプロセッサ
- 現世代
    - PlayStation 4
        - 4つのx64コアを持つ2つのクラスタ
        - コアあたり1つのハードウェアスレッド
    - Xbox One
        - 4つのx64コアを持つ2つのクラスタ
        - コアあたり1つのハードウェアスレッド

##

## サンドボックス == 負荷が変化しやすい

## サンドボックス == 負荷が変化しやすい

## サンドボックス == 負荷が変化しやすい

## 効率的に保つ

- 最大CPUおよびGPU占有率
    - これらを完全に専有し続ける
    - GPUアイドルを避ける
- 動的な負荷分散と賢いジョブバッチ処理
- レイテンシを低く保つ

## Destinyレンダラの目標

- 素晴らしいビジュアルと即応性の高いゲームプレイを伴うゲームを出荷する
- スケーラブルに保つ
- 効率的に保つ
- 単純に保つ
    - "心配するのをやめてマルチスレッディングを愛することを学んだ方法"
    - 10分でわかるゼロからジョブをレンダリングするまで
    - 新機能 -> 既存ジョブへの変更は最小限に

<aside class="notes">
[TODO]
</asides>

## Destinyレンダラの目標

- 素晴らしいビジュアルと即応性の高いゲームプレイを伴うゲームを出荷する
- スケーラブルに保つ
- 効率的に保つ
- 単純に保つ
- レンダリングからシミュレーションを分離する

## Destinyレンダラの目標

- 素晴らしいビジュアルと即応性の高いゲームプレイを伴うゲームを出荷する
- スケーラブルに保つ
- 効率的に保つ
- 単純に保つ
- レンダリングからシミュレーションを分離する
- 完全にデータ駆動なレンダリングパイプライン

##

##

##

##

##

##

##

## 実際には…

## 実際には…

## 実際には…

## 実際には…

## 実際には…

## 実際には…

##

## まえがき

- 粒度の粗い並列化
- Destinyのレンダラの目標
- **シミュレーションとレンダリングの分離**
- コアワークロードのジョブ化
- データ駆動レンダリングサブミッション
- 高度な最適化
- おわりに

# レンダリングからのゲームステートのトラバーサルの分離

## 意識的な切り離し

- 可視性とゲームオブジェクトを分離する
    - ゲームオブジェクトに依存しない可視性のトラバーサル
- 可視性の結果からレンダリング負荷を操る
    - レンダリングとゲームオブジェクトを分離する

## 静的データをしまう

- 単純な所見:
    - レンダリングデータ != ゲームオブジェクトデータ
    - レンダリングデータの大半はオブジェクトの寿命で静的である
- レンダラで不変なレンダリングデータをキャッシュする
    - 登録時に
    - 登録後は読み込みのみ

## Carry On Only!

- フレーム毎の*一時的*なレンダリング固有データを抽出する
    - 静的データはすでにキャッシュされている
    - 動的データのみを抽出する --- 各フレームごと

## Carry On Only!

- フレーム毎の*一時的*なレンダリング固有データを抽出する
    - 静的データはすでにキャッシュされている
    - 動的データのみを抽出する --- 各フレームごと
- 可視性の結果は抽出すべきゲームステートを定義する
    - *可視要素に対するデータのみを抽出する*

##

##

## オブジェクトとレンダリングの分離

- 各システムで表現を分ける
    - オブジェクトシステム(ゲーム側)
    - レンダリング(レンダリングオブジェクト)
    - 可視性(可視性オブジェクト)
- レイヤ間で通線するためのインターフェイスを提供する
    - 厳密なアクセス規則
    - 特定のゲームフェイズの間のみ

## データフロー

## データフロー

## データフロー

## データフロー

## フレームパケット

- 動的なフレーム毎のレンダリングデータのストレージ
    - すべての特徴的なレンダラの動的データはここに格納される
    - 完全にステートレス、毎フレーム後に投げ捨てられる
- 小さな総フットプリント
    - PS3とXbox360でフレームあたり1MB
        - ゲームステート全体の9%

## まえがき

- 粒度の粗い並列化
- Destinyのレンダラの目標
- シミュレーションとレンダリングの分離
- **コアワークロードのジョブ化**
- データ駆動レンダリングサブミッション
- 高度な最適化
- おわりに

## ビューの処理

- ビュー == {錐台|カメラ}

## ビューの処理

- ビュー == {錐台|カメラ}
    - 例:
        - プレイヤービュー　シャドウビュー　頭上マップビュー

## ビューの処理

- ビュー == {錐台|カメラ}
    - 例: プレイヤー、シャドウ、頭上ビュー、など
- ビュー == レンダリングジョブチェイン単位
    - 可視性..抽出..準備..| サブミット

## ビュージョブチェイン

## ビュージョブチェイン

- コアシステムジョブ
- 常に実行する
    - フレームの内容に依存しない

## ビュージョブチェイン

- データ駆動のビュージョブチェイン
- 動的に生成される
- 与えられたフレームでの内容に基づく

## ビュージョブチェイン

## ビュージョブチェイン

- ビューを決定する
    - プレイヤービュー？
    - シャドウビュー？
    - など

## ビュージョブチェイン

- ビューを決定する
- フレームとビューパケットを予約する
- 重い割当やヒープ等なし

## 抽出

## 抽出

- ビューごとに可視レンダリングオブジェクトのリストを計算する
    - 可視性リングバッファに格納する(一時的)

## 抽出

- ビューチェインジョブをレンダノード上で処理する
    - レンダノードは効率的で、超コンパクトで、キャッシュコヒーレントな表現
- レンダノードのコヒーレントな配列にデータを送る

## 抽出

- レンダオブジェクトタイプで可視リストをソートする
- のちの実行のコヒーレンシーのため
- ビューパケットにレンダノードを割り当てる

## 抽出

- レンダビューノードはビュー依存のデータを格納する
- 独自のフレームパケットデータを割り当てられる
    - レンダオブジェクトタイプに基づいて

## 抽出

- フレームノードを持つビューの間でデータを共有する
    - フレームパケット内でのデータ共有
    - 冗長なデータを回避する

## 抽出

## 抽出

## 抽出

## 抽出

## 抽出

## 抽出

## 抽出

##

## ちゅうしゅ

## 抽出

##

## ウィンドウとレイテンシの抽出

TODO
