---
title: Moving Frostbite to Physically Based Rendering 3.0 [@Lagarde2014]
codeBlockCaptions: true
figureTemplate: 図 \[i\] \[titleDelim\] \[t\]
tableTemplate: 表 \[i\] \[titleDelim\] \[t\]
listingTemplate: リスト \[i\] \[titleDelim\] \[t\]
bibliography: bibliography.bib
---
# まえがき(Introduction) {id="sec:1"}

# リファレンス(Reference) {id="sec:2"}

# マテリアル(Material) {id="sec:3"}

## マテリアルモデル(Material models) {id="sec:3.1"}

### 外観(Appearance)

### マテリアルモデル(Material models)

### エネルギー保存則(Energy conservation)

### 形状の特徴(Shape characteristics)

### Frostbiteの標準モデル(*Frostbite* standard model)

## マテリアルシステム(Material system) {id="sec:3.2"}

### マテリアル(Material) {id="sec:3.2.1"}

### レンダループ(Render loop)

## PBRとデカール(PBR and decals) {id="sec:3.3"}

# ライティング(Lighting) {id="sec:4"}

## 一般(General) {id="sec:4.1"}

## 解析的ライトパラメータ(Analytical light parameters) {id="sec:4.2"}

## ライト単位(Light unit) {id="sec:4.3"}

## パンクチュアルライト(Punctual lights) {id="sec:4.4"}

## 測光ライト(Photometric lights) {id="sec:4.5"}

## 太陽(Sun) {id="sec:4.6"}

## エリアライト(Area lights) {id="sec:4.7"}

### エリアライトの単位(Area light unit) {id="sec:4.7.1"}

### ディフューズエリアライト(Diffuse area lights) {id="sec:4.7.2"}

#### 一般(General) {id="sec:4.7.2.1"}

#### 球型エリアライト(Sphere area lights) {id="sec:4.7.2.2"}

#### ディスク型エリアライト(Disk area lights)

#### 球型とディスク型のエリアライトのマージ(Sphere and disk area light merging)

#### 矩形型エリアライト(Rectangular area lights)

#### チューブ型エリアライト(Tube area lights)

### 5倍ルール(Five times rule) {id="sec:4.7.3"}

### Disneyのディフューズによるディフューズエリアライト(Diffuse area light with Disney's diffuse) {id="sec:4.7.4"}

以前の導出のすべてはランバートBRDFに対して行われていた。しかし、マテリアルモデルの節で言及されるように、我々の標準マテリアルはDisneyのディフューズ項を用いる。これは解析的手法に対応しておらず、構造化されたサンプリングのアプローチで各サンプルのモデルに対する評価を呼び出すのが高価になる可能性があった。これを扱うために、我々はランバートエリアライトの照度へ単一のライト方向に対するDisneyのディフューズ評価を適用することとした。

$$
L_{\text{out}} = f_d(\boldsymbol{v}, \boldsymbol{l}) E(n)
$$ {#fig:45}

$\boldsymbol{l}$に対する最も単純な選択はライト位置を使うことである。いくつかのライトタイプでは、この近似は十分に良好である([@fig:45]参照)。しかし、より良い選択はDrobotのアプローチのように最も代表的な点の方向を取ることである([@fig:46]参照)。Frostbiteでは、パフォーマンス的な理由によりDisneyのディフューズ項に対して入力としてライト位置を使う。

![球は左から右にラフネスが増加する。左:Disneyのディフューズ項への入力としてライト位置を与えるディスク型エリアライティング。右:リファレンス。結果は近い。](assets/Figure45.png){#fig:45}

![球は左から右にラフネスが増加する。左上:Disneyのディフューズ項への入力としてライト位置を与える矩形型エリアライティング。右上:入力としてMRP方向を使う場合。下:リファレンス。MRP近似がよりリファレンスに近い。](assets/Figure46.png){#fig:46}

BRDFローブの支配的な方向を計算に入れることでこの近似を改善することが可能である。この支配的な方向の処理は[@sec:4.9.3]にてその詳細を述べる。我々は表面の法線のシフトによりこれを取り戻す([@lst:15]参照)。しかし、その差異はとても微妙であるので、シェーダコストを減らすためにこのシフトを適用しないことにした。

~~~ {.c .numberLines id="lst:15"}
float3 getDiffuseDominantDir(float3 N, float NdotV, float roughness) {
    float a = 1.02341f * roughness - 1.51174f;
    float b = -0.511705f * roughness + 0.755868f;
    float lerpFactor = saturate((NdotV * a + b) * roughness);

    return normalize(lerp(N, V, lerpFactor));
~~~
: エリアライトを評価するとき、Disneyのディフューズ項のローブの支配的な方向を計算するための関数。

### スペキュラエリアライト(Specular area lights)

スペキュラエリアライトはリアルタイム制約下では本当に複雑な問題である。BRDFの入力(視線ベクトル、f0、ラフネス)の数と矩形(幅、高さ、向き、定数でない強度)のような標準ライトの形状のひとつはライトプロブと同様に事前計算アプローチを困難にする。文献で使える現在の解決法はGGXスペキュラモデルのリファレンスとの比較に耐えうるものではない。@Drobot2014b のMRPアプローチはPhongモデルに限りうまく行き、@Karis2013 の反射レイからの最短距離はうまいエネルギー保存の項が失われていおり、グレージング角でうまく動作しない。他の数学ヘビーな解決法と同じくエリアライトのためのフィルタされた重点サンプリング[@Colbert2010]に触発された他の解決法を試したが、シェーダコストは法外である。我々はground truthと一致させず、単純に最適なビジュアルを持つより安価な解決法を取ることを決めた。我々のライトはKarisのアプローチを用いているが、ディスクと矩形については、うまい粗いエネルギー保存の項をいずれも見つけられなかった([@fig:47]参照)。

![スペキュラのみのライティングを持つシーン。左:スペキュラにKarisのアプローチを用いたさまざまなエリアライトタイプ。右:リファレンス。](assets/Figure47.png){#fig:47}

粗い表面に対するスペキュラエリアライトの積分を多少改善するため、我々はBRDFローブの支配的な方向を計算に入れた。支配的な方向の処理は[@sec:4.9.3]でその詳細を述べている。鏡面方向のシフトによりそれを取り戻す([@lst:16])。エリアライトのバージョンはライトプロブで使われるそれよりも単純である。我々の場合ではそれで十分である事が判明した。[@fig:48]には鏡面と支配的な方向を使った比較を示す。これは相関ありと相関なしの両方のSmishのG項でうまく働く。

~~~ {.c .numberLines id="lst:16"}
float3 getSpecularDominantDirArea(float3 N, float3 R, float NdotV, float roughness) {
    // 単純な線形近似
    float lerpFactor = (1 - roughness);

    return normalize(lerp(N, R, lerpFactor));
}
~~~
: エリアライトを評価するとき、マイクロファセットGGXベースのスペキュラ項に対するローブの支配的な方向を計算する関数。

![左:ミラー方向の積分における様々なサイズの球型エリアライティングの近似。右:支配的方向の場合。大きい球と粗い表面で改善が見られる。](assets/Figure48.png){#fig:48}

**備考**: ライトと表面の特性に依存すると、ディフューズエリアリアライトで計算される照度はスペキュラエリアライトには適切でないことがある(Lambertのコサインが常にディフューズとスペキュラの両方の項に適用されるパンクチュアルライトの場合とは異なる)。確かに、ライトの形状とBRDFの重点コーンの交差に対する立体角は異なる可能性があり、Lambertのコサインに関する積分結果が異なるはずである。

## エミッシブな表面(Emissive surfaces) {id="sec:4.8"}

現実世界では、エミッシブな表面はエリアライトと同等である。これらは光源のように近くの表面を照らす光を放射する。ゲームでは、パフォーマンス制約により伝統的なライトとして表面のエミッシブな部分を扱うことはできない。Frostbite内では、1)元となる表面に表示されるエミッシブライト、2)光を放つエリアライト、の2つの区別を設けた。エミッシブライトは他のライトと同様にエミッシブ色とエミッシブ強度値を与えることによりシェーダ内でピクセル精度で生成される。強度は輝度($\frac{cd}{m^2}$)かEV値で渡される。これらのエミッシブライトはライティングを生み出さず、見えている色のみを生み出す。しかし、その強度がカメラセンサーを飽和させたとき、これらはブルームを生み出す([@sec:5.1]参照)。我々は3つのエミッシブな表面のケースを大まかに示すことができる([@fig:49]を参照)。

- A. エミッシブマテリアルが非エミッシブマテリアルの下にある。
- B. エミッシブマテリアルが非エミッシブマテリアルの上にある。
- C. マテリアル全体がエミッシブである。

![エミッシブマテリアルの3つのケース。A)エミッシブマテリアルが非エミッシブマテリアルの下にある。B)エミッシブマテリアルが非エミッシブマテリアルの上にある。C)マテリアル全体がエミッシブである。](assets/Figure49.png){#fig:49}

ケースBとCは、Bでエミッシブ層の下のマテリアルが覗けること以外、非常に近い。Frostbiteでは、暗黙的にケースCをサポートするケースBのみを扱う。エミッシブな表面を効率的にレンダリングするのは簡単ではない。ディファードなやり方でエミッシブな不透明オブジェクトを適切にレンダリングして、(Gバッファ生成パスの後にレンダリングされる)ディファードデカールとの互換性を保つためには、エミッシブ情報をGバッファに格納する必要がある。これはコストの高い追加のバッファを必要とする。Frostbiteでは様々なパスを持つ。

|||
|-|-|
|透明オブジェクト|エミッシブは表面のレンダリング中に適用される|
|フォワード不透明オブジェクト|エミッシブは表面のレンダリング中に適用される|
|完全なエミッシブを持つディファード不透明オブジェクト|エミッシブは表面の追加のレンダリングパスで適用される、つまり、表面は2回レンダリングされる|
|安価なエミッシブを持つディファード不透明オブジェクト|エミッシブはラジオシティバッファに格納され、間接ライティングとして同時に適用される|

間接ディフューズライティングはGバッファ生成時のディフューズアルベドで構成されていないが、これは後にディフューズアルベドを調整することをデカールで可能にするためである。アーティストがパフォーマンスを正確性とトレードしたいときに備えて、エミッシブ値をラジオシティバッファに格納できるようにしてある。このアプローチで問題になるのはエミッシブ色がディフューズアルベドと結合してしまうことである。ラジオシティバッファが適用されるとき、ディフューズアルベドをラジオシティバッファに乗算する。エミッシブでも同様である。ディフューズアルベドを調整するデカールはこの場合エミッシブも調整する。これが"安価"なエミッシブと呼ぶ所以である([@lst:17])。もうひとつの制約はこのテクニックがディフューズを持たないような金属質のオブジェクトで動作しないことである。

~~~ {.c .numberLines id="lst:17"}
// Gバッファ生成中に
float3 radiosity = ...;
// エミッシブをラジオシティにパックする(同じ単位(輝度)で)
radiosity += emissive * emissiveIntensity;
gBufferRadiosity = packLightingRGBA(gbufferRadiosity);

// ラジオシティアプリケーション中に
float3 unpackedRadiosity = unpackLightingRGBA(gbufferRadiosity);
indirectDiffuse = unpackedRadiosity * data.diffuseAlbedo;
~~~
: ディファードのケースで管理される安価なエミッシブ。

![フォワード(上)とディファード(下)でレンダリングされたエミッシブな表面の例。すべての球はエミッシブなオブジェクトであり、球型エリアライトがエミッシブ球として同じ位置に追加された。](assets/Figure50.png){#fig:50}

**備考**: エリアライトの場所に正確な強度を持つエミッシブ球を自動的に生成するツールを開発した。例を[@fig:51]に示す。これは実際に説得力のあるビジュアルシーンを生み出し、アーティストがこれらのライトをデバッグするのに役立つ。

![エミッシブな表面としてライトを可視化するデバッグモード。](assets/Figure51.png){#fig:51}

## 画像ベースライト(Image based lights) {id="sec:4.9"}

画像ベースライト(IBL)は点を取り囲む入射するライティングを表すことができる。この取り囲むライティングはオブジェクトをその環境に"フィット"させるために重要である。アーティストから"反射"と呼ばれることが時折あるため、この入射ライティングはBRDFの式$f$、つまり、標準マテリアルに対するスペキュラ$f_r$の部分だけでなく$f_d$の部分も含めて、すべての部分に矛盾なく適用される必要がある。レイヤードマテリアルのようなさらに進化したマテリアルでは、すべてのレイヤがこのライティングによって影響を受ける必要がある。シェーダで反射テクスチャを直接追加することでこのライティングを"見せかけること(faking)"はライティングとマテリアルの情報の間の*鍵分離(key separation)*を破壊してしまい、異なる環境でアセットの再利用を難しくしている。IBLの$L$とBRDFの$f$との間の相互作用の計算は以下の積分を評価する必要があるコストの高い処理である。

$$
L(\boldsymbol{v}) = \int_{\Omega} f(\boldsymbol{l}, \boldsymbol{v}, \Theta) L(\boldsymbol{l}) d\boldsymbol{l}
$$ {#eq:46}

視線方向$\boldsymbol{v}$、マテリアルモデル$f$、パラメータ$\Theta$(Fresnel、ラフネス、アルベドなど)を持つ。連続的にオブジェクトを環境に合わせ、未だに良い反射の近似を提供するため、すべての状況で反射を提供できるようにする必要がある。このため、@Drobot2013 に触発された4つのタイプのIBLに頼る。こららのタイプのそれぞれは入射ライティングの特定のタイプか範囲を表現することを可能にする。

- **ディスタントライトプロブ**: 取り囲む遠く離れたライティングをキャプチャする。これはいかなる視差(parallax)を含まない(空、遠方の建物、背景の水滴など)。これは最も正確でない反射タイプであるが、いつでも利用できる。
- **ローカルライトプロブ**: ビューの単一の点からあるエリアに含まれるすべてのオブジェクトをキャプチャする(キューブマップ)。これらのキャプチャは、取り囲むジオメトリを一致させるためにアーティストにより慎重に調整された、単純なプロキシジオメトリに再投影される(例えば、球か箱)。この反射タイプはディスタントライトプロブより正確であるが、オブジェクトライティングと視差は完璧にキャプチャされない。
- **スクリーンスペース反射**: 深度バッファに対するレイマーチングによりライトバッファに基づく反射をキャプチャする。これは小から中の範囲の反射を捕らえ、良好なcontact hardening[^contact_hardening]反射を保証する。これは最も正確な反射源のひとつである。
- **平面反射(Planar Reflections)**: エンジンによる自動かアーティストによる手動いずれかでセットアップされた平面に反射したシーンをレンダリングすることで反射をキャプチャする。この反射タイプは反射が道路、建物、水面といったほぼ平坦な表面でうまく働く平面に横たわると仮定する。

[^contact_hardening]: 投影先への距離が近いほど像が正確になるような特徴。

**静的vs動的**: ディスタントライトプロブとローカルライトプロブは、ある瞬間における周辺のライティングをキャプチャした、通常"静的"なライティング情報を含む。これらのコンテンツは、要件や割り当てられたパフォーマンス予算に従い、要求に応じて又は毎フレームにリフレッシュさせることができる。SSRや平面反射は、それらの視点に依存するという特徴により毎フレーム更新されるため、"動的"なライティング情報を含む。これらの計算はそのコストを減らすためにいくつかのフレームに分散させることもできる。

簡単にSSRや平面反射を述べるが、この節は主にローカルライトプロブとディスタントライトプロブに焦点を当てる。まず、ライトプロブの取得とそのライティング単位を説明する。そして、それらのフィルタリング、評価、さまざまなIBLの合成を説明する。

### ライトプロブの取得と単位(Light probes acquisition and unit) {id="sec:4.9.1"}

Frostbiteでは、IBLは画像データに関連する定義によるものである。それらすべては、ライティングパイプラインの出力であるので、輝度単位を使う。

#### ディスタントライトプロブ(Distant light probe)

ディスタントライトプロブはキューブマップとして表される周囲の環境をキャプチャする。アーティストにはディスタントライトプロブを取得するための2つの方法がある。

- 任意に背景に合成される物理ベーススカイを通してライティングを取得する。
- 現実世界のカメラから取得したハイダイナミックレンジ画像(HDRI)を使う。

Frostbiteはディスタントライトプロブをキャプチャするために使われることがある物理ベーススカイを使う。ディスタントライトプロブは状況の変化(時刻サイクル、天候の変化など)に対処するときに必要に応じてリフレッシュさせることができる。スカイライティングはその他のライトのように輝度に変換される。キャプチャする時は、ライティングパイプラインのみを考慮する。我々はいかなる色管理処理(トーンマッピング、カラーグレーディング…)を含むポストプロセスを取り除き、HDRテクスチャフォーマットRGBA16Fに結果の輝度を格納する。

現実世界のディスタントライトプロブをうまく使うには何が取得されていたかを理解する必要がある。取得したHDR画像は静的な特徴によりインゲームで最終的なライティングにまれに使われる。これらはむしろ、アセットを設計したり、マテリアル特性が自然なライティングで正しく反応することを検証したりするために、入射ライティングとして使われる。しかし、取得したHDRIをインゲームライティングと混ぜ合わせる必要があるとき、注意して行う必要がある。HDRIのテクセルに格納してあるものが明確ではない。カメラが輝度値を出力すると考えられるかもしれないが、カメラの応答とポストプロセスステップは最高と最低の輝度値をカットする。出力されたピクセルはもはや輝度値を表さしておらず、むしろそれはもとのシーン輝度に関係するデバイス依存の値である。輝度からピクセル値への変換を詳しく述べる実際のプロセスは[@sec:5.1]にその詳細を述べる。

**HDRI生成**: LDRカメラでは、続くキャプチャの複雑なプロセスと再構築が **絶対輝度範囲(absolute luminance range)**[@Debevec1997]でHDR画像を得ることを可能にする。このプロセスは、複数の露出でシーン受け取り、(輝度HDR[@Anastasia]のような)ソフトウェアで後にそれらを組み合わせるということを暗に示す。ソフトウェアはデバイス依存の応答曲線によりもとのシーン輝度を再構成する。良い画像[^footnote36]を取得することと、カメラ応答曲線を識別できることという二重の困難は、アーティストによって生み出されたほとんどのHDR画像が **相対的輝度**か露出前の輝度を表現するだけになっている、ということを暗に示している([@fig:52]参照)。他のライトタイプとそのようなディスタントライトプロブを混ぜ合わせるために、我々は相対的輝度値を調整するためのマルチプライヤをアーティストに提供する。Mac-Bethチャート、カメラ設定、よく知られた輝度値に基づく手動のキャリブレーションにより、アーティストは絶対輝度を取り戻すために良いファクタを見つけることができる[^footnote37]。正しく再構築された画像では、晴れた空は約$8000[\frac{cd}{m^2}]$の輝度を持ち、曇り空では約$2000[\frac{cd}{m^2}]$の輝度を持つ。夜のシーンでは、$3000[\frac{cd}{m^2}]$から$5000[\frac{cd}{m^2}]$の値はストリートのライト照明では珍しくない。月の輝度は約$2500[\frac{cd}{m^2}]$で、他のオブジェクトは、環境光でのみ照らされるときは、$1[\frac{cd}{m^2}]$以下になるためかなり暗くなる[@McNeel2015]。

![ディスタントライティングのために用いられるHDRIテクスチャの例。HDRIは相対的輝度値を格納する。](assets/Figure52.png){#fig:52}

[^footnote36]: 脚注36: 自然な密度フィルタを使うと、特に太陽をキャプチャしようとする[@Reinhard2005]ときに、適切な輝度を再構築するのに役立つ。

[^footnote37]: 脚注37: MaxwellやVRayはHDRIを輝度単位ではなく放射輝度単位として考えていることを確認した。我々の結果と合わせるためにこのソフトウェアのHDRIを683で除算する必要がある。CañadaはMaxwellにおいて、これが下手に取得された古いHDRIに関する歴史的な理由によるものであることを確認していた。

**強い光源**: 取得したHDRIでは、事前のインテグレーション間のノイズを避け(次節を参照)、それらの可視性を扱うためにライトプロブから強い光源を取り除くことが必要である。例えば、ライトプロブにベイクする代わりに太陽をディレクショナルライトとすると、適切に太陽のシャドウイングを扱うことができる。HDRIから太陽を取り除くことは太陽に周囲の空の小さな部分を単純にコピペする必要がある。

### ローカルライトプロブ(Local light probes) {id="sec:4.9.2"}

ローカルライトプロブはそれらのボリュームの周りの限られたエリアにある周囲のオブジェクトをキャプチャする。その目標はローカルな環境を一致させることである。この取得は常にエンジン内で処理され、オフラインで"ベイク"又は一度だけキャプチャされる、要求に応じてリフレッシュされる、実行時に毎フレームリフレッシュさせる、のいずれかを行うことができる。その選択は予算や必要条件(動くオブジェクト、ライティング状況の変化、など)に依存する。ローカルライトプロブをキャプチャすると、レンダリングの問題が生じる。

- **順序依存性(Order-dependency)**: ローカルライトプロブをキャプチャし終わるまで、シーンはローカルライトプロブで照らすことができない。この鶏と卵[^chicken_and_egg]の問題は、ローカルライトプロブがあるものの後に別のものをキャプチャする場合にキャプチャの順序依存性を生じさせる。
- **メタリックな表面**: メタリックな表面はキャプチャ時にディフューズの寄与もスペキュラの寄与も持たないために問題となり、結果として真っ黒な見た目になる。光のバウンスをシミュレートするために何回かローカルライトプロブをキャプチャすることが可能になる。もうひとつの可能性として、ディスタントライトプロブのライティングに頼ることが挙げられるが、屋内の環境で明らかなライトリークが現れる可能性がある。
- **ビュー依存の効果**: ローカルライトプロブ単一の点(つまり、キューブマップの中心)でキャプチャされる。そして、光沢のある鏡のような表面から入射するこのライティングは、ビュー依存性のために、キャプチャされた点以外の視点では誤りである。

[^chicken_and_egg]: 生命の起源として鶏と卵のどちらが先に現れたのか、という循環する因果関係のジレンマ。

これらの問題を解決するため、我々はライトプロブの取得中にマテリアルのスペキュラ要素を無効化する。スペキュラ項のみを含むメタリックな表面はディフューズアルベドとしてFresnel$f_0$を用いることでディフューズ表面として近似される。キャプチャ中に、アルファチャンネルに周囲のオブジェクトの可視性も格納する。これはローカルライトプロブの寄与をフェードするためにIBL合成の間で後に使われる。[@fig:53]はキャプチャされたローカルライトプロブの例を示す。

![上:いくつかのオブジェクト周りのローカルプロブのアプリケーション。地面に配置されたオブジェクトに当たっている、壁から来る赤色の反射に注目。左下:ローカルライトプロブに取得した色。金色のメタリックなオブジェクトが黄色に発光していることに注目。左下:ローカルライトプロブに格納されたアルファチャンネル情報。](assets/Figure53.png){#fig:53}

**関与媒質**: 例えば霧がかった環境では、ローカルライトプロブの寄与を評価するときに、理想としては媒質の透過率を計算に入れるべきである。フォグをローカルライトプロブに直接的に取得するのは、それが3D($\theta$、$\phi$、深度)ではなく2D($\theta$、$\phi$)の関数をモデル化するので、正しく動作しない。なので、この単純な2D関数では、陰影付けされる点とローカルライトプロブのプロキシジオメトリとの間の実際の透過率を計算することはできない。

![様々な角度から見た(GGXのNDFによる)マイクロファセットBRDFの形状。どのように見る角度でローブの異方性が増加するかに注目。](assets/Figure54.png){#fig:54}

### ライトプロブのフィルタリング(Light probe filtering) {id="sec:4.9.2"}

[@eq:46]の積分は視線方向$\boldsymbol{v}$、マテリアルモデル$f$、そのパラメータ$\Theta$に依存する。通常はそのような積分は解析解を持たず、一般的にはMonte-Carloのような確率的な積分のテクニックによる、数値的な評価を必要とする。そのような積分を直接評価するには毎フレームに各ピクセルごとに大量のサンプルを必要になると思われる。これは可能であるが、ゲームのようなハイパフォーマンスアプリケーションの文脈では現実的ではない。重点サンプリングはサンプル数を減らすことができるが、複数重点サンプリング(multiple-importance sampling; MIS)でさえ各フレームで各ピクセルを評価するために必要とするサンプル数は多すぎる。

**スペキュラの事前統合**: この評価を単純化するため、いくつかの近似を作ることで積分を事前統合することができる。すべての$\boldsymbol{v}$と$\Theta$に対してこの式を事前に統合することは巨大なメモリフットプリントを必要とするだろう。そのため、初めの近似はビュー依存を取り除くことである。これはBRDFの粗い近似を引き起こすが、マイクロファセットフレームワーク及び/又は半角パラメータ化に基づくBRDFの形状は[@fig:54]に示されるように見る角度に強く依存するため、許容できるトレードオフである。法線入射方向では、BRDF形状は等方的である。グレージング角では、BRDF形状は異方的である。[@eq:46]を事前統合することでビュー依存を取り除くことはBRDF形状がすべての角度から見て等方的であるという仮定を行う。これは、引き伸ばされた反射(stretched refrections)を妨げるような、重要な(key)ビジュアルの差異を引き起こす。この近似は[@fig:55]に示されるように平坦な表面でかなり目立つ可能性があるが、曲がった表面では多少目立ちにくくなる[^footnote38]。

![(GGXのNDFによる)マイクロファセットBRDFにおけるグレージング角での引き伸ばされた反射。左:近似。右:正しい挙動。](assets/Figure55.png){#fig:55}

[^footnote38]: 脚注38:積分を正しく評価し、引き伸ばされた反射を復元するために事前にフィルタした重点サンプリング[@Krivanek2008]を使うか、事前統合と @Green2007 に示されるような等方的なローブの分解を使うかのいずれかが可能である。

事前統合の次元性をさらに減らすため、ラフネス$\alpha$と0°の入射角でのFresnel値$f_0$による$\Theta = (f_0, \alpha)$へパラメータ数を減らす必要がある。先に述べたように、[@eq:46]は数値積分する必要がある。"事前にベイク"されたローカルライトプロブにおいて、この積分は、すべての計算がオフラインで行われるため、あらゆるパフォーマンスに関する懸念を持たずに行うことができる。しかし、オンデマンドなライトプロブ、連続的にリフレッシュされるローカルライトプロブ、アーティストによる高速な操作(ローカルライトプロブの配置、ディスタントライトプロブの回転)では、パフォーマンスが重要(critical)であり、良好な質/速度の比率を達成する必要がある。重点サンプリングは被積分関数の重要な部分での計算に注力することで集束を早めるために使うことができる。

$$
TODO
$$ {#eq:47}

### () {id="sec:4.9.3"}

## (Shadow and occlusion) {id="sec:4.10"}

### () {id="sec:4.10.1"}

### () {id="sec:4.10.2"}

### () {id="sec:4.10.3"}

### () {id="sec:4.10.4"}

## (Deferred / Forward rendering) {id="sec:4.11"}

# (Image) {id="sec:5"}

## () {id="sec:5.1"}

## () {id="sec:5.2"}

## () {id="sec:5.3"}

# (Transition to PBR) {id="sec:6"}

\appendix

# (Listing for reference mode) {id="sec:A"}

# (Oren-Nayar and GGX's diffuse term derivation) {id="sec:B"}

# (Energy conservation) {id="sec:C"}

# (Optimization algorithm for converting Disney's parametrization) {id="sec:D"}

# (Rectangular area lighting) {id="sec:E"}

# (Local light probe evaluation) {id="sec:F"}

# 参考文献(References)
