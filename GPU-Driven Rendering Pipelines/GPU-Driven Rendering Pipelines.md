---
title: GPU-Driven Rendering Pipelines [@Haar2015]
numberSections: false
---
# GPU駆動レンダリングとは？[GPU-Driven Rendering?]

- GPUが実際にレンダリングするものを制御する。
- "シーンを描画する"GPUコマンド
    - N個のビューポート/錐台
    - GPUが(サブ)オブジェクトの可視性を決定する。
    - CPU/GPUを往復[roundtrip]しなくて良い
- 先行研究[SBOT08]

# 動機(RedLynx)[Motivation (RedLynx)]

- インゲームレベルエディタを用いたモジュラー構造
- 大きな描画距離。小さなオブジェクトから作られる背景。
- 焼き込みライティングなし。シャドウマップからの大量のドローコール。
- CPUは物理シミュレーションやビジュアルスクリプティングで使われる。

# 動機(Assassin's Creed Unity)[Motivation Assassin's Creed Unity]

- 大規模なジオメトリ量: 建築物

<!-- p.7 -->

- 大規模なジオメトリ量: シームレスな内装

<!-- p.8 -->

- 大規模なジオメトリ量: 群衆

<!-- p.9 -->

- モジュラー構造(部分的に自動化されている)
- 前のAssassin's Creedと比べて最大10倍のインスタンス
- コンソールでは、CPUは最も乏しい[scarce]リソースである。

# メッシュクラスタレンダリング[Mesh Cluster Rendering]

- 固定トポロジー(64頂点ストリップ)
- 固定トポロジーに合わせるためにすべてのメッシュを分割して組み替える(退化した[degenerate]トライアングルを挿入する)。
- 頂点シェーダでは共有バッファから頂点を手動でフェッチする[@Riccio2013]。
- `DrawInstancedIndirect`
- GPUカリングはクラスタリストとドローコール引数を出力する。

<!-- p.11 -->

- 単一のドローコールに任意のメッシュ数
- クラスタ境界によってGPUカリングされる[@Greene1993; @Shopf2008; @Hill2011]。
- より高速な頂点フェッチ
- クラスタ深度ソート

# メッシュクラスタレンダリング(ACU)[Mesh Cluster Rendering (ACU)]

- トライアングルストリップでの問題
    - メモリが退化したトライアングルにより増加する。
    - 非決定的なクラスタ順序
- `MultiDrawIndexedInstancedIndirect`
    - インスタンスあたりひとつの(サブ)ドローコール
    - クラスタあたり64トライアングル
    - 実行中[on the fly]にインデックスバッファを追加する必要がある。

# レンダリングパイプラインの概要[Rendering Pipeline Overview]

- 粗い錐台カリング
- バッチハッシュを構築する。インスタンスのGPUデータを更新する。
- ドローコールをバッチ処理する。
- インスタンスカリング(錐台/オクルージョン)
- クラスタチャンク拡張[expansion]
- クラスタカリング(錐台/オクルージョン/トライアングル背面)
- インデックスバッファのコンパクション
- マルチドロー

<!-- p.14 -->

- CPU四分木カリング
- インスタンス毎データ
    - 例: 変換、LODファクタ、など。
    - GPUのリングバッファにて更新される。
    - 静的なインスタンスに対しては永続的[persistent]
- ドローコールハッシュはインスタンス化しないデータで構築する。
    - 例: マテリアル、レンダステート、など。
- ドローコールはハッシュに基づいてマージされる。

# 静的トライアングル背面カリング[Static Triangle Backface Culling]

- クラスタ中心キューブマップのピクセル錐台のためにトライアングルの可視性を焼き込む。
- キューブマップのルックアップはカメラに基づく。
- クラスタ内のすべてのトライアングルの可視性のための64ビットをフェッチする。

<!-- p.24 -->

- キューブマップ面あたり1ピクセルのみ(トライアングルあたり6ビット)
- ピクセル錐台はカリング効率をあげるためある距離で打ち切る(斜めの角度[oblique angle]で偽陽性になり得る)。
- 10-30%のトライアングルがカリングされる。

# オクルージョン深度生成[Occlusion Depth Generation]

- 最適な遮蔽物[occluder]を伴う深度プリパス
- High-ZやEarly-Zのためにフル解像度でレンダリングする。
- 512x256へダウンサンプリングする。
- 最後のフレームの深度の再投影で組み合わせる。
- GPUカリングのための深度階層

<!-- p.27 -->

- 300の最適な遮蔽物(~600us)
- High-ZやEarly-Zのためにフル解像度でレンダリングする。
- 512x256へダウンサンプリングする。(100us)
- 最後のフレームの深度の再投影で組み合わせる。(50us)
- GPUカリングのための深度階層(50us)

(* PS4のパフォーマンス)

# シャドウオクルージョン深度生成[Shadow Occlusion Depth Generation]

- カスケードごと
- カメラ深度再投影(~70us)
- 最後のフレームの深度の再投影で組み合わせる。(10us)
- GPUカリングのための深度階層(30us)

# カメラ深度生成[Camera Depth Generation]

- [@Silvennoinen2012]と似たようなもの
- しかし、マスクはフォグのために効率的ではない。
    - 最小深度を使えない。
    - far面を除外できない。
- 64x64のピクセル再投影
- 冗長なオーバードローを取り除くために深度をプリプロセスすることができるかも。

# 結果[Results]

- CPU
    - 1-2桁[orders of magnitude]少ないドローコール
    - 10倍のオブジェクトで、前のACの最大75%
- GPU
    - 20-40%のトライアングルがカリングされる(背面＋クラスタ境界)。
    - 小さな全体ゲインのみ: ジオメトリレンダリングの10%以下
    - 30-80%のシャドウトライアングルがカリングされる。
- 作業中
    - 静的なオブジェクトに対する更なるGPU駆動
    - 更なるバッチフレンドリーなデータ

# 将来[Future]

- バインドレステクスチャ
- GPU駆動 vs. DX12/Vulkan

# RedLynxのトピックス[RedLynx Topics]

# 仮想テクスチャリング[Virtual Texturing]

- **キーアイデア**: メモリ内に可視テクスチャデータのみを維持する[@Hall1999]。
- 仮想的な256Kx256Kのテクスチャアトラス
- 128x128テクセルページ
- 8Kx8Kのテクスチャページキャッシュ
    - 5スライスのテクスチャ配列: アルベド、スペキュラ、ラフネス、法線、など
    - DXT圧縮(BC5/BC3)

# VTを伴うGPU駆動レンダリング[GPU-Driven Rendering with VT]

- 仮想テクスチャリングは我々のレンダラとAC: Unityのレンダラとで大きく異なる所である。
- **重要な機能**: すべてのテクスチャデータは、単一のテクスチャバインディングを用いることで、同時に使うことができる。
- テクスチャでバッチする必要はない！

# 単一ドローコールレンダリング[Single Draw Call Rendering]

- ビューポート＝単一のドローコール(x2)
- 異なる頂点アニメーションタイプに対する動的バッチ処理
    - 近年のGPUで高速(+2%のコスト)
- クラスタ深度ソートは深度プリパスに似たゲインをもたらす。
- 逆順ソートを伴う安価なOIT

# 追加のVTの長所[Additional VT Advantages]

- 複合マテリアルブレンドやデカールレンダリング結果はVTページキャッシュへ格納される。
- データ再利用は数百フレームをかけてコストを償却する。
- テクスチャ解像度やアセット数に関係なく、一定のメモリフットプリント

# 仮想ディファードテクスチャリング[Virtual Deferred Textureing]

- **古いアイデア**: テクセルの代わりにUVをGバッファに格納する[@Auf2007]。
- **重要な機能**: VTページキャッシュアトラスは現時点で可視であるすべてのテクスチャデータを含む。
- **8Kx8K** のテクスチャアトラスへの16＋16ビットのUVは **8x8** のサブピクセル精度を与える。

# 勾配と接線フレーム[Gradients and Tangent Frame]


- スクリーン空間でピクセル勾配を計算する。UV距離は近傍を特定するために使われる。
- 近傍が見つからない→バイリニア
- 接線フレームは32ビットクォータニオンとして格納される[@Frykholm2009]。
- `VT.Page = UV.xy / 128`で暗黙的なMIP及びマテリアルID

# 要約＆長所[Recap & Advantages]

- 64ビット。フルフィルレート。MRTなし。
- オーバードローはひどく安価[dirty cheap]
    - テクスチャリングはライティングのコンピュートシェーダまで遅らされる。
- クアッド効率はそれほど重要ではない。
- 仮想テクスチャリングページIDパスはもう必要ない。

# 勾配再構築の品質[Gradient reconstruction quality]

# MSAAトリック[MSAA Trick]

- **重要な観察**: UVと接線は補間できる。
- **アイデア**: 順序付けられたグリッド4xMSAAパターンを持つ1/2の解像度(540p)でシーンをレンダリングする。
- ライティングのコンピュートシェーダで各サンプルを別々に読むために`Texture2DMS.Load(...)`を使う。

$$
P_1 = A + \frac{1}{4} \vec{AB} + \frac{1}{4} \vec{AC} \\
P_2 = B + \frac{1}{4} \vec{BA} + \frac{1}{4} \vec{BD} \\
P_3 = C + \frac{1}{4} \vec{CA} + \frac{1}{4} \vec{CD} \\
P_4 = D + \frac{1}{4} \vec{DC} + \frac{1}{4} \vec{DB} \\
$$

# 1080p再構築[1080p Reconstruction]

- 1080pをLDSに再構築する。
- エッジピクセルは完璧に再構築される。MSAAは両側[both sides]のためのピクセルシェーダを実行する。
- 内部ピクセルのUVと接線を補間する。
- クオリティは素晴らしい[excellent]。差異は見つけにくい[hard to spot]。

# 8xMSAAトリックのベンチマーク[8xMSAA Trick Benchmark]

- 128bppのGバッファ
- ひとつのピクセルが"2xMSAAピクセル"の2x2タイルである。
- Xbox One: 1080p + MSAA + 60fps :)

||2xMSAA|MSAAトリック|削減率|
|-|-|-|-|
|Gバッファレンダリング時間|3.03ms|2.06ms|-32%|
|ピクセルシェーダのwave|83016|36969|-55%|
|DRAMメモリトラフィック|76.3MB|60.9MB|-20%|
|ESRAM(18MB partial)|15.0MB|29.1MB||

# 二段階オクルージョンカリング[Two-Phase Occlusion Culling]

TODO

# 参考文献[References]
