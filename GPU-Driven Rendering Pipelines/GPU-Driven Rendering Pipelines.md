---
title: GPU-Driven Rendering Pipelines [@Haar2015]
numberSections: false
---
# GPU駆動レンダリングとは？[GPU-Driven Rendering?]

- GPUが実際にレンダリングするものを制御する。
- "シーンを描画する"GPUコマンド
    - N個のビューポート/錐台
    - GPUが(サブ)オブジェクトの可視性を決定する。
    - CPU/GPUを往復[roundtrip]しなくて良い
- 先行研究[SBOT08]

# 動機(RedLynx)[Motivation (RedLynx)]

- インゲームレベルエディタを用いたモジュラー構造
- 大きな描画距離。小さなオブジェクトから作られる背景。
- 焼き込みライティングなし。シャドウマップからの大量のドローコール。
- CPUは物理シミュレーションやビジュアルスクリプティングで使われる。

# 動機(Assassin's Creed Unity)[Motivation Assassin's Creed Unity]

- 大規模なジオメトリ量: 建築物

<!-- p.7 -->

- 大規模なジオメトリ量: シームレスな内装

<!-- p.8 -->

- 大規模なジオメトリ量: 群衆

<!-- p.9 -->

- モジュラー構造(部分的に自動化されている)
- 前のAssassin's Creedと比べて最大10倍のインスタンス
- コンソールでは、CPUは最も乏しい[scarce]リソースである。

# メッシュクラスタレンダリング[Mesh Cluster Rendering]

- 固定トポロジー(64頂点ストリップ)
- 固定トポロジーに合わせるためにすべてのメッシュを分割して組み替える(退化した[degenerate]トライアングルを挿入する)。
- 頂点シェーダでは共有バッファから頂点を手動でフェッチする[@Riccio2013]。
- `DrawInstancedIndirect`
- GPUカリングはクラスタリストとドローコール引数を出力する。

<!-- p.11 -->

- 単一のドローコールに任意のメッシュ数
- クラスタ境界によってGPUカリングされる[@Greene1993; @Shopf2008; @Hill2011]。
- より高速な頂点フェッチ
- クラスタ深度ソート

# メッシュクラスタレンダリング(ACU)[Mesh Cluster Rendering (ACU)]

- トライアングルストリップでの問題
    - メモリが退化したトライアングルにより増加する。
    - 非決定的なクラスタ順序
- `MultiDrawIndexedInstancedIndirect`
    - インスタンスあたりひとつの(サブ)ドローコール
    - クラスタあたり64トライアングル
    - 実行中[on the fly]にインデックスバッファを追加する必要がある。

# レンダリングパイプラインの概要[Rendering Pipeline Overview]

- 粗い錐台カリング
- バッチハッシュを構築する。インスタンスのGPUデータを更新する。
- ドローコールをバッチ処理する。
- インスタンスカリング(錐台/オクルージョン)
- クラスタチャンク拡張[expansion]
- クラスタカリング(錐台/オクルージョン/トライアングル背面)
- インデックスバッファのコンパクション
- マルチドロー

<!-- p.14 -->

- CPU四分木カリング
- インスタンス毎データ
    - 例: 変換、LODファクタ、など。
    - GPUのリングバッファにて更新される。
    - 静的なインスタンスに対しては永続的[persistent]
- ドローコールハッシュはインスタンス化しないデータで構築する。
    - 例: マテリアル、レンダステート、など。
- ドローコールはハッシュに基づいてマージされる。

# 静的トライアングル背面カリング[Static Triangle Backface Culling]

- クラスタ中心キューブマップのピクセル錐台のためにトライアングルの可視性を焼き込む。
- キューブマップのルックアップはカメラに基づく。
- クラスタ内のすべてのトライアングルの可視性のための64ビットをフェッチする。

<!-- p.24 -->

- キューブマップ面あたり1ピクセルのみ(トライアングルあたり6ビット)
- ピクセル錐台はカリング効率をあげるためある距離で打ち切る(斜めの角度[oblique angle]で偽陽性になり得る)。
- 10-30%のトライアングルがカリングされる。

# オクルージョン深度生成[Occlusion Depth Generation]

- 最適な遮蔽物[occluder]を伴う深度プリパス
- High-ZやEarly-Zのためにフル解像度でレンダリングする。
- 512x256へダウンサンプリングする。
- 最後のフレームの深度の再投影で組み合わせる。
- GPUカリングのための深度階層

<!-- p.27 -->

- 300の最適な遮蔽物(~600us)
- High-ZやEarly-Zのためにフル解像度でレンダリングする。
- 512x256へダウンサンプリングする。(100us)
- 最後のフレームの深度の再投影で組み合わせる。(50us)
- GPUカリングのための深度階層(50us)

(* PS4のパフォーマンス)

# シャドウオクルージョン深度生成[Shadow Occlusion Depth Generation]

- カスケードごと
- カメラ深度再投影(~70us)
- 最後のフレームの深度の再投影で組み合わせる。(10us)
- GPUカリングのための深度階層(30us)

# カメラ深度生成[Camera Depth Generation]

- [@Silvennoinen2012]と似たようなもの
- しかし、マスクはフォグのために効率的ではない。
    - 最小深度を使えない。
    - far面を除外できない。
- 64x64のピクセル再投影
- 冗長なオーバードローを取り除くために深度をプリプロセスすることができるかも。

# 結果[Results]

- CPU
    - 1-2桁[orders of magnitude]少ないドローコール
    - 10倍のオブジェクトで、前のACの最大75%
- GPU
    - 20-40%のトライアングルがカリングされる(背面＋クラスタ境界)。
    - 小さな全体ゲインのみ: ジオメトリレンダリングの10%以下
    - 30-80%のシャドウトライアングルがカリングされる。
- 作業中
    - 静的なオブジェクトに対する更なるGPU駆動
    - 更なるバッチフレンドリーなデータ

# 将来[Future]

- バインドレステクスチャ
- GPU駆動 vs. DX12/Vulkan

# RedLynxのトピックス[RedLynx Topics]

TODO

# 参考文献[References]
