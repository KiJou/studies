---
title: Engine Optimization Hot Lap [@Lottes2018]
---
# Engine Optimization Hot Lap

# このトークの目標

- ハードウェアレベルにより近い所でのGPUの動作の仕方について更に教示する
- GPUワークロードやエンジン設計についての理由付けを行うのを助けるために
- 様々な最適化の結果を提示する
- <font color="red">そして、究極的にはGPUがスケールし続けるたびにビジュアルおよびパフォーマンス目標をさらに良く理解するのを助ける</font>

# GCN再掲

- SIMD(VALU) = 16幅ベクトルALUは4クロックに渡って64幅のwaveを実行する
    - 最大占有率 8 waves/SIMD (Polaris)、または、一般には10 waves/SIMD (Polaris以外)
- CU = Compute Unitは4SIMDを含む(1wave/clockのピークVALU実行スループット)
- SALU = Scalar ALU
- LDS = Local Data Store
- V\$ = ベクトルL1キャッシュ (VMEM)
- I\$ = 命令L1キャッシュ
- K\$ = スカラL1キャッシュ (SMEM)

# 描画の外側を考える

- しばしば最適化の努力は最も高価なシェーダを最適化することに注力[narrowly focused]される
- このトークは全体論的な視点を取る: **すべての描画/ディスパッチの内外のフレーム全体の実行時間に注目する**

# AMD内で使われる解析用ツールのイントロダクション

- 外部ツール
    - Radeon GPU Profiler (RGP)
- AMD内部ツール
    - VK_GPA_interface
    - ドライバ修正
    - 命令トレースリポート
        - → wave実行の詳細
        - → waveの寿命
        - → CU命令のまとめ
            - 緑 = SIMDあたりのVALUの発行
            - 橙 = VMEMの発行

# 核となる原則

# AMDAHLの法則

- 並列処理の観点でマシンがスケールするごとに可能なパフォーマンス改善は並列処理の量に比例する
- 例えば、GHzだと[at the GHz wall]、仕事の75%を並列に走らせただけで、ベストケースの実行時間は並列でないマシンの25%にまで下がるだろう
- Takeaway: **パイプライン化された並列な仕事でGPUを満杯にし続ける**

# GCNのベクトルメモリアクセスの理解

- 平均レイテンシーはGPU/ワークロード/他によって変化し得る
- 人工のシェーダレイテンシーのテスト結果からパフォーマンスの急上昇[cliff]を推定できる
    - L1ヒットで約114クロック(peak 16 clock/VMEM return rate for image ops) (1 clock/VALU)
    - L2ヒットで約190クロック(L1ヒットと比べて平均で約76クロックの追加レイテンシー ... 76/16 = 4.75のイメージL1\$ヒット)
    - L2ミスで約350クロック(L1ヒットと比べて平均で約236クロックの追加レイテンシー ... 236/16 = 14.75のイメージL1\$ヒット)
- メモリスループットを減らすもの
    - リクエストキューがdrainingしない程度に高速なVMEM操作を維持しないこと
        - **メモリリクエストの通常フローを維持してみる(wave占有率の不規則さを探す、など)**
    - L1キャッシュミスやL2キャッシュミスによって引き起こされるメモリバブル
        - **空間的および時間的にデータ局所性を改善して、L1ヒット率を上げてみる**

# Idle Bound

# Idle Boundの例 --- スライド1

GPU Draining
アイドル込みのバリア
直列の依存性＋小さなジョブ

# Idle Boundの例 --- スライド2

単純なジオメトリではGPUは飽和しない
GPU Draining
SIMULTANEOUS_USE_BITのコマンドバッファは並列性を妨げる

# 1/4解像度パスのDrainとFillに関する数

最初のPSのwaveへのフロントエンドのタイムスタンプでは2.2us(ここにはVSからPSへの遅延が含まれる)
PSのfill時間では1.2us(50%以下がアクティブ)
PSのdrain時間は5.9us(約50%がアクティブ)
バリアに2.6us(キャッシュのフラッシュを含む)
計59.9usのうち51.5usがアクティブ
↑このポストパスではGPUの最低でも14%のVALUがアイドル

独立した第2、第3のPS描画を伴う並列でのPSクリア(48us中35usのVALU処理)
100%として数える(実際にはこうはならないだろう)
vkCmdClearAttachmentsはVS+PSクリアを生成、VSからPSへの遅延に注意
最小のオーバーラップ、帯域幅boundのPSクリア(VALUなし)が第2PSの起動を遅らせる
↑このポストパス＋クリアではGPUの最低でも26%のVALUがアイドル

# GPUを埋める --- コールドキャッシュの話

TODO
