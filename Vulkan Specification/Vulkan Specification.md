---
title: Vulkan 1.0.68 - A Specification
---
# はじめに {id="sec:1"}

## 1.1

## 1.2

## 用語法 {id="sec:1.3"}

この文書におけるキーワード **しなければならない[must]**、**要求されている[required]**、**推奨される[recommend]**、**してもよい[may]**、**選択できる[optional]** はRFC 2119に示される通りに解釈されるものとする^[訳注:日本語訳に際し、この文書では[RFC 2119JA](https://www.ipa.go.jp/security/rfc/RFC2119JA.html)に準拠する。]。

[http://www.ietf.org/rfc/rfc2119.txt](http://www.ietf.org/rfc/rfc2119.txt)

しなければならない[must]
: 単独で使われるとき、この語、または、**要求されている[required]** はその定義が仕様の絶対的な要請事項であることを意味する。**not** が続くとき("**してはならない[must not]**")、このフレーズはその定義が仕様の絶対的な禁止事項であること意味する。

する必要がある[should]
: 単独で使われるとき、この語は、特定の状況において特定の項目を無視する妥当な理由が存在するかもしれないが、異なる進路を取る前にその完全な意義を理解して慎重に検討しなければならない、ということを意味する。**not** が続くとき("**しないほうがよい[should not]**")、特定の挙動が許容できる、または、非常に有用であるときにこのフレーズは特定の状況において妥当な理由が存在するかもしれないが、このラベルで述べられるいかなる挙動を実装する前にその完全な意義を理解して、その場合分けを慎重に検討 **する必要がある**、ということを意味する。文法的に適切な場合、**推奨される[recommend]**、または、**推奨[recommendation]** が **する必要がある** の代わりに使われるかもしれない。

してもよい[may]
: この語、または、形容詞 **選択できる[optional]** は項目が真に選択的であることを意味する。あるベンダーは、特定の市場が要求している、または、他のベンダーはその項目を省略するかもしれないのに対し、そのベンダーは同様の項目がその製品を改良すると思っていることを理由に、その項目を含むことを選んでもよい。特定の選択肢を含まない実装は、恐らく機能性に劣るだろうが、その選択肢を含む他の実装と相互運用する準備をしておかなければならない。同様に、特定の選択肢を含む実装はその選択肢を含まない他の実装と相互運用する準備をしておかなければならない(もちろん、その選択肢が提供する機能は除く)。

追加の用語 **できる[can]**、**できない[cannot]** は以下のように解釈されるものとする。

できる[can]
: この語は、述べられる特定の挙動がアプリケーションに対して妥当な選択であることを意味し、実装の挙動を指して使われることは一切ない。

できない[cannot]
: この語は述べられる特定の挙動がアプリケーションによって達成不可能であることを意味する。例えば、エントリーポイントが存在しなければ、シェーダコードは処理を表現する能力がない。

> 注意
> この仕様書で使われるように、**できない** と **してはならない** の間には重要な区別がある。**できない** はアプリケーションがAPIを通して表現することも達成することも文字通りできないことを意味する。一方で、**してはならない** は、アプリケーションがAPIを通して表現する能力がないこと、実装のために処理の結果が未定義であり回復不可能となり得ることを意味する。

## 1.4

# 基礎 {id="sec:2"}

## アーキテクチャモデル {id="sec:2.1"}

Vulkanは以下の特性を持つCPU、GPU、その他ハードウェアアクセラレータのアーキテクチャのために設計され、そのAPIも同様に記述される。

- これらのバイトサイズの粒度でアドレス指定可能な、8、16、32、64ビットの符号ありと符号なしの二の補数の整数に対する実行時サポート
- [浮動小数点計算](#sec:2.8.1)の節における範囲と精度の制約を満足する、32、64ビットの浮動小数点型に対する実行時サポート
- これらの型の表現とエンディアンはそのホストと物理デバイスに対して同一で **なければならない**。

> 注意
> Vulkanにおける様々なデータの型と構造はホストと物理デバイスのメモリの間を相互に対応 **してもよい** ので、ホストやデバイスのアーキテクチャは両方とも、ポータブルで高性能なアプリケーションを記述するために効率的にそのようなデータへアクセスでき **なければならない**。

## 実行モデル {id="sec:2.2"}

この節はVulkanシステムの実行モデルの概要を述べる。

Vulkanは1つ以上の *デバイス* を露出する。このそれぞれが1つ以上の *キュー* を露出する。これは互いに非同期的に処理を行っ **てもよい**。デバイスによってサポートされる一連のキューは *ファミリー* に分けられる。各ファミリーは1種以上の機能性をサポートし、同様の特徴を持つ複数のキューを含ん **でもよい**。単一のファミリー内のキューは互いに *互換性がある* と見なし、キューのとあるファミリーに対して生成される処理はそのファミリー内のいずれのキューにおいて実行 **できる**。この仕様はキューがサポート **してもよい**、グラフィクス、コンピュート、トランスファー、スパースメモリ管理の4種の機能性を定義する。

> 注意
> 単一のデバイスは、?[multiple members of one or more of those families]を報告するのではなく、もしくはそれと同様に、複数の同様のキューファミリーを報告 **してもよい**。これは、これらのファミリーのメンバーが同様の能力を持つ一方で、これらが直接的に互いへの互換性が *ない* ことを示す。

デバイスメモリはアプリケーションによって明示的に管理される。各デバイスは、異なるメモリエリアを表すために、1つ以上のヒープを公表 **してもよい**。メモリヒープはデバイスローカルかホストローカルのいずれかであるが、デバイスからは常に可視である。メモリヒープについての更なる詳細はそのヒープで利用可能なメモリタイプを経由して公開される。実装で使えるように **してもよい** メモリエリアの例は以下を含める。

- *device local* はデバイスへ物理的に接続されるメモリである。
- *device local*、*host visible* はホストから可視であるデバイスローカルなメモリである。
- *host local*、*host visible* はホストに対してローカルであり、デバイスとホストから可視である。

他のアーキテクチャでは、いかなる目的に対して用いることが **できる** 単一のヒープのみが存在 **してもよい**。

VulkanアプリケーションはVulkanライブラリの呼び出しを経由して発行されるデバイスコマンドを記録したコマンドバッファのサブミッションを通して一連のデバイスを制御する。コマンドバッファのコンテンツは基礎となるハードウェアに特有であり、アプリケーションから不透明である。一度構築されれば、コマンドバッファは実行するためにキューへ一度だけ又は何度もサブミット **できる**。複数のコマンドバッファはアプリケーション内で複数のスレッドを用いることで並列に作ることが **できる**。

異なるキューにサブミットされたコマンドバッファは互いに関して並列に、または、順序を外れて[out of order]さえも実行 **してもよい**。単一のキューにサブミットされたコマンドバッファは、[同期の章](#sec:6)でさらに述べられるように、[サブミッション順序](#sec:6.2.submission_order)を尊重する。デバイスによるコマンドバッファの実行はホストの実行に対して非同期でもある。一度コマンドバッファがキューにサブミットされれば、即座にアプリケーションへ制御を返し **てもよい**。デバイスとホストの間や異なるキューの間の同期はアプリケーションの責任である。

### キュー操作 {id="sec:2.3"}

Vulkanのキューはデバイスの実行エンジンへのインターフェイスを提供する。これらの実行エンジンに対するコマンドは実行する前にコマンドバッファに記録される。その後、これらのコマンドバッファは多くの *バッチ* における実行に対する *キューサブミッション* コマンドによってキューに提出される。一度キューにサブミットされれば、これらのコマンドは実行を開始し、アプリケーションの更なる介入なしに完了するだろうが、この実行順は多くの[暗黙的および明示的な順序制約](#sec:6)に依存している。

作業は一般的に`vkQueue*`(例えば、[vkQueueSubmit](#sec:5.5.vkQueueSubmit)、[vkQueueBindSparse](#sec:28.7.6.vkQueueBindSparse))の形を取るキューサブミッションコマンドを用いてキューにサブミットされ、作業を開始する前に待機するセマフォのリストと作業を完了したと一度だけ合図を送るセマフォのリストを任意に取る。作業それ自体は、セマフォの合図や待機と同様に、すべて *キュー操作* である。

異なるキューでのキュー操作は暗黙的な順序制約を持たず、いかなる順序で実行 **してもよい**。キューの間の明示的な順序制約は[セマフォ](#sec:6.4)や[フェンス](#sec:6.3)によって表現 **できる**。

単一のキューへのコマンドバッファサブミッションは[サブミッション順序](#sec:6.2.submission_order)やその他の[暗黙的な順序保証](#sec:6.2)を尊重するが、そうでなければ、重ね合わせたり順序を外れて実行 **してもよい**。その他のバッチや単一のキューに対するキューサブミッションのタイプ(例えば、[スパースメモリバインディング](#sec:28.7.6.sparse_memory_binding))は他のいかなるキューサブミッションまたはバッチに対する暗黙的な順序制約を持たない。キューサブミッションと個々のバッチとの間の追加の明示的な順序制約は[セマフォ](#sec:6.4)や[フェンス](#sec:6.3)によって表現できる。

フェンスまたはセマフォが合図を送る前に、以前にサブミットされたいかなるキュー操作も実行を完了し、これらのキュー操作からのメモリ書き込みが将来のキュー操作で[利用可能](#sec:6.1.availability)であることが保証される。合図が送られたセマフォまたはフェンスを待機することは利用可能である以前の書き込みが後続のコマンドから[可視](#sec:6.1.visibility)でもあることを保証する。

プライマリとセカンダリのコマンドバッファの間、および、同じまたは異なるバッチやサブミッションのプライマリコマンドバッファの間の両方のコマンドバッファ境界は追加のいかなる順序制約も導入しない。言い換えれば、いかなるセマフォまたはフェンスの間の(セカンダリコマンドバッファの実行を含めることが **できる**)一連のコマンドバッファのサブミットは、各境界で現在の状態が[リセット](#sec:5.reset)されることを除いて、それらがすべて単一のプライマリコマンドバッファに記録されたかのように、記録されたコマンドを実行する。明示的な順序制約は[明示的な同期プリミティブ](#sec:6)によって表現 **できる**。

> 注意
> 実装はキューにサブミットされた作業の実行を重ね合わせるための著しい自由度を持つ。そして、これはVulkanデバイスにおける深いパイプライン処理や並列性のために普通のことである。

コマンドバッファに記録されるコマンドはアクションを処理する(描画、ディスパッチ、クリア、コピー、クエリ/タイムスタンプ操作、サブパス開始/終了操作)、ステートを設定する(パイプライン、デスクリプタセット、バッファのバインド、動的ステートの設定、push constants、レンダパス/サブパスのステートの設定)、同期を処理する(イベントの設定/待機、パイプラインバリア、レンダパス/サブパスの依存関係)、のいずれかを行う。いくつかのコマンドはこれらタスクのひとつかそれ以上を処理する。ステートを設定するコマンドはコマンドバッファの *現在の状態* を更新する。アクションを処理するいくつかのコマンド(例えば、描画/ディスパッチ)はコマンドバッファの開始から累積的に設定された現在の状態に基づいて行う。アクションコマンドを処理するのに関係する作業はしばしば重ね合わせたり並べ替えたりできるが、そうすることが各アクションコマンドによって用いられるステートを変更 **してはならない**。一般に、アクションコマンドは、フレームバッファアタッチメントを変更したり、バッファやイメージのメモリを読み書きしたり、クエリプールに書き込んだりするコマンドである。

同期コマンドは2つの一連のアクションコマンドの間の明示的な[実行およびメモリの依存関係](#sec:6.1)を導入する。ここでは、後者のコマンド一式が前者のコマンド一式に依存する。これらの依存関係は前者におけるとある[パイプラインステージ](#sec:6.2.1)の実行の後に後者におけるとあるパイプラインステージの実行が起こること、および、とあるパイプラインステージによって処理される[メモリアクセス](#sec:6.7.2)の効果が順番に起こるの両方を強制し、そして、互いに可視である。明示的な依存関係または[暗黙的な順序保証](#sec:6.2)によって強制されないとき、アクションコマンドは実行を重ね合わせたり順序を外れて実行 **してもよく**、互いのメモリアクセスの副次的効果を確認 **しなくてもよい**^[訳注:原文では"**may** not see …"となっている。要検証。]。

デバイスはホストに関して非同期にキュー操作を実行する。制御は、キューへのコマンドバッファサブミッションに従い、アプリケーションへ即座に返される。アプリケーションは必要に応じてホストとデバイスの間の作業を同期 **しなければならない**。

## オブジェクトモデル {id="sec:2.3"}

## 2.4

## 2.5

## 2.6

## 2.7

## 2.8

### 2.8.1 {id="sec:2.8.1"}

# 3

# 4

# 5

<a id="sec:5.reset" />Each command buffer manages ...

# 6 {id="sec:6"}

## 6.1

<a id="sec:6.1.availability" /><a id="sec:6.1.visibility" />Two additional types ...

## 6.2

<a id="sec:6.2.submission_order">*提出順序*</a>
