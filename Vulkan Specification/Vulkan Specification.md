---
title: Vulkan 1.0.68 - A Specification
---
# はじめに {id="sec:1"}

## 1.1

## 1.2

## 用語法 {id="sec:1.3"}

この文書におけるキーワード **しなければならない[must]**、**要求されている[required]**、**推奨される[recommend]**、**してもよい[may]**、**選択できる[optional]** はRFC 2119に示される通りに解釈されるものとする^[訳注:日本語訳に際し、この文書では[RFC 2119JA](https://www.ipa.go.jp/security/rfc/RFC2119JA.html)に準拠する。]。

[http://www.ietf.org/rfc/rfc2119.txt](http://www.ietf.org/rfc/rfc2119.txt)

しなければならない[must]
: 単独で使われるとき、この語、または、**要求されている[required]** はその定義が仕様の絶対的な要請事項であることを意味する。**not** が続くとき("**してはならない[must not]**")、このフレーズはその定義が仕様の絶対的な禁止事項であること意味する。

する必要がある[should]
: 単独で使われるとき、この語は、特定の状況において特定の項目を無視する妥当な理由が存在するかもしれないが、異なる進路を取る前にその完全な意義を理解して慎重に検討しなければならない、ということを意味する。**not** が続くとき("**しないほうがよい[should not]**")、特定の挙動が許容できる、または、非常に有用であるときにこのフレーズは特定の状況において妥当な理由が存在するかもしれないが、このラベルで述べられるいかなる挙動を実装する前にその完全な意義を理解して、その場合分けを慎重に検討 **する必要がある**、ということを意味する。文法的に適切な場合、**推奨される[recommend]**、または、**推奨[recommendation]** が **する必要がある** の代わりに使われるかもしれない。

してもよい[may]
: この語、または、形容詞 **選択できる[optional]** は項目が真に選択的であることを意味する。あるベンダーは、特定の市場が要求している、または、他のベンダーはその項目を省略するかもしれないのに対し、そのベンダーは同様の項目がその製品を改良すると思っていることを理由に、その項目を含むことを選んでもよい。特定の選択肢を含まない実装は、恐らく機能性に劣るだろうが、その選択肢を含む他の実装と相互運用する準備をしておかなければならない。同様に、特定の選択肢を含む実装はその選択肢を含まない他の実装と相互運用する準備をしておかなければならない(もちろん、その選択肢が提供する機能は除く)。

追加の用語 **できる[can]**、**できない[cannot]** は以下のように解釈されるものとする。

できる[can]
: この語は、述べられる特定の挙動がアプリケーションに対して妥当な選択であることを意味し、実装の挙動を指して使われることは一切ない。

できない[cannot]
: この語は述べられる特定の挙動がアプリケーションによって達成不可能であることを意味する。例えば、エントリーポイントが存在しなければ、シェーダコードは処理を表現する能力がない。

> 注意
> この仕様書で使われるように、**できない** と **してはならない** の間には重要な区別がある。**できない** はアプリケーションがAPIを通して表現することも達成することも文字通りできないことを意味する。一方で、**してはならない** は、アプリケーションがAPIを通して表現する能力がないこと、実装のために処理の結果が未定義であり回復不可能となり得ることを意味する。

## 1.4

# 基礎 {id="sec:2"}

## アーキテクチャモデル {id="sec:2.1"}

Vulkanは以下の特性を持つCPU、GPU、その他ハードウェアアクセラレータのアーキテクチャのために設計され、そのAPIも同様に記述される。

- これらのバイトサイズの粒度でアドレス指定可能な、8、16、32、64ビットの符号ありと符号なしの二の補数の整数に対する実行時サポート
- [浮動小数点計算](#sec:2.8.1)の節における範囲と精度の制約を満足する、32、64ビットの浮動小数点型に対する実行時サポート
- これらの型の表現とエンディアンはそのホストと物理デバイスに対して同一で **なければならない**。

> 注意
> Vulkanにおける様々なデータの型と構造はホストと物理デバイスのメモリの間を相互に対応 **してもよい** ので、ホストやデバイスのアーキテクチャは両方とも、ポータブルで高性能なアプリケーションを記述するために効率的にそのようなデータへアクセスでき **なければならない**。

## 実行モデル {id="sec:2.2"}

この節はVulkanシステムの実行モデルの概要を述べる。

Vulkanは1つ以上の *デバイス* を露出する。このそれぞれが1つ以上の *キュー* を露出する。これは互いに非同期的に処理を行っ **てもよい**。デバイスによってサポートされる一連のキューは *ファミリー* に分けられる。各ファミリーは1種以上の機能性をサポートし、同様の特徴を持つ複数のキューを含ん **でもよい**。単一のファミリー内のキューは互いに *互換性がある* と見なし、キューのとあるファミリーに対して生成される処理はそのファミリー内のいずれのキューにおいて実行 **できる**。この仕様はキューがサポート **してもよい**、グラフィクス、コンピュート、トランスファー、スパースメモリ管理の4種の機能性を定義する。

> 注意
> 単一のデバイスは、?[multiple members of one or more of those families]を報告するのではなく、もしくはそれと同様に、複数の同様のキューファミリーを報告 **してもよい**。これは、これらのファミリーのメンバーが同様の能力を持つ一方で、これらが直接的に互いへの互換性が *ない* ことを示す。

デバイスメモリはアプリケーションによって明示的に管理される。各デバイスは、異なるメモリエリアを表すために、1つ以上のヒープを公表 **してもよい**。メモリヒープはデバイスローカルかホストローカルのいずれかであるが、デバイスからは常に可視である。メモリヒープについての更なる詳細はそのヒープで利用可能なメモリタイプを経由して公開される。実装で使えるように **してもよい** メモリエリアの例は以下を含める。

- *device local* はデバイスへ物理的に接続されるメモリである。
- *device local*、*host visible* はホストから可視であるデバイスローカルなメモリである。
- *host local*、*host visible* はホストに対してローカルであり、デバイスとホストから可視である。

他のアーキテクチャでは、いかなる目的に対して用いることが **できる** 単一のヒープのみが存在 **してもよい**。

VulkanアプリケーションはVulkanライブラリの呼び出しを経由して発行されるデバイスコマンドを記録したコマンドバッファのサブミッションを通して一連のデバイスを制御する。コマンドバッファの中身は基礎となるハードウェアに特有であり、アプリケーションから不透明である。一度構築されれば、コマンドバッファは実行するためにキューへ一度だけ又は何度もサブミット **できる**。複数のコマンドバッファはアプリケーション内で複数のスレッドを用いることで並列に作ることが **できる**。

異なるキューにサブミットされたコマンドバッファは互いに関して並列に、または、順序を外れて[out of order]さえも実行 **してもよい**。単一のキューにサブミットされたコマンドバッファは、[同期の章](#sec:6)でさらに述べられるように、[サブミッション順序](#sec:6.2.submission_order)を尊重する。デバイスによるコマンドバッファの実行はホストの実行に対して非同期でもある。一度コマンドバッファがキューにサブミットされれば、即座にアプリケーションへ制御を返し **てもよい**。デバイスとホストの間や異なるキューの間の同期はアプリケーションの責任である。

### キュー操作 {id="sec:2.2.1"}

Vulkanのキューはデバイスの実行エンジンへのインターフェイスを提供する。これらの実行エンジンに対するコマンドは実行する前にコマンドバッファに記録される。その後、これらのコマンドバッファは多くの *バッチ* における実行に対する *キューサブミッション* コマンドによってキューに提出される。一度キューにサブミットされれば、これらのコマンドは実行を開始し、アプリケーションの更なる介入なしに完了するだろうが、この実行順は多くの[暗黙的および明示的な順序制約](#sec:6)に依存している。

作業は一般的に`vkQueue*`(例えば、[vkQueueSubmit](#sec:5.5.vkQueueSubmit)、[vkQueueBindSparse](#sec:28.7.6.vkQueueBindSparse))の形を取るキューサブミッションコマンドを用いてキューにサブミットされ、作業を開始する前に待機するセマフォのリストと作業を完了したと一度だけ合図を送るセマフォのリストを任意に取る。作業それ自体は、セマフォの合図や待機と同様に、すべて *キュー操作* である。

異なるキューでのキュー操作は暗黙的な順序制約を持たず、いかなる順序で実行 **してもよい**。キューの間の明示的な順序制約は[セマフォ](#sec:6.4)や[フェンス](#sec:6.3)によって表現 **できる**。

単一のキューへのコマンドバッファサブミッションは[サブミッション順序](#sec:6.2.submission_order)やその他の[暗黙的な順序保証](#sec:6.2)を尊重するが、そうでなければ、重ね合わせたり順序を外れて実行 **してもよい**。その他のバッチや単一のキューに対するキューサブミッションのタイプ(例えば、[スパースメモリバインディング](#sec:28.7.6.sparse_memory_binding))は他のいかなるキューサブミッションまたはバッチに対する暗黙的な順序制約を持たない。キューサブミッションと個々のバッチとの間の追加の明示的な順序制約は[セマフォ](#sec:6.4)や[フェンス](#sec:6.3)によって表現できる。

フェンスまたはセマフォが合図を送る前に、以前にサブミットされたいかなるキュー操作も実行を完了し、これらのキュー操作からのメモリ書き込みが将来のキュー操作で[利用可能](#sec:6.1.availability)であることが保証される。合図が送られたセマフォまたはフェンスを待機することは利用可能である以前の書き込みが後続のコマンドから[可視](#sec:6.1.visibility)でもあることを保証する。

プライマリとセカンダリのコマンドバッファの間、および、同じまたは異なるバッチやサブミッションのプライマリコマンドバッファの間の両方のコマンドバッファ境界は追加のいかなる順序制約も導入しない。言い換えれば、いかなるセマフォまたはフェンスの間の(セカンダリコマンドバッファの実行を含めることが **できる**)一連のコマンドバッファのサブミットは、各境界で現在の状態が[リセット](#sec:5.reset)されることを除いて、それらがすべて単一のプライマリコマンドバッファに記録されたかのように、記録されたコマンドを実行する。明示的な順序制約は[明示的な同期プリミティブ](#sec:6)によって表現 **できる**。

> 注意
> 実装はキューにサブミットされた作業の実行を重ね合わせるための著しい自由度を持つ。そして、これはVulkanデバイスにおける深いパイプライン処理や並列性のために普通のことである。

コマンドバッファに記録されるコマンドはアクションを処理する(描画、ディスパッチ、クリア、コピー、クエリ/タイムスタンプ操作、サブパス開始/終了操作)、ステートを設定する(パイプライン、デスクリプタセット、バッファのバインド、動的ステートの設定、push constants、レンダパス/サブパスのステートの設定)、同期を処理する(イベントの設定/待機、パイプラインバリア、レンダパス/サブパスの依存関係)、のいずれかを行う。いくつかのコマンドはこれらタスクのひとつかそれ以上を処理する。ステートを設定するコマンドはコマンドバッファの *現在の状態* を更新する。アクションを処理するいくつかのコマンド(例えば、描画/ディスパッチ)はコマンドバッファの開始から累積的に設定された現在の状態に基づいて行う。アクションコマンドを処理するのに関係する作業はしばしば重ね合わせたり並べ替えたりできるが、そうすることが各アクションコマンドによって用いられるステートを変更 **してはならない**。一般に、アクションコマンドは、フレームバッファアタッチメントを変更したり、バッファやイメージのメモリを読み書きしたり、クエリプールに書き込んだりするコマンドである。

同期コマンドは2つの一連のアクションコマンドの間の明示的な[実行およびメモリの依存関係](#sec:6.1)を導入する。ここでは、後者のコマンド一式が前者のコマンド一式に依存する。これらの依存関係は前者におけるとある[パイプラインステージ](#sec:6.2.1)の実行の後に後者におけるとあるパイプラインステージの実行が起こること、および、とあるパイプラインステージによって処理される[メモリアクセス](#sec:6.7.2)の効果が順番に起こるの両方を強制し、そして、互いに可視である。明示的な依存関係または[暗黙的な順序保証](#sec:6.2)によって強制されないとき、アクションコマンドは実行を重ね合わせたり順序を外れて実行 **してもよく**、互いのメモリアクセスの副次的効果を確認 **しなくてもよい**。

デバイスはホストに関して非同期にキュー操作を実行する。制御は、キューへのコマンドバッファサブミッションに従い、アプリケーションへ即座に返される。アプリケーションは必要に応じてホストとデバイスの間の作業を同期 **しなければならない**。

## オブジェクトモデル {id="sec:2.3"}

Vulkanにおけるデバイス、キュー、その他のエンティティはVulkanオブジェクトによって表される。APIレベルでは、すべてのオブジェクトはハンドルによって参照される。ハンドルにはディスパッチ可能[dispatchable]とディスパッチ不能[non-dispatchable]の2つクラスが存在する。*ディスパッチ可能* なハンドル型は不透明型へのポインタである。このポインタはAPIコマンドを傍受する一環としてレイヤーによって使われ **てもよい**。そしてそれ故に、各APIコマンドはその第1引数としてディスパッチ可能型を取る。ディスパッチ可能型の各オブジェクトはその寿命の間に唯一のハンドル値を持た **なければならない**。

*ディスパッチ不能* なハンドル型は実装依存の意味を持つ64ビット整数型であり、ソフトウェア構造へのポインタではなくハンドルにオブジェクト情報を直接エンコード **してもよい**。ディスパッチ不能型のオブジェクトは型の内部に、または、型にわたって唯一のハンドル値を持た **なくてもよい**。ハンドル値が唯一でないならば、そのようなハンドルのひとつを破壊しても他の型の同一ハンドルが不正になるようなことがあっ **てはならず**、同じ型の同一ハンドルでは、そのハンドル値の生成された回数が破壊された回数よりも多いならば、不正になるようなことがあっ **てはならない**。

ある`VkDevice`から生成または割り当てられた(すなわち、第1引数として`VkDevice`を伴う)すべてのオブジェクトはそのデバイスに対してプライベートであり、他のデバイスで用いられ **てはならない**。

### オブジェクト寿命 {id="sec:2.3.1"}

オブジェクトは`vkCreate*`や`vkAllocate*`コマンドによってそれぞれ生成または割り当てられる。一度オブジェクトが生成または割り当てられれば、その"構造"は不変であると見なされるが、あるオブジェクト型の中身は依然として自由に変更できる。オブジェクトは`vkDestroy*`や`vkFree*`コマンドによってそれぞれ破壊または解放される。

(生成ではなく)割り当てられるオブジェクトは既存のプールオブジェクトまたはメモリヒープからリソースを取り、解放されるときにリソースをそのプールまたはヒープに返す。オブジェクトの生成や破壊は一般に実行時の間に低頻度で発生することが期待される一方で、割り当てや解放は高頻度で発生することが **できる**。プールオブジェクトは割り当てや解放のパフォーマンス改善に適応するのに役立つ。

Vulkanオブジェクトの寿命を追跡することと使用中に破壊しないことのはアプリケーションの責任である。

アプリケーション所有のメモリの所有権は渡されたVulkanコマンドによって即座に取得される。そのようなメモリの所有権はそのコマンドの存続期間の終了時にアプリケーションへ返却 **しなければならない** ため、アプリケーションは、このメモリを取得したすべてのコマンドが返った後すぐに、そのメモリを変更したり開放したりすることが **できる**。

以下のオブジェクト型は、Vulkanコマンドに渡され、生成するのに使われるオブジェクトによってそれ以上にアクセスされないとき、消費される。これらは渡されるいかなるAPIコマンドの存続期間中にも破壊され **てはならない**。

- `VkShaderModule`
- `VkPipelineCache`

他のオブジェクトを生成するために引数として渡される`VkRenderPass`オブジェクトは渡されたコマンドの存続期間の後でそのオブジェクトによってそれ以上にアクセスされない。コマンドバッファで使われる`VkRenderPass`は以下に示される規定に従う。

`VkPipelineLayout`オブジェクトはそれを使うコマンドバッファが記録状態にある間に破壊 **してはならない**。

`VkDescriptorSetLayout`オブジェクトはこのレイアウトを用いて割り当てられたデスクリプタセットで操作するコマンドによってアクセスされ **てもよく**、これらのデスクリプタセットはデスクリプタセットレイアウトが破壊された後に[vkUpdateDescriptorSets](#sec:13.2.4.vkUpdateDescriptorSets)によって更新 **してはならない**。そうでなければ、デスクリプタセットレイアウトはAPIコマンドによって使用中でないいずれかのときに破壊 **できる**。

アプリケーションは他のいかなるVulkanオブジェクト型を、そのオブジェクトがデバイスによって(コマンドバッファの実行などを介して)使い終わるまで、破壊 **してはならない**。

以下のVulkanオブジェクトはそのオブジェクトを使用しているいずれかのコマンドバッファが[待機状態](#sec:5.1)にある間に破壊 **してはならない**。

- `VkEvent`
- `VkQueryPool`
- `VkBuffer`
- `VkBufferView`
- `VkImage`
- `VkImageView`
- `VkPipeline`
- `VkSampler`
- `VkDescriptorPool`
- `VkFramebuffer`
- `VkRenderPass`
- `VkCommandBuffer`
- `VkCommandPool`
- `VkDeviceMemory`
- `VkDescriptorSet`

これらのオブジェクトを破壊しようとすると、[記録または実行状態](#sec:5.1)にあるいずれかのコマンドバッファが動き出し、これらのオブジェクトを使っていると、[不正状態](#sec:5.1)に遷移する。

以下のVulkanオブジェクトはいずれかのキューがそのオブジェクトを使うコマンドを実行している間に破壊 **してはならない**。

- `VkFence`
- `VkSemaphore`
- `VkCommandBuffer`
- `VkCommandPool`

一般に、(コマンドバッファのリセットのような)他のオブジェクトをもう使わないような方法で破壊またはリセットされることを除いたいかなる方法で解放されたオブジェクトを使うオブジェクトがそれ以上に使われない場合に限り、解放されようとしているオブジェクトが他のオブジェクトの使用(例えば、ビューによるリソースの使用、デスクリプタセットによるビューの使用、コマンドバッファによるオブジェクトの使用、リソースへのメモリ割り当てのバインディング)に関与していても、オブジェクトは任意の順序で破壊または解放 **できる**。そのオブジェクトがリセットされていたならば、解放されたオブジェクトを一切用いていないかのように使うことが **できる**。これの例外はオブジェクト間に親子関係が存在するときである。この場合、アプリケーションは、親が破壊されるときにその子供を解放すると明示的に定義される(例えば、下に定義されるような、プールオブジェクトで)ときを除いて、その子オブジェクトを破壊する前に親オブジェクトを破壊 **してはならない**。

`VkCommandPool`オブジェクトは`VkCommandBuffer`オブジェクトの親である。`VkDescriptorPool`オブジェクトは`VkDescriptorSet`オブジェクトの親である。`VkDevice`オブジェクトは多くのオブジェクト型の親である(それらの生成への引数として`VkDevice`を取るすべて)。

以下のVulkanオブジェクトは破壊 **できる** ときに対して固有の制限を持つ。

- `VkQueue`オブジェクトは明示的に破壊 **できない**。代わりに、それらが取得[retrieve]される`VkDevice`オブジェクトが破壊されるときに暗黙的に破壊される。
- プールオブジェクトを破壊すると、そのプールから割り当てられたすべてのオブジェクトが暗黙的に解放される。具体的には、`VkCommandPool`を破壊すると、それから割り当てられたすべての`VkCommandBuffer`が解放され、`VkDescriptorPool`を破壊すると、それから割り当てられたすべての`VkDescriptorSet`が解放される。
- `VkDevice`オブジェクトはそれらから取得されたすべての`VkQueue`オブジェクトがアイドルであり、それらから生成されたすべてのオブジェクトが破壊されたときに破壊 **できる**。これは以下のオブジェクトを含む。
    - `VkFence`
    - `VkSemaphore`
    - `VkEvent`
    - `VkQueryPool`
    - `VkBuffer`
    - `VkBufferView`
    - `VkImage`
    - `VkImageView`
    - `VkShaderModule`
    - `VkPipelineCache`
    - `VkPipeline`
    - `VkPipelineLayout`
    - `VkSampler`
    - `VkDescriptorSetLayout`
    - `VkDescriptorPool`
    - `VkFramebuffer`
    - `VkRenderPass`
    - `VkCommandPool`
    - `VkCommandBuffer`
    - `VkDeviceMemory`
- `VkPhysicalDevice`オブジェクトは明示的に破壊 **できない**。代わりに、それらが取得[retrieve]される`VkInstance`オブジェクトが破壊されるときに暗黙的に破壊される。
- `VkInstance`は、その`VkPhysicalDevice`オブジェクトのいずれかから生成されたすべての`VkDevice`オブジェクトが破壊されれば、破壊 **できる**。

## 2.4

## 2.5

TODO

## 2.6

## 2.7

## 2.8

### 2.8.1 {id="sec:2.8.1"}

# 3

# 4

# 5

<a id="sec:5.reset" />Each command buffer manages ...

# 6 {id="sec:6"}

## 6.1

<a id="sec:6.1.availability" /><a id="sec:6.1.visibility" />Two additional types ...

## 6.2

<a id="sec:6.2.submission_order">*提出順序*</a>
